<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Graph Data Structures and Algorithms</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.4 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Graph Data Structures and Algorithms
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1AdjacencyListGraph.html">AdjacencyListGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">undirected adjacency list graph in the LEMON API  <a href="classvigra_1_1AdjacencyListGraph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvigra_1_1AdjacencyListGraph_1_1ArcMap.html">AdjacencyListGraph::ArcMap&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default arc map  <a href="structvigra_1_1AdjacencyListGraph_1_1ArcMap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvigra_1_1AdjacencyListGraph_1_1EdgeMap.html">AdjacencyListGraph::EdgeMap&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default edge map  <a href="structvigra_1_1AdjacencyListGraph_1_1EdgeMap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html">GridGraph&lt; N, DirectedTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a grid graph in arbitrary dimensions.  <a href="classvigra_1_1GridGraph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvigra_1_1AdjacencyListGraph_1_1NodeMap.html">AdjacencyListGraph::NodeMap&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default node map  <a href="structvigra_1_1AdjacencyListGraph_1_1NodeMap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ShortestPathDijkstra.html">ShortestPathDijkstra&lt; GRAPH, WEIGHT_TYPE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortest path computer  <a href="classvigra_1_1ShortestPathDijkstra.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf99022444cf39abe8093b776c8bd695c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf99022444cf39abe8093b776c8bd695c"></a>
typedef detail::GenericArc<br class="typebreak"/>
&lt; index_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaf99022444cf39abe8093b776c8bd695c">Arc</a></td></tr>
<tr class="memdesc:gaf99022444cf39abe8093b776c8bd695c"><td class="mdescLeft">&#160;</td><td class="mdescRight">arc descriptor <br/></td></tr>
<tr class="separator:gaf99022444cf39abe8093b776c8bd695c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a97ae6fcf1a1bb7611addacd7668368"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a97ae6fcf1a1bb7611addacd7668368"></a>
typedef <br class="typebreak"/>
detail_adjacency_list_graph::ArcIt<br class="typebreak"/>
&lt; GraphType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga1a97ae6fcf1a1bb7611addacd7668368">ArcIt</a></td></tr>
<tr class="memdesc:ga1a97ae6fcf1a1bb7611addacd7668368"><td class="mdescLeft">&#160;</td><td class="mdescRight">arc iterator <br/></td></tr>
<tr class="separator:ga1a97ae6fcf1a1bb7611addacd7668368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8184453a810cff881f243eab371c2a60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8184453a810cff881f243eab371c2a60"></a>
typedef detail::GenericEdge<br class="typebreak"/>
&lt; index_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga8184453a810cff881f243eab371c2a60">Edge</a></td></tr>
<tr class="memdesc:ga8184453a810cff881f243eab371c2a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge descriptor <br/></td></tr>
<tr class="separator:ga8184453a810cff881f243eab371c2a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga509ee668f636b17835b049538669ca19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga509ee668f636b17835b049538669ca19"></a>
typedef <br class="typebreak"/>
detail_adjacency_list_graph::ItemIter<br class="typebreak"/>
&lt; GraphType, Edge &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga509ee668f636b17835b049538669ca19">EdgeIt</a></td></tr>
<tr class="memdesc:ga509ee668f636b17835b049538669ca19"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge iterator <br/></td></tr>
<tr class="separator:ga509ee668f636b17835b049538669ca19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ffd5fe40f727884040370f1f9dd637"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41ffd5fe40f727884040370f1f9dd637"></a>
typedef <br class="typebreak"/>
detail::GenericIncEdgeIt<br class="typebreak"/>
&lt; GraphType, NodeStorage, <br class="typebreak"/>
InFlter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga41ffd5fe40f727884040370f1f9dd637">InArcIt</a></td></tr>
<tr class="memdesc:ga41ffd5fe40f727884040370f1f9dd637"><td class="mdescLeft">&#160;</td><td class="mdescRight">incoming arc iterator <br/></td></tr>
<tr class="separator:ga41ffd5fe40f727884040370f1f9dd637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1773bf932046141180cff1b90ef6537"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac1773bf932046141180cff1b90ef6537"></a>
typedef <br class="typebreak"/>
detail::GenericIncEdgeIt<br class="typebreak"/>
&lt; GraphType, NodeStorage, <br class="typebreak"/>
IncFilter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gac1773bf932046141180cff1b90ef6537">IncEdgeIt</a></td></tr>
<tr class="memdesc:gac1773bf932046141180cff1b90ef6537"><td class="mdescLeft">&#160;</td><td class="mdescRight">incident edge iterator <br/></td></tr>
<tr class="separator:gac1773bf932046141180cff1b90ef6537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e9be29986bdfdbda472a95357e8da9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0e9be29986bdfdbda472a95357e8da9f"></a>
typedef detail::GenericNode<br class="typebreak"/>
&lt; index_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga0e9be29986bdfdbda472a95357e8da9f">Node</a></td></tr>
<tr class="memdesc:ga0e9be29986bdfdbda472a95357e8da9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">node descriptor <br/></td></tr>
<tr class="separator:ga0e9be29986bdfdbda472a95357e8da9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5dcb437584820e32a34107b3b794b61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac5dcb437584820e32a34107b3b794b61"></a>
typedef <br class="typebreak"/>
detail_adjacency_list_graph::ItemIter<br class="typebreak"/>
&lt; GraphType, Node &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gac5dcb437584820e32a34107b3b794b61">NodeIt</a></td></tr>
<tr class="memdesc:gac5dcb437584820e32a34107b3b794b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">node iterator <br/></td></tr>
<tr class="separator:gac5dcb437584820e32a34107b3b794b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf26da1c2944326fc0900f77f3a2619f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf26da1c2944326fc0900f77f3a2619f2"></a>
typedef <br class="typebreak"/>
detail::GenericIncEdgeIt<br class="typebreak"/>
&lt; GraphType, NodeStorage, <br class="typebreak"/>
OutFilter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaf26da1c2944326fc0900f77f3a2619f2">OutArcIt</a></td></tr>
<tr class="memdesc:gaf26da1c2944326fc0900f77f3a2619f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">outgoing arc iterator <br/></td></tr>
<tr class="separator:gaf26da1c2944326fc0900f77f3a2619f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9337178b0a2edda7de11a5d963999d99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9337178b0a2edda7de11a5d963999d99"></a>
typedef <br class="typebreak"/>
detail::GenericIncEdgeIt<br class="typebreak"/>
&lt; GraphType, NodeStorage, <br class="typebreak"/>
BackOutFilter &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga9337178b0a2edda7de11a5d963999d99">OutBackArcIt</a></td></tr>
<tr class="memdesc:ga9337178b0a2edda7de11a5d963999d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">outgoing back arc iterator <br/></td></tr>
<tr class="separator:ga9337178b0a2edda7de11a5d963999d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga051fdb7fbf0c445a26c9e99fa73f9064"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga051fdb7fbf0c445a26c9e99fa73f9064">AdjacencyListGraph</a> (const size_t nodes=0, const size_t edges=0)</td></tr>
<tr class="separator:ga051fdb7fbf0c445a26c9e99fa73f9064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4603a13c6197aef468e356e57281c98a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4603a13c6197aef468e356e57281c98a"></a>
Arc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga4603a13c6197aef468e356e57281c98a">arcFromId</a> (const index_type id) const </td></tr>
<tr class="memdesc:ga4603a13c6197aef468e356e57281c98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get arc descriptor for given node ID <em>i</em> (API: LEMON). Return <code>Arc(lemon::INVALID)</code> when the ID does not exist in this graph. <br/></td></tr>
<tr class="separator:ga4603a13c6197aef468e356e57281c98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae82369ef3f9699017a022456a587f22d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae82369ef3f9699017a022456a587f22d"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gae82369ef3f9699017a022456a587f22d">arcNum</a> () const </td></tr>
<tr class="memdesc:gae82369ef3f9699017a022456a587f22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of arcs in this graph (API: LEMON). <br/></td></tr>
<tr class="separator:gae82369ef3f9699017a022456a587f22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8092b6d600e8398f5f271c60e3f4e9d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8092b6d600e8398f5f271c60e3f4e9d1"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga8092b6d600e8398f5f271c60e3f4e9d1">baseNode</a> (const IncEdgeIt &amp;iter) const </td></tr>
<tr class="memdesc:ga8092b6d600e8398f5f271c60e3f4e9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start node of the edge the given iterator is referring to (API: LEMON). <br/></td></tr>
<tr class="separator:ga8092b6d600e8398f5f271c60e3f4e9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74b1e27379fed7852306608b64829deb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga74b1e27379fed7852306608b64829deb"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga74b1e27379fed7852306608b64829deb">baseNode</a> (const OutArcIt &amp;iter) const </td></tr>
<tr class="memdesc:ga74b1e27379fed7852306608b64829deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start node of the edge the given iterator is referring to (API: LEMON). <br/></td></tr>
<tr class="separator:ga74b1e27379fed7852306608b64829deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga479253660987e28105d9446c27c8f0bb"><td class="memTemplParams" colspan="2">template&lt;class GRAPH , class EDGE_WEIGHTS , class SEEDS , class LABELS &gt; </td></tr>
<tr class="memitem:ga479253660987e28105d9446c27c8f0bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga479253660987e28105d9446c27c8f0bb">carvingSegmentation</a> (const GRAPH &amp;g, const EDGE_WEIGHTS &amp;edgeWeights, const SEEDS &amp;seeds, const typename LABELS::Value backgroundLabel, const typename EDGE_WEIGHTS::Value backgroundBias, LABELS &amp;labels)</td></tr>
<tr class="memdesc:ga479253660987e28105d9446c27c8f0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge weighted watersheds Segmentataion  <a href="#ga479253660987e28105d9446c27c8f0bb">More...</a><br/></td></tr>
<tr class="separator:ga479253660987e28105d9446c27c8f0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df648e05bbd7b292bf65e54a93cacbf"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6df648e05bbd7b292bf65e54a93cacbf"></a>
template&lt;class G , class A , class B &gt; </td></tr>
<tr class="memitem:ga6df648e05bbd7b292bf65e54a93cacbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga6df648e05bbd7b292bf65e54a93cacbf">copyEdgeMap</a> (const G &amp;g, const A &amp;a, B &amp;b)</td></tr>
<tr class="memdesc:ga6df648e05bbd7b292bf65e54a93cacbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy a lemon edge map <br/></td></tr>
<tr class="separator:ga6df648e05bbd7b292bf65e54a93cacbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0461a292f8ffc7030457c25f87c0073"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac0461a292f8ffc7030457c25f87c0073"></a>
template&lt;class G , class A , class B &gt; </td></tr>
<tr class="memitem:gac0461a292f8ffc7030457c25f87c0073"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gac0461a292f8ffc7030457c25f87c0073">copyNodeMap</a> (const G &amp;g, const A &amp;a, B &amp;b)</td></tr>
<tr class="memdesc:gac0461a292f8ffc7030457c25f87c0073"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy a lemon node map <br/></td></tr>
<tr class="separator:gac0461a292f8ffc7030457c25f87c0073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd4ffb49d6489338d607b5f24b7e419"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabcd4ffb49d6489338d607b5f24b7e419"></a>
Arc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gabcd4ffb49d6489338d607b5f24b7e419">direct</a> (const Edge &amp;edge, const bool forward) const </td></tr>
<tr class="memdesc:gabcd4ffb49d6489338d607b5f24b7e419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an arc for the given edge <em>e</em>, oriented along the edge's natural (<code>forward = true</code>) or reversed (<code>forward = false</code>) direction (API: LEMON). <br/></td></tr>
<tr class="separator:gabcd4ffb49d6489338d607b5f24b7e419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845d3a2e39b5cbfb9f328311b2ac8e30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga845d3a2e39b5cbfb9f328311b2ac8e30"></a>
Arc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga845d3a2e39b5cbfb9f328311b2ac8e30">direct</a> (const Edge &amp;edge, const Node &amp;node) const </td></tr>
<tr class="memdesc:ga845d3a2e39b5cbfb9f328311b2ac8e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an arc for the given edge <em>e</em> oriented so that node <em>n</em> is the starting node of the arc (API: LEMON), or return <code>lemon::INVALID</code> if the edge is not incident to this node. <br/></td></tr>
<tr class="separator:ga845d3a2e39b5cbfb9f328311b2ac8e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5652b5472e1fec81528709dcd540ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b5652b5472e1fec81528709dcd540ee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga3b5652b5472e1fec81528709dcd540ee">direction</a> (const Arc &amp;arc) const </td></tr>
<tr class="memdesc:ga3b5652b5472e1fec81528709dcd540ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> when the arc is looking on the underlying edge in its natural (i.e. forward) direction, <code>false</code> otherwise (API: LEMON). <br/></td></tr>
<tr class="separator:ga3b5652b5472e1fec81528709dcd540ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8c60544340cd8c4b8b88ef3744da9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7d8c60544340cd8c4b8b88ef3744da9a"></a>
Edge&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga7d8c60544340cd8c4b8b88ef3744da9a">edgeFromId</a> (const index_type id) const </td></tr>
<tr class="memdesc:ga7d8c60544340cd8c4b8b88ef3744da9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get edge descriptor for given node ID <em>i</em> (API: LEMON). Return <code>Edge(lemon::INVALID)</code> when the ID does not exist in this graph. <br/></td></tr>
<tr class="separator:ga7d8c60544340cd8c4b8b88ef3744da9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb5a73206ef443e691b2d0fe02c32963"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb5a73206ef443e691b2d0fe02c32963"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gabb5a73206ef443e691b2d0fe02c32963">edgeNum</a> () const </td></tr>
<tr class="memdesc:gabb5a73206ef443e691b2d0fe02c32963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges in this graph (API: LEMON). <br/></td></tr>
<tr class="separator:gabb5a73206ef443e691b2d0fe02c32963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf2d9ac4f45fe58fa403af7c0821b38"><td class="memTemplParams" colspan="2">template&lt;class GRAPH , class WEIGHTS , class COMPERATOR &gt; </td></tr>
<tr class="memitem:ga5cf2d9ac4f45fe58fa403af7c0821b38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga5cf2d9ac4f45fe58fa403af7c0821b38">edgeSort</a> (const GRAPH &amp;g, const WEIGHTS &amp;weights, const COMPERATOR &amp;comperator, std::vector&lt; typename GRAPH::Edge &gt; &amp;sortedEdges)</td></tr>
<tr class="memdesc:ga5cf2d9ac4f45fe58fa403af7c0821b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a vector of Edge descriptors  <a href="#ga5cf2d9ac4f45fe58fa403af7c0821b38">More...</a><br/></td></tr>
<tr class="separator:ga5cf2d9ac4f45fe58fa403af7c0821b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c146d157be5221477d8efb6943623a"><td class="memTemplParams" colspan="2">template&lt;class GRAPH , class EDGE_WEIGHTS , class SEEDS , class LABELS &gt; </td></tr>
<tr class="memitem:ga67c146d157be5221477d8efb6943623a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga67c146d157be5221477d8efb6943623a">edgeWeightedWatershedsSegmentation</a> (const GRAPH &amp;g, const EDGE_WEIGHTS &amp;edgeWeights, const SEEDS &amp;seeds, LABELS &amp;labels)</td></tr>
<tr class="memdesc:ga67c146d157be5221477d8efb6943623a"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge weighted watersheds Segmentataion  <a href="#ga67c146d157be5221477d8efb6943623a">More...</a><br/></td></tr>
<tr class="separator:ga67c146d157be5221477d8efb6943623a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab6c54335f12cd7da2798eb5a2177910"><td class="memTemplParams" colspan="2">template&lt;unsigned int N, class DirectedTag , class T , class EDGEMAP &gt; </td></tr>
<tr class="memitem:gaab6c54335f12cd7da2798eb5a2177910"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaab6c54335f12cd7da2798eb5a2177910">edgeWeightsFromInterpolatedImage</a> (const GridGraph&lt; N, DirectedTag &gt; &amp;g, const MultiArrayView&lt; N, T &gt; &amp;interpolatedImage, EDGEMAP &amp;edgeWeights, bool euclidean=false)</td></tr>
<tr class="memdesc:gaab6c54335f12cd7da2798eb5a2177910"><td class="mdescLeft">&#160;</td><td class="mdescRight">create edge weights from an interpolated image  <a href="#gaab6c54335f12cd7da2798eb5a2177910">More...</a><br/></td></tr>
<tr class="separator:gaab6c54335f12cd7da2798eb5a2177910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb6612859f47b018b2eaa6a6cd24a5ea"><td class="memTemplParams" colspan="2">template&lt;unsigned int N, class DirectedTag , class NODEMAP , class EDGEMAP , class FUNCTOR &gt; </td></tr>
<tr class="memitem:gadb6612859f47b018b2eaa6a6cd24a5ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gadb6612859f47b018b2eaa6a6cd24a5ea">edgeWeightsFromNodeWeights</a> (const GridGraph&lt; N, DirectedTag &gt; &amp;g, const NODEMAP &amp;nodeWeights, EDGEMAP &amp;edgeWeights, bool euclidean, FUNCTOR const &amp;func)</td></tr>
<tr class="memdesc:gadb6612859f47b018b2eaa6a6cd24a5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">create edge weights from node weights  <a href="#gadb6612859f47b018b2eaa6a6cd24a5ea">More...</a><br/></td></tr>
<tr class="separator:gadb6612859f47b018b2eaa6a6cd24a5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3db8b23fe023c6493405ae4f8a3cf60"><td class="memTemplParams" colspan="2">template&lt;class GRAPH , class EDGE_WEIGHTS , class NODE_SIZE , class NODE_LABEL_MAP &gt; </td></tr>
<tr class="memitem:gac3db8b23fe023c6493405ae4f8a3cf60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gac3db8b23fe023c6493405ae4f8a3cf60">felzenszwalbSegmentation</a> (const GRAPH &amp;graph, const EDGE_WEIGHTS &amp;edgeWeights, const NODE_SIZE &amp;nodeSizes, float k, NODE_LABEL_MAP &amp;nodeLabeling, const int nodeNumStopCond=-1)</td></tr>
<tr class="memdesc:gac3db8b23fe023c6493405ae4f8a3cf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge weighted watersheds Segmentataion  <a href="#gac3db8b23fe023c6493405ae4f8a3cf60">More...</a><br/></td></tr>
<tr class="separator:gac3db8b23fe023c6493405ae4f8a3cf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab987a63a328ffd395970d3080a8a501b"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab987a63a328ffd395970d3080a8a501b"></a>
template&lt;class G , class A , class T &gt; </td></tr>
<tr class="memitem:gab987a63a328ffd395970d3080a8a501b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gab987a63a328ffd395970d3080a8a501b">fillEdgeMap</a> (const G &amp;g, A &amp;a, const T &amp;value)</td></tr>
<tr class="memdesc:gab987a63a328ffd395970d3080a8a501b"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill a lemon edge map <br/></td></tr>
<tr class="separator:gab987a63a328ffd395970d3080a8a501b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219158b1d271342c96ad37d96a0f8997"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga219158b1d271342c96ad37d96a0f8997"></a>
template&lt;class G , class A , class T &gt; </td></tr>
<tr class="memitem:ga219158b1d271342c96ad37d96a0f8997"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga219158b1d271342c96ad37d96a0f8997">fillNodeMap</a> (const G &amp;g, A &amp;a, const T &amp;value)</td></tr>
<tr class="memdesc:ga219158b1d271342c96ad37d96a0f8997"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill a lemon node map <br/></td></tr>
<tr class="separator:ga219158b1d271342c96ad37d96a0f8997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd71fa51f2c89e97b3562aa88bfc06e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9dd71fa51f2c89e97b3562aa88bfc06e"></a>
Arc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga9dd71fa51f2c89e97b3562aa88bfc06e">findArc</a> (const Node &amp;u, const Node &amp;v) const </td></tr>
<tr class="memdesc:ga9dd71fa51f2c89e97b3562aa88bfc06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a descriptor for the arc connecting vertices <em>u</em> and <em>v</em>,<br/>
or <code>lemon::INVALID</code> if no such edge exists (API: LEMON). <br/></td></tr>
<tr class="separator:ga9dd71fa51f2c89e97b3562aa88bfc06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae854581b9788068b45a560dde7b59b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeae854581b9788068b45a560dde7b59b"></a>
Edge&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaeae854581b9788068b45a560dde7b59b">findEdge</a> (const Node &amp;a, const Node &amp;b) const </td></tr>
<tr class="memdesc:gaeae854581b9788068b45a560dde7b59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a descriptor for the edge connecting vertices <em>u</em> and <em>v</em>,<br/>
or <code>lemon::INVALID</code> if no such edge exists (API: LEMON). <br/></td></tr>
<tr class="separator:gaeae854581b9788068b45a560dde7b59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae576b3bc3a6baeb6518cca788035d9d3"><td class="memTemplParams" colspan="2">template&lt;class GRAPH , class NODE_FEATURES_IN , class EDGE_INDICATOR , class NODE_FEATURES_OUT &gt; </td></tr>
<tr class="memitem:gae576b3bc3a6baeb6518cca788035d9d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gae576b3bc3a6baeb6518cca788035d9d3">graphSmoothing</a> (const GRAPH &amp;g, const NODE_FEATURES_IN &amp;nodeFeaturesIn, const EDGE_INDICATOR &amp;edgeIndicator, const float lambda, const float edgeThreshold, const float scale, NODE_FEATURES_OUT &amp;nodeFeaturesOut)</td></tr>
<tr class="memdesc:gae576b3bc3a6baeb6518cca788035d9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">smooth node features of a graph  <a href="#gae576b3bc3a6baeb6518cca788035d9d3">More...</a><br/></td></tr>
<tr class="separator:gae576b3bc3a6baeb6518cca788035d9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c52213c916e738367e4efe23f579c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf8c52213c916e738367e4efe23f579c1"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaf8c52213c916e738367e4efe23f579c1">id</a> (const Node &amp;node) const </td></tr>
<tr class="memdesc:gaf8c52213c916e738367e4efe23f579c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID for node desciptor <em>v</em> (API: LEMON). <br/></td></tr>
<tr class="separator:gaf8c52213c916e738367e4efe23f579c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6682057e4d1351e841287f618a7140fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6682057e4d1351e841287f618a7140fa"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga6682057e4d1351e841287f618a7140fa">id</a> (const Edge &amp;edge) const </td></tr>
<tr class="memdesc:ga6682057e4d1351e841287f618a7140fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID for edge desciptor <em>v</em> (API: LEMON). <br/></td></tr>
<tr class="separator:ga6682057e4d1351e841287f618a7140fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0de8c72261cd393ab8777ba02999780"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf0de8c72261cd393ab8777ba02999780"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaf0de8c72261cd393ab8777ba02999780">id</a> (const Arc &amp;arc) const </td></tr>
<tr class="memdesc:gaf0de8c72261cd393ab8777ba02999780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID for arc desciptor <em>v</em> (API: LEMON). <br/></td></tr>
<tr class="separator:gaf0de8c72261cd393ab8777ba02999780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e4a082419162804528250e835f0b0f"><td class="memTemplParams" colspan="2">template&lt;class GRAPH_IN , class GRAPH_IN_NODE_LABEL_MAP &gt; </td></tr>
<tr class="memitem:gac2e4a082419162804528250e835f0b0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gac2e4a082419162804528250e835f0b0f">makeRegionAdjacencyGraph</a> (GRAPH_IN graphIn, GRAPH_IN_NODE_LABEL_MAP labels, AdjacencyListGraph &amp;rag, typename AdjacencyListGraph::template EdgeMap&lt; std::vector&lt; typename GRAPH_IN::Edge &gt; &gt; &amp;affiliatedEdges, const Int64 ignoreLabel=-1)</td></tr>
<tr class="memdesc:gac2e4a082419162804528250e835f0b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a region adjacency graph from a graph and labels w.r.t. that graph  <a href="#gac2e4a082419162804528250e835f0b0f">More...</a><br/></td></tr>
<tr class="separator:gac2e4a082419162804528250e835f0b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8180ead78023a62efb6a27046166aaa8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8180ead78023a62efb6a27046166aaa8"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga8180ead78023a62efb6a27046166aaa8">maxArcId</a> () const </td></tr>
<tr class="memdesc:ga8180ead78023a62efb6a27046166aaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum ID of any edge in arc graph (API: LEMON). <br/></td></tr>
<tr class="separator:ga8180ead78023a62efb6a27046166aaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ee497cea3ca55feba6a1a9f62c96a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29ee497cea3ca55feba6a1a9f62c96a1"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga29ee497cea3ca55feba6a1a9f62c96a1">maxEdgeId</a> () const </td></tr>
<tr class="memdesc:ga29ee497cea3ca55feba6a1a9f62c96a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum ID of any edge in this graph (API: LEMON). <br/></td></tr>
<tr class="separator:ga29ee497cea3ca55feba6a1a9f62c96a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125fa90a1534b92b81d4112cbbe9bb0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga125fa90a1534b92b81d4112cbbe9bb0b"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga125fa90a1534b92b81d4112cbbe9bb0b">maxNodeId</a> () const </td></tr>
<tr class="memdesc:ga125fa90a1534b92b81d4112cbbe9bb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum ID of any node in this graph (API: LEMON). <br/></td></tr>
<tr class="separator:ga125fa90a1534b92b81d4112cbbe9bb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga018e4d5adb0601354d6cceb57c48b129"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga018e4d5adb0601354d6cceb57c48b129"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga018e4d5adb0601354d6cceb57c48b129">nodeFromId</a> (const index_type id) const </td></tr>
<tr class="memdesc:ga018e4d5adb0601354d6cceb57c48b129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node descriptor for given node ID <em>i</em> (API: LEMON). Return <code>Node(lemon::INVALID)</code> when the ID does not exist in this graph. <br/></td></tr>
<tr class="separator:ga018e4d5adb0601354d6cceb57c48b129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4266e6050f3b3b310d2f7523e046ac85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4266e6050f3b3b310d2f7523e046ac85"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga4266e6050f3b3b310d2f7523e046ac85">nodeNum</a> () const </td></tr>
<tr class="memdesc:ga4266e6050f3b3b310d2f7523e046ac85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nodes in this graph (API: LEMON). <br/></td></tr>
<tr class="separator:ga4266e6050f3b3b310d2f7523e046ac85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75b06521f0e3497e16c998d938af5fb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga75b06521f0e3497e16c998d938af5fb6"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga75b06521f0e3497e16c998d938af5fb6">oppositeNode</a> (Node const &amp;n, const Edge &amp;e) const </td></tr>
<tr class="memdesc:ga75b06521f0e3497e16c998d938af5fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the opposite node of the given node <em>n</em> along edge <em>e</em> (API: LEMON), or return <code>lemon::INVALID</code> if the edge is not incident to this node. <br/></td></tr>
<tr class="separator:ga75b06521f0e3497e16c998d938af5fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74f4759ba0a1c275eebe78b9eefc0e09"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga74f4759ba0a1c275eebe78b9eefc0e09"></a>
template&lt;class NODE , class PREDECESSORS &gt; </td></tr>
<tr class="memitem:ga74f4759ba0a1c275eebe78b9eefc0e09"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga74f4759ba0a1c275eebe78b9eefc0e09">pathLength</a> (const NODE source, const NODE target, const PREDECESSORS &amp;predecessors)</td></tr>
<tr class="memdesc:ga74f4759ba0a1c275eebe78b9eefc0e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the length in node units of a path <br/></td></tr>
<tr class="separator:ga74f4759ba0a1c275eebe78b9eefc0e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82e3a5b4c468e99f8cbbe2f3fd17a827"><td class="memTemplParams" colspan="2">template&lt;class RAG , class BASE_GRAPH , class BASE_GRAPH_RAG_LABELS , class BASE_GRAPH_GT , class RAG_GT , class RAG_GT_QT &gt; </td></tr>
<tr class="memitem:ga82e3a5b4c468e99f8cbbe2f3fd17a827"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga82e3a5b4c468e99f8cbbe2f3fd17a827">projectGroundTruth</a> (const RAG &amp;rag, const BASE_GRAPH &amp;baseGraph, const BASE_GRAPH_RAG_LABELS &amp;baseGraphRagLabels, const BASE_GRAPH_GT &amp;baseGraphGt, RAG_GT &amp;ragGt, RAG_GT_QT &amp;ragGtQt)</td></tr>
<tr class="separator:ga82e3a5b4c468e99f8cbbe2f3fd17a827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5146deb4665a1cff08bc087ad4b091"><td class="memTemplParams" colspan="2">template&lt;class GRAPH , class NODE_FEATURES_IN , class EDGE_INDICATOR , class NODE_FEATURES_OUT &gt; </td></tr>
<tr class="memitem:gaec5146deb4665a1cff08bc087ad4b091"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaec5146deb4665a1cff08bc087ad4b091">recursiveGraphSmoothing</a> (const GRAPH &amp;g, const NODE_FEATURES_IN &amp;nodeFeaturesIn, const EDGE_INDICATOR &amp;edgeIndicator, const float lambda, const float edgeThreshold, const float scale, size_t iterations, NODE_FEATURES_OUT &amp;nodeFeaturesBuffer, NODE_FEATURES_OUT &amp;nodeFeaturesOut)</td></tr>
<tr class="memdesc:gaec5146deb4665a1cff08bc087ad4b091"><td class="mdescLeft">&#160;</td><td class="mdescRight">smooth node features of a graph  <a href="#gaec5146deb4665a1cff08bc087ad4b091">More...</a><br/></td></tr>
<tr class="separator:gaec5146deb4665a1cff08bc087ad4b091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb75ebc0b1d25c176e7e6b4884db1b96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeb75ebc0b1d25c176e7e6b4884db1b96"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaeb75ebc0b1d25c176e7e6b4884db1b96">runningNode</a> (const IncEdgeIt &amp;iter) const </td></tr>
<tr class="memdesc:gaeb75ebc0b1d25c176e7e6b4884db1b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end node of the edge the given iterator is referring to (API: LEMON). <br/></td></tr>
<tr class="separator:gaeb75ebc0b1d25c176e7e6b4884db1b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf16981dabfb091adcff82c5a9fde83a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf16981dabfb091adcff82c5a9fde83a3"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaf16981dabfb091adcff82c5a9fde83a3">runningNode</a> (const OutArcIt &amp;iter) const </td></tr>
<tr class="memdesc:gaf16981dabfb091adcff82c5a9fde83a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end node of the edge the given iterator is referring to (API: LEMON). <br/></td></tr>
<tr class="separator:gaf16981dabfb091adcff82c5a9fde83a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae55d4b94f1300b962ac7e9b4dfd75575"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae55d4b94f1300b962ac7e9b4dfd75575"></a>
template&lt;class GRAPH , class WEIGHTS , class PREDECESSORS , class DISTANCE , class HEURSTIC &gt; </td></tr>
<tr class="memitem:gae55d4b94f1300b962ac7e9b4dfd75575"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gae55d4b94f1300b962ac7e9b4dfd75575">shortestPathAStar</a> (const GRAPH &amp;graph, const typename GRAPH::Node &amp;source, const typename GRAPH::Node &amp;target, const WEIGHTS &amp;weights, PREDECESSORS &amp;predecessors, DISTANCE &amp;distance, const HEURSTIC &amp;heuristic)</td></tr>
<tr class="memdesc:gae55d4b94f1300b962ac7e9b4dfd75575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Astar Shortest path search. <br/></td></tr>
<tr class="separator:gae55d4b94f1300b962ac7e9b4dfd75575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8bb6d3578149171ee50de591b4643b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf8bb6d3578149171ee50de591b4643b4"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaf8bb6d3578149171ee50de591b4643b4">source</a> (const Arc &amp;arc) const </td></tr>
<tr class="memdesc:gaf8bb6d3578149171ee50de591b4643b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start node of the given arc <em>a</em> (API: LEMON). <br/></td></tr>
<tr class="separator:gaf8bb6d3578149171ee50de591b4643b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ae431a1e12905978ee64c47cfa0278"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac4ae431a1e12905978ee64c47cfa0278"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gac4ae431a1e12905978ee64c47cfa0278">target</a> (const Arc &amp;arc) const </td></tr>
<tr class="memdesc:gac4ae431a1e12905978ee64c47cfa0278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end node of the given arc <em>a</em> (API: LEMON). <br/></td></tr>
<tr class="separator:gac4ae431a1e12905978ee64c47cfa0278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa15defbad1ddb4a1e042c93486611256"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa15defbad1ddb4a1e042c93486611256"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaa15defbad1ddb4a1e042c93486611256">u</a> (const Edge &amp;edge) const </td></tr>
<tr class="memdesc:gaa15defbad1ddb4a1e042c93486611256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start node of the given edge <em>e</em> (API: LEMON,<br/>
 the boost::graph API provides the free function <code>boost::source(e, graph)</code>). <br/></td></tr>
<tr class="separator:gaa15defbad1ddb4a1e042c93486611256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e52752fea99a66d8b4f2d06c64de533"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2e52752fea99a66d8b4f2d06c64de533"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga2e52752fea99a66d8b4f2d06c64de533">v</a> (const Edge &amp;edge) const </td></tr>
<tr class="memdesc:ga2e52752fea99a66d8b4f2d06c64de533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end node of the given edge <em>e</em> (API: LEMON,<br/>
 the boost::graph API provides the free function <code>boost::target(e, graph)</code>). <br/></td></tr>
<tr class="separator:ga2e52752fea99a66d8b4f2d06c64de533"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<p>Graph algorithms and the underlying graph data structures (e.g. <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a> and <a class="el" href="classvigra_1_1AdjacencyListGraph.html" title="undirected adjacency list graph in the LEMON API ">AdjacencyListGraph</a>) implementing the APIs of the <a href="http://www.boost.org/doc/libs/release/libs/graph/">boost::graph</a> and <a href="http://lemon.cs.elte.hu/">LEMON</a> libraries.</p>
<p>See also the <a class="el" href="group__BoostGraphExtensions.html">GridGraph additions to namespace <code>boost</code></a>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga051fdb7fbf0c445a26c9e99fa73f9064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AdjacencyListGraph </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>edges</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>construct </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>: reserve space for n nodes </td></tr>
    <tr><td class="paramname">edges</td><td>: reserve space for n edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5cf2d9ac4f45fe58fa403af7c0821b38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::edgeSort </td>
          <td>(</td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WEIGHTS &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMPERATOR &amp;&#160;</td>
          <td class="paramname"><em>comperator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename GRAPH::Edge &gt; &amp;&#160;</td>
          <td class="paramname"><em>sortedEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a vector of Edge descriptors </p>
<p>Sort the Edge descriptors given weights and a comperator </p>

</div>
</div>
<a class="anchor" id="gac2e4a082419162804528250e835f0b0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::makeRegionAdjacencyGraph </td>
          <td>(</td>
          <td class="paramtype">GRAPH_IN&#160;</td>
          <td class="paramname"><em>graphIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GRAPH_IN_NODE_LABEL_MAP&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjacencyListGraph &amp;&#160;</td>
          <td class="paramname"><em>rag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename AdjacencyListGraph::template EdgeMap&lt; std::vector&lt; typename GRAPH_IN::Edge &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>affiliatedEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int64&#160;</td>
          <td class="paramname"><em>ignoreLabel</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make a region adjacency graph from a graph and labels w.r.t. that graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">graphIn</td><td>: input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">labels</td><td>: labels w.r.t. graphIn </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rag</td><td>: region adjacency graph </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">affiliatedEdges</td><td>: a vector of edges of graphIn for each edge in rag </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ignoreLabel</td><td>: optional label to ignore (default: -1 means no label will be ignored) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga67c146d157be5221477d8efb6943623a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::edgeWeightedWatershedsSegmentation </td>
          <td>(</td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EDGE_WEIGHTS &amp;&#160;</td>
          <td class="paramname"><em>edgeWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SEEDS &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LABELS &amp;&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge weighted watersheds Segmentataion </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g,:</td><td>input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeWeights</td><td>: edge weights / edge indicator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seeds</td><td>: seed must be non empty! </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">labels</td><td>: resulting nodeLabeling (not necessarily dense) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga479253660987e28105d9446c27c8f0bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::carvingSegmentation </td>
          <td>(</td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EDGE_WEIGHTS &amp;&#160;</td>
          <td class="paramname"><em>edgeWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SEEDS &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename LABELS::Value&#160;</td>
          <td class="paramname"><em>backgroundLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename EDGE_WEIGHTS::Value&#160;</td>
          <td class="paramname"><em>backgroundBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LABELS &amp;&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge weighted watersheds Segmentataion </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g,:</td><td>input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeWeights</td><td>: edge weights / edge indicator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seeds</td><td>: seed must be non empty! </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">backgroundLabel</td><td>: which label is background </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">backgroundBias</td><td>: bias for background </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">labels</td><td>: resulting nodeLabeling (not necessarily dense) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac3db8b23fe023c6493405ae4f8a3cf60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::felzenszwalbSegmentation </td>
          <td>(</td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EDGE_WEIGHTS &amp;&#160;</td>
          <td class="paramname"><em>edgeWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NODE_SIZE &amp;&#160;</td>
          <td class="paramname"><em>nodeSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_LABEL_MAP &amp;&#160;</td>
          <td class="paramname"><em>nodeLabeling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nodeNumStopCond</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge weighted watersheds Segmentataion </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">graph,:</td><td>input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeWeights</td><td>: edge weights / edge indicator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeSizes</td><td>: size of each node </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">k</td><td>: free parameter of felzenszwalb algorithm </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeLabeling</td><td>: nodeLabeling (not necessarily dense) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeNumStopCond</td><td>: optional stopping condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae576b3bc3a6baeb6518cca788035d9d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::graphSmoothing </td>
          <td>(</td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NODE_FEATURES_IN &amp;&#160;</td>
          <td class="paramname"><em>nodeFeaturesIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EDGE_INDICATOR &amp;&#160;</td>
          <td class="paramname"><em>edgeIndicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>edgeThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_FEATURES_OUT &amp;&#160;</td>
          <td class="paramname"><em>nodeFeaturesOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smooth node features of a graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g</td><td>: input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeFeaturesIn</td><td>: input node features which should be smoothed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeIndicator</td><td>: edge indicator to indicate over which edges one should smooth </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lambda</td><td>: scale edge indicator by lambda bevore taking negative exponent </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeThreshold</td><td>: edge threshold </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">scale</td><td>: how much smoothing should be applied </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeFeaturesOut</td><td>: smoothed node features </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec5146deb4665a1cff08bc087ad4b091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::recursiveGraphSmoothing </td>
          <td>(</td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NODE_FEATURES_IN &amp;&#160;</td>
          <td class="paramname"><em>nodeFeaturesIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EDGE_INDICATOR &amp;&#160;</td>
          <td class="paramname"><em>edgeIndicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>edgeThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_FEATURES_OUT &amp;&#160;</td>
          <td class="paramname"><em>nodeFeaturesBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_FEATURES_OUT &amp;&#160;</td>
          <td class="paramname"><em>nodeFeaturesOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smooth node features of a graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g</td><td>: input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeFeaturesIn</td><td>: input node features which should be smoothed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeIndicator</td><td>: edge indicator to indicate over which edges one should smooth </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lambda</td><td>: scale edge indicator by lambda bevore taking negative exponent </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeThreshold</td><td>: edge threshold </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">scale</td><td>: how much smoothing should be applied </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">iterations</td><td>: how often should this algorithm be called recursively </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeFeaturesBuffer</td><td>: preallocated(!) buffer to store node features temp. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeFeaturesOut</td><td>: smoothed node features </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga82e3a5b4c468e99f8cbbe2f3fd17a827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::projectGroundTruth </td>
          <td>(</td>
          <td class="paramtype">const RAG &amp;&#160;</td>
          <td class="paramname"><em>rag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BASE_GRAPH &amp;&#160;</td>
          <td class="paramname"><em>baseGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BASE_GRAPH_RAG_LABELS &amp;&#160;</td>
          <td class="paramname"><em>baseGraphRagLabels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BASE_GRAPH_GT &amp;&#160;</td>
          <td class="paramname"><em>baseGraphGt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAG_GT &amp;&#160;</td>
          <td class="paramname"><em>ragGt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAG_GT_QT &amp;&#160;</td>
          <td class="paramname"><em>ragGtQt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>project ground truth from a base graph, to a region adjacency graph. </p>

</div>
</div>
<a class="anchor" id="gadb6612859f47b018b2eaa6a6cd24a5ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::edgeWeightsFromNodeWeights </td>
          <td>(</td>
          <td class="paramtype">const GridGraph&lt; N, DirectedTag &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NODEMAP &amp;&#160;</td>
          <td class="paramname"><em>nodeWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EDGEMAP &amp;&#160;</td>
          <td class="paramname"><em>edgeWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>euclidean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create edge weights from node weights </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g</td><td>: input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeWeights</td><td>: node property map holding node weights </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edgeWeights</td><td>: resulting edge weights </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">euclidean</td><td>: if 'true', multiply the computed weights with the Euclidean distance between the edge's end nodes (default: 'false') </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">func</td><td>: binary function that computes the edge weight from the weights of the edge's end nodes (default: take the average) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab6c54335f12cd7da2798eb5a2177910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::edgeWeightsFromInterpolatedImage </td>
          <td>(</td>
          <td class="paramtype">const GridGraph&lt; N, DirectedTag &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArrayView&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolatedImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EDGEMAP &amp;&#160;</td>
          <td class="paramname"><em>edgeWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>euclidean</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create edge weights from an interpolated image </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g</td><td>: input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">interpolatedImage</td><td>: interpolated image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edgeWeights</td><td>: edge weights </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">euclidean</td><td>: if 'true', multiply the weights with the Euclidean distance between the edge's end nodes (default: 'false')</td></tr>
  </table>
  </dd>
</dl>
<p>For each edge, the function reads the weight from <code>interpolatedImage[u+v]</code>, where <code>u</code> and <code>v</code> are the coordinates of the edge's end points. </p>

</div>
</div>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.10.0 (Thu Jan 8 2015)
</i>
</tr>
</table>
</BODY>
</HTML>
