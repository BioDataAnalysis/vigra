<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Mathematical Functions</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
<script>
var runOnLoad=function(c,o,d,e){function x(){for(e=1;c.length;)c.shift()()}o[d]?(document[d]('DOMContentLoaded',x,0),o[d]('load',x,0)):o.attachEvent('onload',x);return function(t){e?o.setTimeout(t,0):c.push(t)}}([],window,'addEventListener');
</script>
<script type="text/javascript" src="documents/CollapsibleLists.js"></script>
<script type="text/javascript">
    runOnLoad(function(){ CollapsibleLists.apply(); });
</script>
<style type="text/css">
.collapsibleList li.collapsibleListOpen{
  list-style-image:url('documents/pfeil.gif');
  cursor:pointer;
}
.collapsibleList li.collapsibleListClosed{
  list-style-image:url('documents/bullet.gif');
  cursor:pointer;
}
.collapsibleList li.lastItem{
  list-style-image:url('documents/diamond.gif');
}
</style>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://ukoethe.github.io/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Mathematical Functions
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevigra"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevigra.html">vigra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BSpline.html">BSpline&lt; ORDER, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BSplineBase.html">BSplineBase&lt; ORDER, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1CatmullRomSpline.html">CatmullRomSpline&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1CoscotFunction.html">CoscotFunction&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Gaussian.html">Gaussian&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8686fee88c6f46f3e19a76f00826dc10"><td class="memTemplParams" colspan="2">template&lt;class IndexIterator , class InIterator , class OutIterator &gt; </td></tr>
<tr class="memitem:ga8686fee88c6f46f3e19a76f00826dc10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga8686fee88c6f46f3e19a76f00826dc10">applyPermutation</a> (IndexIterator index_first, IndexIterator index_last, InIterator in, OutIterator out)</td></tr>
<tr class="memdesc:ga8686fee88c6f46f3e19a76f00826dc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort an array according to the given index permutation.  <a href="#ga8686fee88c6f46f3e19a76f00826dc10">More...</a><br/></td></tr>
<tr class="separator:ga8686fee88c6f46f3e19a76f00826dc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf658d43400902a049a289c4e5ded84d9"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:gaf658d43400902a049a289c4e5ded84d9"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaf658d43400902a049a289c4e5ded84d9">argMax</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:gaf658d43400902a049a289c4e5ded84d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximum element in a sequence.  <a href="#gaf658d43400902a049a289c4e5ded84d9">More...</a><br/></td></tr>
<tr class="separator:gaf658d43400902a049a289c4e5ded84d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe67abfb62abdfc09a8e1e47a87485ea"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class UnaryFunctor &gt; </td></tr>
<tr class="memitem:gafe67abfb62abdfc09a8e1e47a87485ea"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gafe67abfb62abdfc09a8e1e47a87485ea">argMaxIf</a> (Iterator first, Iterator last, UnaryFunctor condition)</td></tr>
<tr class="memdesc:gafe67abfb62abdfc09a8e1e47a87485ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the maximum element in a sequence conforming to a condition.  <a href="#gafe67abfb62abdfc09a8e1e47a87485ea">More...</a><br/></td></tr>
<tr class="separator:gafe67abfb62abdfc09a8e1e47a87485ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad84c74edbd392ac2035df2a6d583fc05"><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:gad84c74edbd392ac2035df2a6d583fc05"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gad84c74edbd392ac2035df2a6d583fc05">argMin</a> (Iterator first, Iterator last)</td></tr>
<tr class="memdesc:gad84c74edbd392ac2035df2a6d583fc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum element in a sequence.  <a href="#gad84c74edbd392ac2035df2a6d583fc05">More...</a><br/></td></tr>
<tr class="separator:gad84c74edbd392ac2035df2a6d583fc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d791e8c9cac48509aa4e1557ecf676"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class UnaryFunctor &gt; </td></tr>
<tr class="memitem:ga45d791e8c9cac48509aa4e1557ecf676"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga45d791e8c9cac48509aa4e1557ecf676">argMinIf</a> (Iterator first, Iterator last, UnaryFunctor condition)</td></tr>
<tr class="memdesc:ga45d791e8c9cac48509aa4e1557ecf676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the minimum element in a sequence conforming to a condition.  <a href="#ga45d791e8c9cac48509aa4e1557ecf676">More...</a><br/></td></tr>
<tr class="separator:ga45d791e8c9cac48509aa4e1557ecf676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cf8d64d518f2d493bee81d886906cdf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga9cf8d64d518f2d493bee81d886906cdf">besselJ</a> (int n, double x)</td></tr>
<tr class="memdesc:ga9cf8d64d518f2d493bee81d886906cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bessel function of the first kind.  <a href="#ga9cf8d64d518f2d493bee81d886906cdf">More...</a><br/></td></tr>
<tr class="separator:ga9cf8d64d518f2d493bee81d886906cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d85515af4527b6922f14a853fe40d3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga84d85515af4527b6922f14a853fe40d3">besselY</a> (int n, double x)</td></tr>
<tr class="memdesc:ga84d85515af4527b6922f14a853fe40d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bessel function of the second kind.  <a href="#ga84d85515af4527b6922f14a853fe40d3">More...</a><br/></td></tr>
<tr class="separator:ga84d85515af4527b6922f14a853fe40d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54aeb0113ef25c8a4f2e72a1acc794c5"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga54aeb0113ef25c8a4f2e72a1acc794c5">ceilPower2</a> (UInt32 x)</td></tr>
<tr class="memdesc:ga54aeb0113ef25c8a4f2e72a1acc794c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round up to the nearest power of 2.  <a href="#ga54aeb0113ef25c8a4f2e72a1acc794c5">More...</a><br/></td></tr>
<tr class="separator:ga54aeb0113ef25c8a4f2e72a1acc794c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga482d2e82f374a8758cd516d19f4c3424"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga482d2e82f374a8758cd516d19f4c3424">checksum</a> (const char *data, unsigned int size)</td></tr>
<tr class="memdesc:ga482d2e82f374a8758cd516d19f4c3424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the CRC-32 checksum of a byte array.  <a href="#ga482d2e82f374a8758cd516d19f4c3424">More...</a><br/></td></tr>
<tr class="separator:ga482d2e82f374a8758cd516d19f4c3424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f6a2804ceaf785495472fb9bf2dd5bc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga0f6a2804ceaf785495472fb9bf2dd5bc">chi2</a> (unsigned int degreesOfFreedom, double arg, double accuracy=1e-7)</td></tr>
<tr class="memdesc:ga0f6a2804ceaf785495472fb9bf2dd5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chi square distribution.  <a href="#ga0f6a2804ceaf785495472fb9bf2dd5bc">More...</a><br/></td></tr>
<tr class="separator:ga0f6a2804ceaf785495472fb9bf2dd5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa94c7af27b4aecda8a764beb89dbc2a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaa94c7af27b4aecda8a764beb89dbc2a6">chi2CDF</a> (unsigned int degreesOfFreedom, double arg, double accuracy=1e-7)</td></tr>
<tr class="memdesc:gaa94c7af27b4aecda8a764beb89dbc2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative chi square distribution.  <a href="#gaa94c7af27b4aecda8a764beb89dbc2a6">More...</a><br/></td></tr>
<tr class="separator:gaa94c7af27b4aecda8a764beb89dbc2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10235727f77f6dfa6af756ce20eec2f7"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ga10235727f77f6dfa6af756ce20eec2f7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga10235727f77f6dfa6af756ce20eec2f7">closeAtTolerance</a> (T1 l, T2 r, typename PromoteTraits&lt; T1, T2 &gt;::Promote epsilon)</td></tr>
<tr class="memdesc:ga10235727f77f6dfa6af756ce20eec2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance based floating-point equality.  <a href="#ga10235727f77f6dfa6af756ce20eec2f7">More...</a><br/></td></tr>
<tr class="separator:ga10235727f77f6dfa6af756ce20eec2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46be68464b972df67e1396fd3a398de7"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga46be68464b972df67e1396fd3a398de7">concatenateChecksum</a> (UInt32 checksum, const char *data, unsigned int size)</td></tr>
<tr class="separator:ga46be68464b972df67e1396fd3a398de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ce9a27a70c7341a29c4637cddf26f8c"><td class="memTemplParams" colspan="2">template&lt;class REAL &gt; </td></tr>
<tr class="memitem:ga7ce9a27a70c7341a29c4637cddf26f8c"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga7ce9a27a70c7341a29c4637cddf26f8c">cos_pi</a> (REAL x)</td></tr>
<tr class="memdesc:ga7ce9a27a70c7341a29c4637cddf26f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">cos(pi*x).  <a href="#ga7ce9a27a70c7341a29c4637cddf26f8c">More...</a><br/></td></tr>
<tr class="separator:ga7ce9a27a70c7341a29c4637cddf26f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d6193bd95ec54c5f25dd0470f58215"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga29d6193bd95ec54c5f25dd0470f58215">ellipticIntegralE</a> (double x, double k)</td></tr>
<tr class="memdesc:ga29d6193bd95ec54c5f25dd0470f58215"><td class="mdescLeft">&#160;</td><td class="mdescRight">The incomplete elliptic integral of the second kind.  <a href="#ga29d6193bd95ec54c5f25dd0470f58215">More...</a><br/></td></tr>
<tr class="separator:ga29d6193bd95ec54c5f25dd0470f58215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e909bd1d07e846d5d3ba78eaed7c520"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga7e909bd1d07e846d5d3ba78eaed7c520">ellipticIntegralF</a> (double x, double k)</td></tr>
<tr class="memdesc:ga7e909bd1d07e846d5d3ba78eaed7c520"><td class="mdescLeft">&#160;</td><td class="mdescRight">The incomplete elliptic integral of the first kind.  <a href="#ga7e909bd1d07e846d5d3ba78eaed7c520">More...</a><br/></td></tr>
<tr class="separator:ga7e909bd1d07e846d5d3ba78eaed7c520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf86b8d2300cd08b69024eb89f90115"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga3cf86b8d2300cd08b69024eb89f90115">even</a> (int t)</td></tr>
<tr class="memdesc:ga3cf86b8d2300cd08b69024eb89f90115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an integer is even.  <a href="#ga3cf86b8d2300cd08b69024eb89f90115">More...</a><br/></td></tr>
<tr class="separator:ga3cf86b8d2300cd08b69024eb89f90115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c914923c1c096cef574906d6169329"><td class="memItemLeft" align="right" valign="top">UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga73c914923c1c096cef574906d6169329">floorPower2</a> (UInt32 x)</td></tr>
<tr class="memdesc:ga73c914923c1c096cef574906d6169329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round down to the nearest power of 2.  <a href="#ga73c914923c1c096cef574906d6169329">More...</a><br/></td></tr>
<tr class="separator:ga73c914923c1c096cef574906d6169329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga441c9e4bf9f952c0fe94836634bcf976"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga441c9e4bf9f952c0fe94836634bcf976">gamma</a> (double x)</td></tr>
<tr class="memdesc:ga441c9e4bf9f952c0fe94836634bcf976"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gamma function.  <a href="#ga441c9e4bf9f952c0fe94836634bcf976">More...</a><br/></td></tr>
<tr class="separator:ga441c9e4bf9f952c0fe94836634bcf976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5825d3973169fc0c90404849a5906697"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga5825d3973169fc0c90404849a5906697"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga5825d3973169fc0c90404849a5906697">gcd</a> (IntType n, IntType m)</td></tr>
<tr class="separator:ga5825d3973169fc0c90404849a5906697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4503426a1fca981239e8f1f4926e030"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:gaf4503426a1fca981239e8f1f4926e030"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaf4503426a1fca981239e8f1f4926e030">greaterEqualAtTolerance</a> (T1 l, T2 r, typename PromoteTraits&lt; T1, T2 &gt;::Promote epsilon)</td></tr>
<tr class="memdesc:gaf4503426a1fca981239e8f1f4926e030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance based floating-point greater-or-equal.  <a href="#gaf4503426a1fca981239e8f1f4926e030">More...</a><br/></td></tr>
<tr class="separator:gaf4503426a1fca981239e8f1f4926e030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga643a6681534ba7611545eecca201666a"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class IndexIterator , class Compare &gt; </td></tr>
<tr class="memitem:ga643a6681534ba7611545eecca201666a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga643a6681534ba7611545eecca201666a">indexSort</a> (Iterator first, Iterator last, IndexIterator index_first, Compare c)</td></tr>
<tr class="memdesc:ga643a6681534ba7611545eecca201666a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index permutation that would sort the input array.  <a href="#ga643a6681534ba7611545eecca201666a">More...</a><br/></td></tr>
<tr class="separator:ga643a6681534ba7611545eecca201666a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf26349c51c03a24f22baab0138374c77"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gaf26349c51c03a24f22baab0138374c77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaf26349c51c03a24f22baab0138374c77">inspectSequence</a> (...)</td></tr>
<tr class="memdesc:gaf26349c51c03a24f22baab0138374c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an analyzing functor at every element of a sequence.  <a href="#gaf26349c51c03a24f22baab0138374c77">More...</a><br/></td></tr>
<tr class="separator:gaf26349c51c03a24f22baab0138374c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89c0801ae0f386bade8dbc77fa485301"><td class="memTemplParams" colspan="2">template&lt;class InIterator , class OutIterator &gt; </td></tr>
<tr class="memitem:ga89c0801ae0f386bade8dbc77fa485301"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga89c0801ae0f386bade8dbc77fa485301">inversePermutation</a> (InIterator first, InIterator last, OutIterator out)</td></tr>
<tr class="memdesc:ga89c0801ae0f386bade8dbc77fa485301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of a given permutation.  <a href="#ga89c0801ae0f386bade8dbc77fa485301">More...</a><br/></td></tr>
<tr class="separator:ga89c0801ae0f386bade8dbc77fa485301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9b14d7429c1745592bdce8772fc9834"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9b14d7429c1745592bdce8772fc9834"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gad9b14d7429c1745592bdce8772fc9834">isPower2</a> (UInt32 x)</td></tr>
<tr class="memdesc:gad9b14d7429c1745592bdce8772fc9834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether x is a power of 2 Bit twiddle from <a href="https://graphics.stanford.edu/~seander/bithacks.html#DetermineIfPowerOf2">https://graphics.stanford.edu/~seander/bithacks.html#DetermineIfPowerOf2</a>. <br/></td></tr>
<tr class="separator:gad9b14d7429c1745592bdce8772fc9834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa613671eda401daa90a686497c27da"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ga1aa613671eda401daa90a686497c27da"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga1aa613671eda401daa90a686497c27da">lcm</a> (IntType n, IntType m)</td></tr>
<tr class="separator:ga1aa613671eda401daa90a686497c27da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53853aa76befa82637051ecbadc9a10b"><td class="memTemplParams" colspan="2">template&lt;class REAL &gt; </td></tr>
<tr class="memitem:ga53853aa76befa82637051ecbadc9a10b"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga53853aa76befa82637051ecbadc9a10b">legendre</a> (unsigned int l, int m, REAL x)</td></tr>
<tr class="memdesc:ga53853aa76befa82637051ecbadc9a10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associated Legendre polynomial.  <a href="#ga53853aa76befa82637051ecbadc9a10b">More...</a><br/></td></tr>
<tr class="separator:ga53853aa76befa82637051ecbadc9a10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0197e622433399bc9792bb1a884c0b8d"><td class="memTemplParams" colspan="2">template&lt;class REAL &gt; </td></tr>
<tr class="memitem:ga0197e622433399bc9792bb1a884c0b8d"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga0197e622433399bc9792bb1a884c0b8d">legendre</a> (unsigned int l, REAL x)</td></tr>
<tr class="memdesc:ga0197e622433399bc9792bb1a884c0b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legendre polynomial.  <a href="#ga0197e622433399bc9792bb1a884c0b8d">More...</a><br/></td></tr>
<tr class="separator:ga0197e622433399bc9792bb1a884c0b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694e9e8eff6f817c3bcf595e1cf12c94"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ga694e9e8eff6f817c3bcf595e1cf12c94"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga694e9e8eff6f817c3bcf595e1cf12c94">lessEqualAtTolerance</a> (T1 l, T2 r, typename PromoteTraits&lt; T1, T2 &gt;::Promote epsilon)</td></tr>
<tr class="memdesc:ga694e9e8eff6f817c3bcf595e1cf12c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance based floating-point less-or-equal.  <a href="#ga694e9e8eff6f817c3bcf595e1cf12c94">More...</a><br/></td></tr>
<tr class="separator:ga694e9e8eff6f817c3bcf595e1cf12c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ed6110df5e4258d0a4541bcf85c762"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Value &gt; </td></tr>
<tr class="memitem:gad4ed6110df5e4258d0a4541bcf85c762"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gad4ed6110df5e4258d0a4541bcf85c762">linearSequence</a> (Iterator first, Iterator last, Value start, Value step)</td></tr>
<tr class="memdesc:gad4ed6110df5e4258d0a4541bcf85c762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an array with a sequence of numbers.  <a href="#gad4ed6110df5e4258d0a4541bcf85c762">More...</a><br/></td></tr>
<tr class="separator:gad4ed6110df5e4258d0a4541bcf85c762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0271fdd97b849704cded72b31cce3c83"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga0271fdd97b849704cded72b31cce3c83">log2i</a> (UInt32 x)</td></tr>
<tr class="memdesc:ga0271fdd97b849704cded72b31cce3c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the base-2 logarithm of an integer.  <a href="#ga0271fdd97b849704cded72b31cce3c83">More...</a><br/></td></tr>
<tr class="separator:ga0271fdd97b849704cded72b31cce3c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc5038616b325ecfd12b4ef51318aa26"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gafc5038616b325ecfd12b4ef51318aa26">loggamma</a> (double x)</td></tr>
<tr class="memdesc:gafc5038616b325ecfd12b4ef51318aa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of the gamma function.  <a href="#gafc5038616b325ecfd12b4ef51318aa26">More...</a><br/></td></tr>
<tr class="separator:gafc5038616b325ecfd12b4ef51318aa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb5121061c3bf2e68ab2cb1ad0b4b08d"><td class="memTemplParams" colspan="2">template&lt;class ArrayLike , class Compare &gt; </td></tr>
<tr class="memitem:gabb5121061c3bf2e68ab2cb1ad0b4b08d"><td class="memTemplItemLeft" align="right" valign="top">detail::IndexCompare<br class="typebreak"/>
&lt; ArrayLike, Compare &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gabb5121061c3bf2e68ab2cb1ad0b4b08d">makeIndexComparator</a> (ArrayLike a, Compare c)</td></tr>
<tr class="memdesc:gabb5121061c3bf2e68ab2cb1ad0b4b08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a compare functor for indirect sort.  <a href="#gabb5121061c3bf2e68ab2cb1ad0b4b08d">More...</a><br/></td></tr>
<tr class="separator:gabb5121061c3bf2e68ab2cb1ad0b4b08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga074ace0a87d00243c85a52e5071a1ad4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga074ace0a87d00243c85a52e5071a1ad4">noncentralChi2</a> (unsigned int degreesOfFreedom, double noncentrality, double arg, double accuracy=1e-7)</td></tr>
<tr class="memdesc:ga074ace0a87d00243c85a52e5071a1ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-central chi square distribution.  <a href="#ga074ace0a87d00243c85a52e5071a1ad4">More...</a><br/></td></tr>
<tr class="separator:ga074ace0a87d00243c85a52e5071a1ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e01fc59c3d8455e8ccbbd8824230226"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226">noncentralChi2CDF</a> (unsigned int degreesOfFreedom, double noncentrality, double arg, double accuracy=1e-7)</td></tr>
<tr class="memdesc:ga4e01fc59c3d8455e8ccbbd8824230226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative non-central chi square distribution.  <a href="#ga4e01fc59c3d8455e8ccbbd8824230226">More...</a><br/></td></tr>
<tr class="separator:ga4e01fc59c3d8455e8ccbbd8824230226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddeff01bf2aa44ad74399a1888a6bbfb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaddeff01bf2aa44ad74399a1888a6bbfb">noncentralChi2CDFApprox</a> (unsigned int degreesOfFreedom, double noncentrality, double arg)</td></tr>
<tr class="memdesc:gaddeff01bf2aa44ad74399a1888a6bbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative non-central chi square distribution (approximate).  <a href="#gaddeff01bf2aa44ad74399a1888a6bbfb">More...</a><br/></td></tr>
<tr class="separator:gaddeff01bf2aa44ad74399a1888a6bbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794eb2a920016363c5e9653b6b2b6eb2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga794eb2a920016363c5e9653b6b2b6eb2"><td class="memTemplItemLeft" align="right" valign="top">NormTraits&lt; T &gt;::NormType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga794eb2a920016363c5e9653b6b2b6eb2">norm</a> (T const &amp;t)</td></tr>
<tr class="memdesc:ga794eb2a920016363c5e9653b6b2b6eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The norm of a numerical object.  <a href="#ga794eb2a920016363c5e9653b6b2b6eb2">More...</a><br/></td></tr>
<tr class="separator:ga794eb2a920016363c5e9653b6b2b6eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48f661149941ebaa90ddd99ee5eee145"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga48f661149941ebaa90ddd99ee5eee145">odd</a> (int t)</td></tr>
<tr class="memdesc:ga48f661149941ebaa90ddd99ee5eee145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an integer is odd.  <a href="#ga48f661149941ebaa90ddd99ee5eee145">More...</a><br/></td></tr>
<tr class="separator:ga48f661149941ebaa90ddd99ee5eee145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd375194b3220beebe0a22e67d7a4e8"><td class="memItemLeft" align="right" valign="top">result_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gaebd375194b3220beebe0a22e67d7a4e8">operator()</a> (argument_type x) const </td></tr>
<tr class="separator:gaebd375194b3220beebe0a22e67d7a4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga203e71c46fd7f38f8139eed3072f6c78"><td class="memTemplParams" colspan="2">template&lt;unsigned n, class V &gt; </td></tr>
<tr class="memitem:ga203e71c46fd7f38f8139eed3072f6c78"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga203e71c46fd7f38f8139eed3072f6c78">power</a> (const V &amp;x)</td></tr>
<tr class="memdesc:ga203e71c46fd7f38f8139eed3072f6c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation to a positive integer power by squaring.  <a href="#ga203e71c46fd7f38f8139eed3072f6c78">More...</a><br/></td></tr>
<tr class="separator:ga203e71c46fd7f38f8139eed3072f6c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fd73560e02ff2f241ebfdf38daf1740"><td class="memItemLeft" align="right" valign="top">REAL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga3fd73560e02ff2f241ebfdf38daf1740">round</a> (REAL v)</td></tr>
<tr class="memdesc:ga3fd73560e02ff2f241ebfdf38daf1740"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rounding function.  <a href="#ga3fd73560e02ff2f241ebfdf38daf1740">More...</a><br/></td></tr>
<tr class="separator:ga3fd73560e02ff2f241ebfdf38daf1740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc3062b27c3a61ddd8b5bc5ac6fc54b"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga2cc3062b27c3a61ddd8b5bc5ac6fc54b">roundi</a> (double t)</td></tr>
<tr class="memdesc:ga2cc3062b27c3a61ddd8b5bc5ac6fc54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round and cast to integer.  <a href="#ga2cc3062b27c3a61ddd8b5bc5ac6fc54b">More...</a><br/></td></tr>
<tr class="separator:ga2cc3062b27c3a61ddd8b5bc5ac6fc54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99756ca23b738bdc82afba3b0e49df74"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga99756ca23b738bdc82afba3b0e49df74"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga99756ca23b738bdc82afba3b0e49df74">sign</a> (T t)</td></tr>
<tr class="memdesc:ga99756ca23b738bdc82afba3b0e49df74"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sign function.  <a href="#ga99756ca23b738bdc82afba3b0e49df74">More...</a><br/></td></tr>
<tr class="separator:ga99756ca23b738bdc82afba3b0e49df74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97607c505b78dde9e45ce4f11ad20ea"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:gab97607c505b78dde9e45ce4f11ad20ea"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gab97607c505b78dde9e45ce4f11ad20ea">sign</a> (T1 t1, T2 t2)</td></tr>
<tr class="memdesc:gab97607c505b78dde9e45ce4f11ad20ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary sign function.  <a href="#gab97607c505b78dde9e45ce4f11ad20ea">More...</a><br/></td></tr>
<tr class="separator:gab97607c505b78dde9e45ce4f11ad20ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d6f0e128653deb42a47a8f379b4b9a0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2d6f0e128653deb42a47a8f379b4b9a0"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga2d6f0e128653deb42a47a8f379b4b9a0">signi</a> (T t)</td></tr>
<tr class="memdesc:ga2d6f0e128653deb42a47a8f379b4b9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer sign function.  <a href="#ga2d6f0e128653deb42a47a8f379b4b9a0">More...</a><br/></td></tr>
<tr class="separator:ga2d6f0e128653deb42a47a8f379b4b9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe78db7b7769819568aeafbfbc2ffd0"><td class="memTemplParams" colspan="2">template&lt;class REAL &gt; </td></tr>
<tr class="memitem:ga8fe78db7b7769819568aeafbfbc2ffd0"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga8fe78db7b7769819568aeafbfbc2ffd0">sin_pi</a> (REAL x)</td></tr>
<tr class="memdesc:ga8fe78db7b7769819568aeafbfbc2ffd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">sin(pi*x).  <a href="#ga8fe78db7b7769819568aeafbfbc2ffd0">More...</a><br/></td></tr>
<tr class="separator:ga8fe78db7b7769819568aeafbfbc2ffd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe62e7b0dc6f379dd436c9c8338c93e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5fe62e7b0dc6f379dd436c9c8338c93e"><td class="memTemplItemLeft" align="right" valign="top">NumericTraits&lt; T &gt;::Promote&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e">sq</a> (T t)</td></tr>
<tr class="memdesc:ga5fe62e7b0dc6f379dd436c9c8338c93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square function.  <a href="#ga5fe62e7b0dc6f379dd436c9c8338c93e">More...</a><br/></td></tr>
<tr class="separator:ga5fe62e7b0dc6f379dd436c9c8338c93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga540e54c778be63996a0f61f7117c2903"><td class="memItemLeft" align="right" valign="top">Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga540e54c778be63996a0f61f7117c2903">sqrti</a> (Int32 v)</td></tr>
<tr class="memdesc:ga540e54c778be63996a0f61f7117c2903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed integer square root.  <a href="#ga540e54c778be63996a0f61f7117c2903">More...</a><br/></td></tr>
<tr class="separator:ga540e54c778be63996a0f61f7117c2903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38870065d4c6e12602b9154c7e69df1f"><td class="memItemLeft" align="right" valign="top">NormTraits&lt; T &gt;::SquaredNormType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga38870065d4c6e12602b9154c7e69df1f">squaredNorm</a> (T const &amp;t)</td></tr>
<tr class="memdesc:ga38870065d4c6e12602b9154c7e69df1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The squared norm of a numerical object.  <a href="#ga38870065d4c6e12602b9154c7e69df1f">More...</a><br/></td></tr>
<tr class="separator:ga38870065d4c6e12602b9154c7e69df1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9210561d31f03b4fa1656bafc7182c0b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9210561d31f03b4fa1656bafc7182c0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga9210561d31f03b4fa1656bafc7182c0b">symmetric2x2Eigenvalues</a> (T a00, T a01, T a11, T *r0, T *r1)</td></tr>
<tr class="memdesc:ga9210561d31f03b4fa1656bafc7182c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues of a 2x2 real symmetric matrix.  <a href="#ga9210561d31f03b4fa1656bafc7182c0b">More...</a><br/></td></tr>
<tr class="separator:ga9210561d31f03b4fa1656bafc7182c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c49eca66b2ba5c308d04fa324dcc230"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2c49eca66b2ba5c308d04fa324dcc230"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga2c49eca66b2ba5c308d04fa324dcc230">symmetric3x3Eigenvalues</a> (T a00, T a01, T a02, T a11, T a12, T a22, T *r0, T *r1, T *r2)</td></tr>
<tr class="memdesc:ga2c49eca66b2ba5c308d04fa324dcc230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigenvalues of a 3x3 real symmetric matrix.  <a href="#ga2c49eca66b2ba5c308d04fa324dcc230">More...</a><br/></td></tr>
<tr class="separator:ga2c49eca66b2ba5c308d04fa324dcc230"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<p>Useful mathematical functions and functors. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad84c74edbd392ac2035df2a6d583fc05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator vigra::argMin </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum element in a sequence. </p>
<p>The function returns the iterator referring to the minimum element. This is identical to the function <code>std::min_element()</code>.</p>
<p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">Iterator is a standard forward iterator.</div>
<div class="line"></div>
<div class="line">bool f = *first &lt; NumericTraits&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::max();</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gaf658d43400902a049a289c4e5ded84d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator vigra::argMax </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the maximum element in a sequence. </p>
<p>The function returns the iterator referring to the maximum element. This is identical to the function <code>std::max_element()</code>.</p>
<p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">Iterator is a standard forward iterator.</div>
<div class="line"></div>
<div class="line">bool f = NumericTraits&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::min() &lt; *first;</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga45d791e8c9cac48509aa4e1557ecf676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator vigra::argMinIf </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunctor&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the minimum element in a sequence conforming to a condition. </p>
<p>The function returns the iterator referring to the minimum element, where only elements conforming to the condition (i.e. where <code>condition(*iterator)</code> evaluates to <code>true</code>) are considered. If no element conforms to the condition, or the sequence is empty, the end iterator <em>last</em> is returned.</p>
<p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">Iterator is a standard forward iterator.</div>
<div class="line"></div>
<div class="line">bool c = condition(*first);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> f = *first &lt; NumericTraits&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::max();</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gafe67abfb62abdfc09a8e1e47a87485ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator vigra::argMaxIf </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunctor&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the maximum element in a sequence conforming to a condition. </p>
<p>The function returns the iterator referring to the maximum element, where only elements conforming to the condition (i.e. where <code>condition(*iterator)</code> evaluates to <code>true</code>) are considered. If no element conforms to the condition, or the sequence is empty, the end iterator <em>last</em> is returned.</p>
<p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">Iterator is a standard forward iterator.</div>
<div class="line"></div>
<div class="line">bool c = condition(*first);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> f = NumericTraits&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::min() &lt; *first;</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gad4ed6110df5e4258d0a4541bcf85c762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::linearSequence </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill an array with a sequence of numbers. </p>
<p>The sequence starts at <em>start</em> and is incremented with <em>step</em>. Default start and stepsize are 0 and 1 respectively. This is a generalization of function <code>std::iota()</code> in C++11.</p>
<p><b> Declaration:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> Value&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__MathFunctions.html#gad4ed6110df5e4258d0a4541bcf85c762">linearSequence</a>(Iterator first, Iterator last, </div>
<div class="line">                  Value <span class="keyword">const</span> &amp; start = 0, Value <span class="keyword">const</span> &amp; step = 1);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">Iterator is a standard forward iterator.</div>
<div class="line"></div>
<div class="line"> first = start;</div>
<div class="line">start += step;</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gaf26349c51c03a24f22baab0138374c77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::inspectSequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call an analyzing functor at every element of a sequence. </p>
<p>This function can be used to collect statistics of the sequence <code>[first, last)</code> defined by these two input interators. The results must be stored in the functor, which serves as a return value.</p>
<p><b> Declarations:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> Functor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MathFunctions.html#gaf26349c51c03a24f22baab0138374c77">inspectSequence</a>(InputIterator first, InputIterator last, Functor &amp; f);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">std::vector array(100);</div>
<div class="line"></div>
<div class="line"><span class="comment">// init functor</span></div>
<div class="line"><a class="code" href="classvigra_1_1FindMinMax.html">vigra::FindMinMax&lt;int&gt;</a> minmax;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__MathFunctions.html#gaf26349c51c03a24f22baab0138374c77">vigra::inspectSequence</a>(array.begin(), array.end(), minmax);</div>
<div class="line"></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Min: &quot;</span> &lt;&lt; minmax.<a class="code" href="classvigra_1_1FindMinMax.html#a0ae3408e83fa258f08ece61e194251a9">min</a> &lt;&lt; <span class="stringliteral">&quot; Max: &quot;</span> &lt;&lt; minmax.<a class="code" href="classvigra_1_1FindMinMax.html#a7a6d5ee26475974260562366c1a71b01">max</a>;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gabb5121061c3bf2e68ab2cb1ad0b4b08d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::IndexCompare&lt;ArrayLike, Compare&gt; vigra::makeIndexComparator </td>
          <td>(</td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a compare functor for indirect sort. </p>
<p>Indirect sorting refers to the situation where you have an array holding data and another array holding indices referencing the first array, and you want to sort the index array according to some property of the data array without changing the data array itself. The factory function <code><a class="el" href="group__MathFunctions.html#gabb5121061c3bf2e68ab2cb1ad0b4b08d" title="Create a compare functor for indirect sort. ">makeIndexComparator()</a></code> creates a sorting predicate for this task, given a sorting predicate for the data array.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MathFunctions.html#ga643a6681534ba7611545eecca201666a" title="Return the index permutation that would sort the input array. ">vigra::indexSort()</a>, <a class="el" href="group__MathFunctions.html#ga8686fee88c6f46f3e19a76f00826dc10" title="Sort an array according to the given index permutation. ">vigra::applyPermutation()</a></dd></dl>
<p><b>Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std:vector&lt;double&gt; data(...);  <span class="comment">// data is immutable</span></div>
<div class="line"></div>
<div class="line">std::vector&lt;int&gt; index(data.size());</div>
<div class="line">std::iota(index.begin(), index.end());</div>
<div class="line"></div>
<div class="line"><span class="comment">// sort the indices such that data[index[k]] is an ascending sequence in k</span></div>
<div class="line">std::sort(index.begin(), index.end(), <a class="code" href="group__MathFunctions.html#gabb5121061c3bf2e68ab2cb1ad0b4b08d">makeIndexComparator</a>(data));</div>
</div><!-- fragment --><p><b>Declarations:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// compare using std::less</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ArrayLike&gt;</div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="group__MathFunctions.html#gabb5121061c3bf2e68ab2cb1ad0b4b08d">makeIndexComparator</a>(ArrayLike a);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compare using functor Compare</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> ArrayLike, <span class="keyword">class</span> Compare&gt;</div>
<div class="line">    <span class="keyword">auto</span> <a class="code" href="group__MathFunctions.html#gabb5121061c3bf2e68ab2cb1ad0b4b08d">makeIndexComparator</a>(ArrayLike a, Compare c);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga643a6681534ba7611545eecca201666a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::indexSort </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexIterator&#160;</td>
          <td class="paramname"><em>index_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index permutation that would sort the input array. </p>
<p>To actually sort an array according to the ordering thus determined, use <a class="el" href="group__MathFunctions.html#ga8686fee88c6f46f3e19a76f00826dc10">applyPermutation()</a>.</p>
<p><b>Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std:vector&lt;double&gt; data(...);  <span class="comment">// data is immutable</span></div>
<div class="line"></div>
<div class="line">std::vector&lt;int&gt; index(data.size());</div>
<div class="line"></div>
<div class="line"><span class="comment">// arrange indices such that data[index[k]] is an ascending sequence in k</span></div>
<div class="line"><a class="code" href="group__MathFunctions.html#ga643a6681534ba7611545eecca201666a">indexSort</a>(data.begin(), data.end(), index.begin());</div>
</div><!-- fragment --><p><b> Declarations:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// compare using std::less</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> IndexIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__MathFunctions.html#ga643a6681534ba7611545eecca201666a">indexSort</a>(Iterator first, Iterator last, IndexIterator index_first);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compare using functor Compare</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> IndexIterator, <span class="keyword">class</span> Compare&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__MathFunctions.html#ga643a6681534ba7611545eecca201666a">indexSort</a>(Iterator first, Iterator last, IndexIterator index_first, Compare compare);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">Iterator and IndexIterators are random access iterators.</div>
<div class="line"></div>
<div class="line">bool res = compare(first[*index_first], first[*index_first]);</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga8686fee88c6f46f3e19a76f00826dc10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::applyPermutation </td>
          <td>(</td>
          <td class="paramtype">IndexIterator&#160;</td>
          <td class="paramname"><em>index_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexIterator&#160;</td>
          <td class="paramname"><em>index_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIterator&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort an array according to the given index permutation. </p>
<p>The iterators <em>in</em> and <em>out</em> may not refer to the same array, as this would overwrite the input prematurely.</p>
<p><b> Declaration:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> IndexIterator, <span class="keyword">class</span> InIterator, <span class="keyword">class</span> OutIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__MathFunctions.html#ga8686fee88c6f46f3e19a76f00826dc10">applyPermutation</a>(IndexIterator index_first, IndexIterator index_last, </div>
<div class="line">                          InIterator in, OutIterator out);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">OutIterator and IndexIterators are forward iterators.</div>
<div class="line">InIterator is a random access iterator.</div>
<div class="line"></div>
<div class="line"> out = in[*index_first];</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga89c0801ae0f386bade8dbc77fa485301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::inversePermutation </td>
          <td>(</td>
          <td class="paramtype">InIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inverse of a given permutation. </p>
<p>This is just another name for <a class="el" href="group__MathFunctions.html#ga643a6681534ba7611545eecca201666a">indexSort()</a>, referring to another semantics.</p>
<p><b> Declaration:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InIterator, <span class="keyword">class</span> OutIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__MathFunctions.html#ga89c0801ae0f386bade8dbc77fa485301">inversePermutation</a>(InIterator first, InIterator last, </div>
<div class="line">                            OutIterator out);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Required Interface:</b></p>
<div class="fragment"><div class="line">InIterator and OutIterator are random access iterators.</div>
<div class="line"></div>
<div class="line"> out = in[*index_first];</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="algorithm_8hxx_source.html">vigra/algorithm.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga482d2e82f374a8758cd516d19f4c3424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 vigra::checksum </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the CRC-32 checksum of a byte array. </p>
<p>Implementation note: This function is slower on big-endian machines because the "4 bytes at a time" optimization is only implemented for little-endian. </p>

</div>
</div>
<a class="anchor" id="ga46be68464b972df67e1396fd3a398de7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 vigra::concatenateChecksum </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate a byte array to an existing CRC-32 checksum. </p>

</div>
</div>
<a class="anchor" id="ga9cf8d64d518f2d493bee81d886906cdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::besselJ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bessel function of the first kind. </p>
<p>Computes the value of BesselJ of integer order <code>n</code> and argument <code>x</code>. Negative <code>x</code> are unsupported and will result in a <code>std::domain_error</code>.</p>
<p>This function wraps a number of existing implementations and falls back to a rather slow algorithm if none of them is available. In particular, it uses boost::math when <code>HasBoostMath</code> is #defined, or native implementations on gcc and MSVC otherwise.</p>
<p><b>#include</b> &lt;<a class="el" href="bessel_8hxx_source.html">vigra/bessel.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga84d85515af4527b6922f14a853fe40d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::besselY </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bessel function of the second kind. </p>
<p>Computes the value of BesselY of integer order <code>n</code> and argument <code>x</code>. Negative <code>x</code> are unsupported and will result in a <code>std::domain_error</code>.</p>
<p>This function wraps a number of existing implementations and falls back to a rather slow algorithm if none of them is available. In particular, it uses boost::math when <code>HasBoostMath</code> is #defined, or native implementations on gcc and MSVC otherwise.</p>
<p><b>#include</b> &lt;<a class="el" href="bessel_8hxx_source.html">vigra/bessel.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga3fd73560e02ff2f241ebfdf38daf1740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL vigra::round </td>
          <td>(</td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The rounding function. </p>
<p>Defined for all floating point types. Rounds towards the nearest integer such that <code>abs(round(t)) == round(abs(t))</code> for all <code>t</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga2cc3062b27c3a61ddd8b5bc5ac6fc54b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long vigra::roundi </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round and cast to integer. </p>
<p>Rounds to the nearest integer like <a class="el" href="group__FixedPointOperations.html#gaddcb15f9b13ee9ba98ee1e5b8e228544" title="rounding to the nearest integer. ">round()</a>, but casts the result to <code>long long</code> (this will be faster and is usually needed anyway).</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga54aeb0113ef25c8a4f2e72a1acc794c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 vigra::ceilPower2 </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round up to the nearest power of 2. </p>
<p>Efficient algorithm for finding the smallest power of 2 which is not smaller than <em>x</em> (function clp2() from Henry Warren: "Hacker's Delight", Addison-Wesley, 2003, see <a href="http://www.hackersdelight.org/">http://www.hackersdelight.org/</a>). If <em>x</em> &gt; 2^31, the function will return 0 because integer arithmetic is defined modulo 2^32.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga73c914923c1c096cef574906d6169329"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 vigra::floorPower2 </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round down to the nearest power of 2. </p>
<p>Efficient algorithm for finding the largest power of 2 which is not greater than <em>x</em> (function flp2() from Henry Warren: "Hacker's Delight", Addison-Wesley, 2003, see <a href="http://www.hackersdelight.org/">http://www.hackersdelight.org/</a>).</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga0271fdd97b849704cded72b31cce3c83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 vigra::log2i </td>
          <td>(</td>
          <td class="paramtype">UInt32&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the base-2 logarithm of an integer. </p>
<p>Returns the position of the left-most 1-bit in the given number <em>x</em>, or -1 if <em>x</em> == 0. That is,</p>
<div class="fragment"><div class="line">assert(k &gt;= 0 &amp;&amp; k &lt; 32 &amp;&amp; <a class="code" href="group__MathFunctions.html#ga0271fdd97b849704cded72b31cce3c83">log2i</a>(1 &lt;&lt; k) == k);</div>
</div><!-- fragment --><p>The function uses Robert Harley's algorithm to determine the number of leading zeros in <em>x</em> (algorithm nlz10() at <a href="http://www.hackersdelight.org/">http://www.hackersdelight.org/</a>). But note that the functions <a class="el" href="group__MathFunctions.html#ga73c914923c1c096cef574906d6169329">floorPower2()</a> or <a class="el" href="group__MathFunctions.html#ga54aeb0113ef25c8a4f2e72a1acc794c5">ceilPower2()</a> are more efficient and should be preferred when possible.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga5fe62e7b0dc6f379dd436c9c8338c93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NumericTraits&lt;T&gt;::Promote vigra::sq </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The square function. </p>
<p><code>sq(x) = x*x</code> is needed so often that it makes sense to define it as a function.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga203e71c46fd7f38f8139eed3072f6c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">V vigra::power </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exponentiation to a positive integer power by squaring. </p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga540e54c778be63996a0f61f7117c2903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 sqrti </td>
          <td>(</td>
          <td class="paramtype">Int32&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signed integer square root. </p>
<p>Unsigned integer square root.</p>
<p>Useful for fast fixed-point computations.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga99756ca23b738bdc82afba3b0e49df74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T vigra::sign </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sign function. </p>
<p>Returns 1, 0, or -1 depending on the sign of <em>t</em>, but with the same type as <em>t</em>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga2d6f0e128653deb42a47a8f379b4b9a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vigra::signi </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The integer sign function. </p>
<p>Returns 1, 0, or -1 depending on the sign of <em>t</em>, converted to int.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gab97607c505b78dde9e45ce4f11ad20ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T1 vigra::sign </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The binary sign function. </p>
<p>Transfers the sign of <em>t2</em> to <em>t1</em>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga3cf86b8d2300cd08b69024eb89f90115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::even </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an integer is even. </p>
<p>Defined for all integral types. </p>

</div>
</div>
<a class="anchor" id="ga48f661149941ebaa90ddd99ee5eee145"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::odd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if an integer is odd. </p>
<p>Defined for all integral types. </p>

</div>
</div>
<a class="anchor" id="ga38870065d4c6e12602b9154c7e69df1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NormTraits&lt;T&gt;::SquaredNormType vigra::squaredNorm </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The squared norm of a numerical object. </p>
<ul>
<li>
For scalar types: equals <code>vigra::sq(t)</code>. </li>
<li>
For vectorial types (including <a class="el" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">TinyVector</a>): equals <code>vigra::dot(t, t)</code>. </li>
<li>
For complex number types: equals <code><a class="el" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function. ">vigra::sq</a>(<a class="el" href="group__FFTWComplexOperators.html#gafa8d2d7496e4bdd96c42026a0ecbde1c" title="real part ">t.real()</a>) + <a class="el" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e" title="The square function. ">vigra::sq</a>(<a class="el" href="group__FFTWComplexOperators.html#ga8a3bba029e1ba026bd968786cfcf4546" title="imaginary part ">t.imag()</a>)</code>. </li>
<li>
For array and matrix types: results in the squared Frobenius norm (sum of squares of the matrix elements). </li>
</ul>

</div>
</div>
<a class="anchor" id="ga794eb2a920016363c5e9653b6b2b6eb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NormTraits&lt;T&gt;::NormType vigra::norm </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The norm of a numerical object. </p>
<p>For scalar types: implemented as <code>abs(t)</code><br/>
 otherwise: implemented as <code>sqrt(squaredNorm(t))</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga9210561d31f03b4fa1656bafc7182c0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::symmetric2x2Eigenvalues </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>r1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues of a 2x2 real symmetric matrix. </p>
<p>This uses the analytical eigenvalue formula </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \lambda_{1,2} = \frac{1}{2}\left(a_{00} + a_{11} \pm \sqrt{(a_{00} - a_{11})^2 + 4 a_{01}^2}\right) \]" src="form_58.png"/>
</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga2c49eca66b2ba5c308d04fa324dcc230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::symmetric3x3Eigenvalues </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a02</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigenvalues of a 3x3 real symmetric matrix. </p>
<p>This uses a numerically stable version of the analytical eigenvalue formula according to </p>
<p>David Eberly: <a href="http://www.geometrictools.com/Documentation/EigenSymmetric3x3.pdf"><em>"Eigensystems for 3 x 3 Symmetric Matrices (Revisited)"</em></a>, Geometric Tools Documentation, 2006</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga7e909bd1d07e846d5d3ba78eaed7c520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::ellipticIntegralF </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The incomplete elliptic integral of the first kind. </p>
<p>This function computes</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{F}(x, k) = \int_0^x \frac{1}{\sqrt{1 - k^2 \sin(t)^2}} dt \]" src="form_59.png"/>
</p>
<p>according to the algorithm given in Press et al. "Numerical Recipes".</p>
<p>Note: In some libraries (e.g. Mathematica), the second parameter of the elliptic integral functions must be k^2 rather than k. Check the documentation when results disagree!</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga29d6193bd95ec54c5f25dd0470f58215"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::ellipticIntegralE </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The incomplete elliptic integral of the second kind. </p>
<p>This function computes</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{E}(x, k) = \int_0^x \sqrt{1 - k^2 \sin(t)^2} dt \]" src="form_60.png"/>
</p>
<p>according to the algorithm given in Press et al. "Numerical Recipes". The complete elliptic integral of the second kind is simply <code>ellipticIntegralE(M_PI/2, k)</code>.</p>
<p>Note: In some libraries (e.g. Mathematica), the second parameter of the elliptic integral functions must be k^2 rather than k. Check the documentation when results disagree!</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga0f6a2804ceaf785495472fb9bf2dd5bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::chi2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chi square distribution. </p>
<p>Computes the density of a chi square distribution with <em>degreesOfFreedom</em> and tolerance <em>accuracy</em> at the given argument <em>arg</em> by calling <code>noncentralChi2(degreesOfFreedom, 0.0, arg, accuracy)</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gaa94c7af27b4aecda8a764beb89dbc2a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::chi2CDF </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cumulative chi square distribution. </p>
<p>Computes the cumulative density of a chi square distribution with <em>degreesOfFreedom</em> and tolerance <em>accuracy</em> at the given argument <em>arg</em>, i.e. the probability that a random number drawn from the distribution is below <em>arg</em> by calling <code>noncentralChi2CDF(degreesOfFreedom, 0.0, arg, accuracy)</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga074ace0a87d00243c85a52e5071a1ad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::noncentralChi2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>noncentrality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-central chi square distribution. </p>
<p>Computes the density of a non-central chi square distribution with <em>degreesOfFreedom</em>, noncentrality parameter <em>noncentrality</em> and tolerance <em>accuracy</em> at the given argument <em>arg</em>. It uses Algorithm AS 231 from Appl. Statist. (1987) Vol.36, No.3 (code ported from <a href="http://lib.stat.cmu.edu/apstat/231">http://lib.stat.cmu.edu/apstat/231</a>). The algorithm has linear complexity in the number of degrees of freedom.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga4e01fc59c3d8455e8ccbbd8824230226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::noncentralChi2CDF </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>noncentrality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cumulative non-central chi square distribution. </p>
<p>Computes the cumulative density of a chi square distribution with <em>degreesOfFreedom</em>, noncentrality parameter <em>noncentrality</em> and tolerance <em>accuracy</em> at the given argument <em>arg</em>, i.e. the probability that a random number drawn from the distribution is below <em>arg</em> It uses Algorithm AS 231 from Appl. Statist. (1987) Vol.36, No.3 (code ported from <a href="http://lib.stat.cmu.edu/apstat/231">http://lib.stat.cmu.edu/apstat/231</a>). The algorithm has linear complexity in the number of degrees of freedom (see <a class="el" href="group__MathFunctions.html#gaddeff01bf2aa44ad74399a1888a6bbfb" title="Cumulative non-central chi square distribution (approximate). ">noncentralChi2CDFApprox()</a> for a constant-time algorithm).</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gaddeff01bf2aa44ad74399a1888a6bbfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::noncentralChi2CDFApprox </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>noncentrality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cumulative non-central chi square distribution (approximate). </p>
<p>Computes approximate values of the cumulative density of a chi square distribution with <em>degreesOfFreedom</em>, and noncentrality parameter <em>noncentrality</em> at the given argument <em>arg</em>, i.e. the probability that a random number drawn from the distribution is below <em>arg</em> It uses the approximate transform into a normal distribution due to Wilson and Hilferty (see Abramovitz, Stegun: "Handbook of Mathematical Functions", formula 26.3.32). The algorithm's running time is independent of the inputs, i.e. is should be used when <a class="el" href="group__MathFunctions.html#ga4e01fc59c3d8455e8ccbbd8824230226" title="Cumulative non-central chi square distribution. ">noncentralChi2CDF()</a> is too slow, and approximate values are sufficient. The accuracy is only about 0.1 for few degrees of freedom, but reaches about 0.001 above dof = 5.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga53853aa76befa82637051ecbadc9a10b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL vigra::legendre </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associated Legendre polynomial. </p>
<p>Computes the value of the associated Legendre polynomial of order <code>l, m</code> for argument <code>x</code>. <code>x</code> must be in the range <code>[-1.0, 1.0]</code>, otherwise an exception is thrown. The standard Legendre polynomials are the special case <code>m == 0</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga0197e622433399bc9792bb1a884c0b8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL vigra::legendre </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legendre polynomial. </p>
<p>Computes the value of the Legendre polynomial of order <code>l</code> for argument <code>x</code>. <code>x</code> must be in the range <code>[-1.0, 1.0]</code>, otherwise an exception is thrown.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga8fe78db7b7769819568aeafbfbc2ffd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL vigra::sin_pi </td>
          <td>(</td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sin(pi*x). </p>
<p>Essentially calls <code>std::sin(M_PI*x)</code> but uses a more accurate implementation to make sure that <code>sin_pi(1.0) == 0.0</code> (which does not hold for <code>std::sin(M_PI)</code> due to round-off error), and <code>sin_pi(0.5) == 1.0</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga7ce9a27a70c7341a29c4637cddf26f8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL vigra::cos_pi </td>
          <td>(</td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cos(pi*x). </p>
<p>Essentially calls <code>std::cos(M_PI*x)</code> but uses a more accurate implementation to make sure that <code>cos_pi(1.0) == -1.0</code> and <code>cos_pi(0.5) == 0.0</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga441c9e4bf9f952c0fe94836634bcf976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::gamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The gamma function. </p>
<p>This function implements the algorithm from<br/>
 Zhang and Jin: "Computation of Special Functions", John Wiley and Sons, 1996.</p>
<p>The argument must be &lt;= 171.0 and cannot be zero or a negative integer. An exception is thrown when these conditions are violated.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="total_variation_8cxx-example.html#a11">total_variation.cxx</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gafc5038616b325ecfd12b4ef51318aa26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::loggamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The natural logarithm of the gamma function. </p>
<p>This function is based on a free implementation by Sun Microsystems, Inc., see <a href="http://www.sourceware.org/cgi-bin/cvsweb.cgi/~checkout~/src/newlib/libm/mathfp/er_lgamma.c?rev=1.6&amp;content-type=text/plain&amp;cvsroot=src">sourceware.org</a> archive. It can be removed once all compilers support the new C99 math functions.</p>
<p>The argument must be positive and &lt; 1e30. An exception is thrown when these conditions are violated.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga10235727f77f6dfa6af756ce20eec2f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::closeAtTolerance </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PromoteTraits&lt; T1, T2 &gt;::Promote&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tolerance based floating-point equality. </p>
<p>Check whether two floating point numbers are equal within the given tolerance. This is useful because floating point numbers that should be equal in theory are rarely exactly equal in practice. If the tolerance <em>epsilon</em> is not given, twice the machine epsilon is used.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga694e9e8eff6f817c3bcf595e1cf12c94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::lessEqualAtTolerance </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PromoteTraits&lt; T1, T2 &gt;::Promote&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tolerance based floating-point less-or-equal. </p>
<p>Check whether two floating point numbers are less or equal within the given tolerance. That is, <em>l</em> can actually be greater than <em>r</em> within the given <em>epsilon</em>. This is useful because floating point numbers that should be equal in theory are rarely exactly equal in practice. If the tolerance <em>epsilon</em> is not given, twice the machine epsilon is used.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gaf4503426a1fca981239e8f1f4926e030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::greaterEqualAtTolerance </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PromoteTraits&lt; T1, T2 &gt;::Promote&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tolerance based floating-point greater-or-equal. </p>
<p>Check whether two floating point numbers are greater or equal within the given tolerance. That is, <em>l</em> can actually be less than <em>r</em> within the given <em>epsilon</em>. This is useful because floating point numbers that should be equal in theory are rarely exactly equal in practice. If the tolerance <em>epsilon</em> is not given, twice the machine epsilon is used.</p>
<p><b>#include</b> &lt;<a class="el" href="mathutil_8hxx_source.html">vigra/mathutil.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga5825d3973169fc0c90404849a5906697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntType vigra::gcd </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the greatest common divisor.</p>
<p>This function works for arbitrary integer types, including user-defined (e.g. infinite precision) ones.</p>
<p><b>#include</b> &lt;<a class="el" href="rational_8hxx_source.html">vigra/rational.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="ga1aa613671eda401daa90a686497c27da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntType vigra::lcm </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the lowest common multiple.</p>
<p>This function works for arbitrary integer types, including user-defined (e.g. infinite precision) ones.</p>
<p><b>#include</b> &lt;<a class="el" href="rational_8hxx_source.html">vigra/rational.hxx</a>&gt;<br/>
 Namespace: vigra </p>

</div>
</div>
<a class="anchor" id="gaebd375194b3220beebe0a22e67d7a4e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CatmullRomSpline&lt; T &gt;::result_type operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1CatmullRomSpline.html#ae45326fbc1e2bb968bbb688bd8da81f1">argument_type</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>function (functor) call </p>

</div>
</div>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.0 (Fri May 19 2017)
</i>
</tr>
</table>
</BODY>
</HTML>
