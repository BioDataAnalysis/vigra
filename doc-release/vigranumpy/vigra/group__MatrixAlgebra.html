<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Advanced Matrix Algebra</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.4 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Advanced Matrix Algebra<div class="ingroups"><a class="el" href="group__LinearAlgebraModule.html">Linear Algebra</a></div>
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>


<p>Solution of linear systems, eigen systems, linear least squares etc.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadeaf1b2866e989c2612712b86236196e"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 &gt; </td></tr>
<tr class="memitem:gadeaf1b2866e989c2612712b86236196e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#gadeaf1b2866e989c2612712b86236196e">choleskyDecomposition</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; &amp;L)</td></tr>
<tr class="separator:gadeaf1b2866e989c2612712b86236196e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f41da2ca248dc0afa075c1e0c56a709"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 &gt; </td></tr>
<tr class="memitem:ga0f41da2ca248dc0afa075c1e0c56a709"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga0f41da2ca248dc0afa075c1e0c56a709">choleskySolve</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;L, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;x)</td></tr>
<tr class="separator:ga0f41da2ca248dc0afa075c1e0c56a709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15edf238753abafb705497c01e38112c"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 &gt; </td></tr>
<tr class="memitem:ga15edf238753abafb705497c01e38112c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga15edf238753abafb705497c01e38112c">determinant</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;a, std::string method=&quot;LU&quot;)</td></tr>
<tr class="separator:ga15edf238753abafb705497c01e38112c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898e3fc2bdea632e7307604325b88016"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 &gt; </td></tr>
<tr class="memitem:ga898e3fc2bdea632e7307604325b88016"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga898e3fc2bdea632e7307604325b88016">inverse</a> (const MultiArrayView&lt; 2, T, C1 &gt; &amp;v, MultiArrayView&lt; 2, T, C2 &gt; &amp;res)</td></tr>
<tr class="separator:ga898e3fc2bdea632e7307604325b88016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d66eaad55a74cf250022e97ae5dd607"><td class="memTemplParams" colspan="2">template&lt;class T , class C &gt; </td></tr>
<tr class="memitem:ga6d66eaad55a74cf250022e97ae5dd607"><td class="memTemplItemLeft" align="right" valign="top">TemporaryMatrix&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga6d66eaad55a74cf250022e97ae5dd607">inverse</a> (const MultiArrayView&lt; 2, T, C &gt; &amp;v)</td></tr>
<tr class="separator:ga6d66eaad55a74cf250022e97ae5dd607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga889fc66edb20976e31a9212a073e411f"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga889fc66edb20976e31a9212a073e411f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga889fc66edb20976e31a9212a073e411f">linearSolve</a> (...)</td></tr>
<tr class="separator:ga889fc66edb20976e31a9212a073e411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a8f25a903663b7428cf0ba01b44b7e5"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 &gt; </td></tr>
<tr class="memitem:ga0a8f25a903663b7428cf0ba01b44b7e5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga0a8f25a903663b7428cf0ba01b44b7e5">linearSolveLowerTriangular</a> (const MultiArrayView&lt; 2, T, C1 &gt; &amp;l, const MultiArrayView&lt; 2, T, C2 &gt; &amp;b, MultiArrayView&lt; 2, T, C3 &gt; x)</td></tr>
<tr class="separator:ga0a8f25a903663b7428cf0ba01b44b7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7661f6e132de307660799727834ac25b"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 &gt; </td></tr>
<tr class="memitem:ga7661f6e132de307660799727834ac25b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga7661f6e132de307660799727834ac25b">linearSolveUpperTriangular</a> (const MultiArrayView&lt; 2, T, C1 &gt; &amp;r, const MultiArrayView&lt; 2, T, C2 &gt; &amp;b, MultiArrayView&lt; 2, T, C3 &gt; x)</td></tr>
<tr class="separator:ga7661f6e132de307660799727834ac25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf664311a5660212a4c9ac7bdb0f1de98"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 &gt; </td></tr>
<tr class="memitem:gaf664311a5660212a4c9ac7bdb0f1de98"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#gaf664311a5660212a4c9ac7bdb0f1de98">logDeterminant</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;a)</td></tr>
<tr class="separator:gaf664311a5660212a4c9ac7bdb0f1de98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9201f15592d676c01ce4f2cc0a784b2e"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 &gt; </td></tr>
<tr class="memitem:ga9201f15592d676c01ce4f2cc0a784b2e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga9201f15592d676c01ce4f2cc0a784b2e">nonsymmetricEigensystem</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;a, MultiArrayView&lt; 2, std::complex&lt; T &gt;, C2 &gt; &amp;ew, MultiArrayView&lt; 2, T, C3 &gt; &amp;ev)</td></tr>
<tr class="separator:ga9201f15592d676c01ce4f2cc0a784b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d356993a9ed3f962643029709b40c2"><td class="memTemplParams" colspan="2">template&lt;class POLYNOMIAL , class VECTOR &gt; </td></tr>
<tr class="memitem:gab5d356993a9ed3f962643029709b40c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#gab5d356993a9ed3f962643029709b40c2">polynomialRealRootsEigenvalueMethod</a> (POLYNOMIAL const &amp;p, VECTOR &amp;roots, bool)</td></tr>
<tr class="separator:gab5d356993a9ed3f962643029709b40c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8beeff7149550f26996388e3450ab402"><td class="memTemplParams" colspan="2">template&lt;class POLYNOMIAL , class VECTOR &gt; </td></tr>
<tr class="memitem:ga8beeff7149550f26996388e3450ab402"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga8beeff7149550f26996388e3450ab402">polynomialRootsEigenvalueMethod</a> (POLYNOMIAL const &amp;poly, VECTOR &amp;roots, bool polishRoots)</td></tr>
<tr class="separator:ga8beeff7149550f26996388e3450ab402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd7bb55aeb57c7646b0eaf8142c7b12"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 &gt; </td></tr>
<tr class="memitem:ga3dd7bb55aeb57c7646b0eaf8142c7b12"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga3dd7bb55aeb57c7646b0eaf8142c7b12">qrDecomposition</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;a, MultiArrayView&lt; 2, T, C2 &gt; &amp;q, MultiArrayView&lt; 2, T, C3 &gt; &amp;r, double epsilon=0.0)</td></tr>
<tr class="separator:ga3dd7bb55aeb57c7646b0eaf8142c7b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58368198ae99f73f3f7b5a7dbf21844f"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 &gt; </td></tr>
<tr class="memitem:ga58368198ae99f73f3f7b5a7dbf21844f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga58368198ae99f73f3f7b5a7dbf21844f">reverseElimination</a> (const MultiArrayView&lt; 2, T, C1 &gt; &amp;r, const MultiArrayView&lt; 2, T, C2 &gt; &amp;b, MultiArrayView&lt; 2, T, C3 &gt; x)</td></tr>
<tr class="separator:ga58368198ae99f73f3f7b5a7dbf21844f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf20e05edcc344f32d96fdaf5a6b3b972"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 , class C4 &gt; </td></tr>
<tr class="memitem:gaf20e05edcc344f32d96fdaf5a6b3b972"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#gaf20e05edcc344f32d96fdaf5a6b3b972">singularValueDecomposition</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; &amp;U, MultiArrayView&lt; 2, T, C3 &gt; &amp;S, MultiArrayView&lt; 2, T, C4 &gt; &amp;V)</td></tr>
<tr class="separator:gaf20e05edcc344f32d96fdaf5a6b3b972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb4d56ba8360951f0ffa62e105e1a69"><td class="memTemplParams" colspan="2">template&lt;class T , class C1 , class C2 , class C3 &gt; </td></tr>
<tr class="memitem:ga2fb4d56ba8360951f0ffa62e105e1a69"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga2fb4d56ba8360951f0ffa62e105e1a69">symmetricEigensystem</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;a, MultiArrayView&lt; 2, T, C2 &gt; &amp;ew, MultiArrayView&lt; 2, T, C3 &gt; &amp;ev)</td></tr>
<tr class="separator:ga2fb4d56ba8360951f0ffa62e105e1a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<p>Solution of linear systems, eigen systems, linear least squares etc. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga2fb4d56ba8360951f0ffa62e105e1a69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::symmetricEigensystem </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the eigensystem of a symmetric matrix.</p>
<p><em>a</em> is a real symmetric matrix, <em>ew</em> is a single-column matrix holding the eigenvalues, and <em>ev</em> is a matrix of the same size as <em>a</em> whose columns are the corresponding eigenvectors. Eigenvalues will be sorted from largest to smallest magnitude. The algorithm returns <code>false</code> when it doesn't converge. It can be applied in-place, i.e. <code>&amp;a == &amp;ev</code> is allowed. The code of this function was adapted from JAMA.</p>
<p><b>#include</b> &lt;<a class="el" href="eigensystem_8hxx_source.html">vigra/eigensystem.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="ga9201f15592d676c01ce4f2cc0a784b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::nonsymmetricEigensystem </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, std::complex&lt; T &gt;, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the eigensystem of a square, but not necessarily symmetric matrix.</p>
<p><em>a</em> is a real square matrix, <em>ew</em> is a single-column matrix holding the possibly complex eigenvalues, and <em>ev</em> is a matrix of the same size as <em>a</em> whose columns are the corresponding eigenvectors. Eigenvalues will be sorted from largest to smallest magnitude. The algorithm returns <code>false</code> when it doesn't converge. It can be applied in-place, i.e. <code>&amp;a == &amp;ev</code> is allowed. The code of this function was adapted from JAMA.</p>
<p><b>#include</b> &lt;<a class="el" href="eigensystem_8hxx_source.html">vigra/eigensystem.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="ga8beeff7149550f26996388e3450ab402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::polynomialRootsEigenvalueMethod </td>
          <td>(</td>
          <td class="paramtype">POLYNOMIAL const &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>polishRoots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the roots of a polynomial using the eigenvalue method.</p>
<p><em>poly</em> is a real polynomial (compatible to <a class="el" href="classvigra_1_1PolynomialView.html">vigra::PolynomialView</a>), and <em>roots</em> a complex valued vector (compatible to <code>std::vector</code> with a <code>value_type</code> compatible to the type <code>POLYNOMIAL::Complex</code>) to which the roots are appended. The function calls <a class="el" href="group__MatrixAlgebra.html#ga9201f15592d676c01ce4f2cc0a784b2e">nonsymmetricEigensystem()</a> with the standard companion matrix yielding the roots as eigenvalues. It returns <code>false</code> if it fails to converge.</p>
<p><b>#include</b> &lt;<a class="el" href="eigensystem_8hxx_source.html">vigra/eigensystem.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a></p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Polynomials.html#gaf46ab7ff907f8abcaccdb43990c4df6b">polynomialRoots()</a>, <a class="el" href="classvigra_1_1Polynomial.html">vigra::Polynomial</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab5d356993a9ed3f962643029709b40c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::polynomialRealRootsEigenvalueMethod </td>
          <td>(</td>
          <td class="paramtype">POLYNOMIAL const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the real roots of a real polynomial using the eigenvalue method.</p>
<p><em>poly</em> is a real polynomial (compatible to <a class="el" href="classvigra_1_1PolynomialView.html">vigra::PolynomialView</a>), and <em>roots</em> a real valued vector (compatible to <code>std::vector</code> with a <code>value_type</code> compatible to the type <code>POLYNOMIAL::Real</code>) to which the roots are appended. The function calls <a class="el" href="group__MatrixAlgebra.html#ga8beeff7149550f26996388e3450ab402">polynomialRootsEigenvalueMethod()</a> and throws away all complex roots. It returns <code>false</code> if it fails to converge. The parameter <code>polishRoots</code> is ignored (it is only here for syntax compatibility with <a class="el" href="group__Polynomials.html#gafdc4f470cee357d53e7db7d40450fde5">polynomialRealRoots()</a>).</p>
<p><b>#include</b> &lt;<a class="el" href="eigensystem_8hxx_source.html">vigra/eigensystem.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a></p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__Polynomials.html#gafdc4f470cee357d53e7db7d40450fde5">polynomialRealRoots()</a>, <a class="el" href="classvigra_1_1Polynomial.html">vigra::Polynomial</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga898e3fc2bdea632e7307604325b88016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::inverse </td>
          <td>(</td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the inverse or pseudo-inverse of matrix <em>v</em>.</p>
<p>If the matrix <em>v</em> is square, <em>res</em> must have the same shape and will contain the inverse of <em>v</em>. If <em>v</em> is rectangular, <em>res</em> must have the transposed shape of <em>v</em>. The inverse is then computed in the least-squares sense, i.e. <em>res</em> will be the pseudo-inverse (Moore-Penrose inverse). The function returns <code>true</code> upon success, and <code>false</code> if <em>v</em> is not invertible (has not full rank). The inverse is computed by means of QR decomposition. This function can be applied in-place.</p>
<p><b>#include</b> &lt;<a class="el" href="linear__solve_8hxx_source.html">vigra/linear_solve.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="ga6d66eaad55a74cf250022e97ae5dd607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TemporaryMatrix&lt;T&gt; vigra::linalg::inverse </td>
          <td>(</td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the inverse or pseudo-inverse of matrix <em>v</em>.</p>
<p>The result is returned as a temporary matrix. If the matrix <em>v</em> is square, the result will have the same shape and contains the inverse of <em>v</em>. If <em>v</em> is rectangular, the result will have the transposed shape of <em>v</em>. The inverse is then computed in the least-squares sense, i.e. <em>res</em> will be the pseudo-inverse (Moore-Penrose inverse). The inverse is computed by means of QR decomposition. If <em>v</em> is not invertible, <code>vigra::PreconditionViolation</code> exception is thrown. Usage:</p>
<div class="fragment"><div class="line">vigra::Matrix&lt;double&gt; v(n, n);</div>
<div class="line">v = ...;</div>
<div class="line"></div>
<div class="line">vigra::Matrix&lt;double&gt; m = <a class="code" href="group__MatrixAlgebra.html#ga898e3fc2bdea632e7307604325b88016">inverse</a>(v);</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="linear__solve_8hxx_source.html">vigra/linear_solve.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="ga15edf238753abafb705497c01e38112c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T vigra::linalg::determinant </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;LU&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the determinant of a square matrix.</p>
<p><em>method</em> must be one of the following: </p>
<dl>
<dt>"Cholesky"</dt>
<dd><p class="startdd">Compute the solution by means of Cholesky decomposition. This method is faster than "LU", but requires the matrix <em>a</em> to be symmetric positive definite. If this is not the case, a <code>ContractViolation</code> exception is thrown.</p>
<p class="enddd"></p>
</dd>
<dt>"LU"</dt>
<dd>(default) Compute the solution by means of LU decomposition. </dd>
</dl>
<p><b>#include</b> &lt;<a class="el" href="linear__solve_8hxx_source.html">vigra/linear_solve.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="gaf664311a5660212a4c9ac7bdb0f1de98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T vigra::linalg::logDeterminant </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the logarithm of the determinant of a symmetric positive definite matrix.</p>
<p>This is useful to avoid multiplication of very large numbers in big matrices. It is implemented by means of Cholesky decomposition.</p>
<p><b>#include</b> &lt;<a class="el" href="linear__solve_8hxx_source.html">vigra/linear_solve.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="gadeaf1b2866e989c2612712b86236196e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::choleskyDecomposition </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cholesky decomposition.</p>
<p><em>A</em> must be a symmetric positive definite matrix, and <em>L</em> will be a lower triangular matrix, such that (up to round-off errors):</p>
<div class="fragment"><div class="line">A == L * <a class="code" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">transpose</a>(L);</div>
</div><!-- fragment --><p>This implementation cannot be applied in-place, i.e. <code>&amp;L == &amp;A</code> is an error. If <em>A</em> is not symmetric, a <code>ContractViolation</code> exception is thrown. If it is not positive definite, the function returns <code>false</code>.</p>
<p><b>#include</b> &lt;<a class="el" href="linear__solve_8hxx_source.html">vigra/linear_solve.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="ga3dd7bb55aeb57c7646b0eaf8142c7b12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::qrDecomposition </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QR decomposition.</p>
<p><em>a</em> contains the original matrix, results are returned in <em>q</em> and <em>r</em>, where <em>q</em> is a orthogonal matrix, and <em>r</em> is an upper triangular matrix, such that (up to round-off errors):</p>
<div class="fragment"><div class="line">a == q * r;</div>
</div><!-- fragment --><p>If <em>a</em> doesn't have full rank, the function returns <code>false</code>. The decomposition is computed by householder transformations. It can be applied in-place, i.e. <code>&amp;a == &amp;q</code> or <code>&amp;a == &amp;r</code> are allowed.</p>
<p><b>#include</b> &lt;<a class="el" href="linear__solve_8hxx_source.html">vigra/linear_solve.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="ga58368198ae99f73f3f7b5a7dbf21844f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::reverseElimination </td>
          <td>(</td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deprecated, use <a class="el" href="group__MatrixAlgebra.html#ga7661f6e132de307660799727834ac25b">linearSolveUpperTriangular()</a>. </p>

</div>
</div>
<a class="anchor" id="ga7661f6e132de307660799727834ac25b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::linearSolveUpperTriangular </td>
          <td>(</td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve a linear system with upper-triangular coefficient matrix.</p>
<p>The square matrix <em>r</em> must be an upper-triangular coefficient matrix as can, for example, be obtained by means of QR decomposition. If <em>r</em> doesn't have full rank the function fails and returns <code>false</code>, otherwise it returns <code>true</code>. The lower triangular part of matrix <em>r</em> will not be touched, so it doesn't need to contain zeros.</p>
<p>The column vectors of matrix <em>b</em> are the right-hand sides of the equation (several equations with the same coefficients can thus be solved in one go). The result is returned int <em>x</em>, whose columns contain the solutions for the corresponding columns of <em>b</em>. This implementation can be applied in-place, i.e. <code>&amp;b == &amp;x</code> is allowed. The following size requirements apply:</p>
<div class="fragment"><div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(r) == <a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(r);</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(r) == <a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(b);</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(r) == <a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(x);</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(b) == <a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(x);</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="linear__solve_8hxx_source.html">vigra/linear_solve.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="ga0a8f25a903663b7428cf0ba01b44b7e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::linearSolveLowerTriangular </td>
          <td>(</td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve a linear system with lower-triangular coefficient matrix.</p>
<p>The square matrix <em>l</em> must be a lower-triangular coefficient matrix. If <em>l</em> doesn't have full rank the function fails and returns <code>false</code>, otherwise it returns <code>true</code>. The upper triangular part of matrix <em>l</em> will not be touched, so it doesn't need to contain zeros.</p>
<p>The column vectors of matrix <em>b</em> are the right-hand sides of the equation (several equations with the same coefficients can thus be solved in one go). The result is returned in <em>x</em>, whose columns contain the solutions for the corresponding columns of <em>b</em>. This implementation can be applied in-place, i.e. <code>&amp;b == &amp;x</code> is allowed. The following size requirements apply:</p>
<div class="fragment"><div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(l) == <a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(l);</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(l) == <a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(b);</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(l) == <a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(x);</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(b) == <a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(x);</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="linear__solve_8hxx_source.html">vigra/linear_solve.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="ga0f41da2ca248dc0afa075c1e0c56a709"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::linalg::choleskySolve </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve a linear system when the Cholesky decomposition of the left hand side is given.</p>
<p>The square matrix <em>L</em> must be a lower-triangular matrix resulting from Cholesky decomposition of some positive definite coefficient matrix.</p>
<p>The column vectors of matrix <em>b</em> are the right-hand sides of the equation (several equations with the same matrix <em>L</em> can thus be solved in one go). The result is returned in <em>x</em>, whose columns contain the solutions for the corresponding columns of <em>b</em>. This implementation can be applied in-place, i.e. <code>&amp;b == &amp;x</code> is allowed. The following size requirements apply:</p>
<div class="fragment"><div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(L) == <a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(L);</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(L) == <a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(b);</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(L) == <a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(x);</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(b) == <a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(x);</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="linear__solve_8hxx_source.html">vigra/linear_solve.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="ga889fc66edb20976e31a9212a073e411f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vigra::linalg::linearSolve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve a linear system.</p>
<p><b> Declarations:</b></p>
<div class="fragment"><div class="line"><span class="comment">// use MultiArrayViews for input and output</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="group__MatrixAlgebra.html#ga889fc66edb20976e31a9212a073e411f">linearSolve</a>(MultiArrayView&lt;2, T, C1&gt; <span class="keyword">const</span> &amp; A, </div>
<div class="line">                 MultiArrayView&lt;2, T, C2&gt; <span class="keyword">const</span> &amp; b,</div>
<div class="line">                 MultiArrayView&lt;2, T, C3&gt; res, </div>
<div class="line">                 std::string method = <span class="stringliteral">&quot;QR&quot;</span>);</div>
<div class="line">                 </div>
<div class="line"><span class="comment">// use TinyVector for RHS and result</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> C1, <span class="keywordtype">int</span> N&gt;</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="group__MatrixAlgebra.html#ga889fc66edb20976e31a9212a073e411f">linearSolve</a>(MultiArrayView&lt;2, T, C1&gt; <span class="keyword">const</span> &amp; A, </div>
<div class="line">                 TinyVector&lt;T, N&gt; <span class="keyword">const</span> &amp; b,</div>
<div class="line">                 TinyVector&lt;T, N&gt; &amp; res, </div>
<div class="line">                 std::string method = <span class="stringliteral">&quot;QR&quot;</span>);</div>
</div><!-- fragment --><p><em>A</em> is the coefficient matrix, and the column vectors in <em>b</em> are the right-hand sides of the equation (so, several equations with the same coefficients can be solved in one go). The result is returned in <em>res</em>, whose columns contain the solutions for the corresponding columns of <em>b</em>. The number of columns of <em>A</em> must equal the number of rows of both <em>b</em> and <em>res</em>, and the number of columns of <em>b</em> and <em>res</em> must match. If right-hand-side and result are specified as <a class="el" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">TinyVector</a>, the number of columns of <em>A</em> must equal N.</p>
<p><em>method</em> must be one of the following: </p>
<dl>
<dt>"Cholesky"</dt>
<dd><p class="startdd">Compute the solution by means of Cholesky decomposition. The coefficient matrix <em>A</em> must by symmetric positive definite. If this is not the case, the function returns <code>false</code>.</p>
<p class="enddd"></p>
</dd>
<dt>"QR"</dt>
<dd><p class="startdd">(default) Compute the solution by means of QR decomposition. The coefficient matrix <em>A</em> can be square or rectangular. In the latter case, it must have more rows than columns, and the solution will be computed in the least squares sense. If <em>A</em> doesn't have full rank, the function returns <code>false</code>.</p>
<p class="enddd"></p>
</dd>
<dt>"SVD"</dt>
<dd><p class="startdd">Compute the solution by means of singular value decomposition. The coefficient matrix <em>A</em> can be square or rectangular. In the latter case, it must have more rows than columns, and the solution will be computed in the least squares sense. If <em>A</em> doesn't have full rank, the function returns <code>false</code>.</p>
<p class="enddd"></p>
</dd>
<dt>"NE"</dt>
<dd>Compute the solution by means of the normal equations, i.e. by applying Cholesky decomposition to the equivalent problem <code>A'*A*x = A'*b</code>. This only makes sense when the equation is to be solved in the least squares sense, i.e. when <em>A</em> is a rectangular matrix with more rows than columns. If <em>A</em> doesn't have full column rank, the function returns <code>false</code>. </dd>
</dl>
<p>This function can be applied in-place, i.e. <code>&amp;b == &amp;res</code> or <code>&amp;A == &amp;res</code> are allowed (provided they have the required shapes).</p>
<p>The following size requirements apply:</p>
<div class="fragment"><div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(r) == <a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(b);</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(r) == <a class="code" href="group__LinearAlgebraFunctions.html#gaa88b5c1277c72b4d4e2b70c278efbffe">rowCount</a>(x);</div>
<div class="line"><a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(b) == <a class="code" href="group__LinearAlgebraFunctions.html#ga40eab6d0fc1e179c173a3b90c9d991be">columnCount</a>(x);</div>
</div><!-- fragment --><p><b>#include</b> &lt;<a class="el" href="linear__solve_8hxx_source.html">vigra/linear_solve.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
<a class="anchor" id="gaf20e05edcc344f32d96fdaf5a6b3b972"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vigra::linalg::singularValueDecomposition </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Singular Value Decomposition.
</pre><p>For an m-by-n matrix <em>A</em> with m &gt;= n, the singular value decomposition is an m-by-n orthogonal matrix <em>U</em>, an n-by-n diagonal matrix S, and an n-by-n orthogonal matrix <em>V</em> so that A = U*S*V'.</p>
<p>To save memory, this functions stores the matrix <em>S</em> in a column vector of appropriate length (a diagonal matrix can be obtained by <code>diagonalMatrix(S)</code>). The singular values, sigma[k] = S(k, 0), are ordered so that sigma[0] &gt;= sigma[1] &gt;= ... &gt;= sigma[n-1].</p>
<p>The singular value decomposition always exists, so this function will never fail (except if the shapes of the argument matrices don't match). The effective numerical rank of A is returned.</p>
<p>(Adapted from JAMA, a Java <a class="el" href="classvigra_1_1linalg_1_1Matrix.html">Matrix</a> Library, developed jointly by the Mathworks and NIST; see <a href="http://math.nist.gov/javanumerics/jama">http://math.nist.gov/javanumerics/jama</a>).</p>
<p><b>#include</b> &lt;<a class="el" href="singular__value__decomposition_8hxx_source.html">vigra/singular_value_decomposition.hxx</a>&gt; or<br/>
 <b>#include</b> &lt;<a class="el" href="linear__algebra_8hxx_source.html">vigra/linear_algebra.hxx</a>&gt;<br/>
 Namespaces: vigra and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> </p>

</div>
</div>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.10.0 (Thu Jan 8 2015)
</i>
</tr>
</table>
</BODY>
</HTML>
