<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - GridGraph&lt; N, DirectedTag &gt; Class Template Reference</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
<script>
var runOnLoad=function(c,o,d,e){function x(){for(e=1;c.length;)c.shift()()}o[d]?(document[d]('DOMContentLoaded',x,0),o[d]('load',x,0)):o.attachEvent('onload',x);return function(t){e?o.setTimeout(t,0):c.push(t)}}([],window,'addEventListener');
</script>
<script type="text/javascript" src="documents/CollapsibleLists.js"></script>
<script type="text/javascript">
    runOnLoad(function(){ CollapsibleLists.apply(); });
</script>
<style type="text/css">
.collapsibleList li.collapsibleListOpen{
  list-style-image:url('documents/pfeil.gif');
  cursor:pointer;
}
.collapsibleList li.collapsibleListClosed{
  list-style-image:url('documents/bullet.gif');
  cursor:pointer;
}
.collapsibleList li.lastItem{
  list-style-image:url('documents/diamond.gif');
}
</style>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://ukoethe.github.io/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">GridGraph&lt; N, DirectedTag &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__MultiIteratorGroup.html">Multi-dimensional Shapes and Array Iterators</a> &#124; <a class="el" href="group__GraphDataStructures.html">Graph Data Structures and Algorithms</a></div>
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>


<p>Define a grid graph in arbitrary dimensions.  
 <a href="classvigra_1_1GridGraph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="multi__gridgraph_8hxx_source.html">vigra/multi_gridgraph.hxx</a>&gt;</code></p>

<p>Inherits GridGraphBase&lt; N, DirectedTag &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph_1_1ArcMap.html">ArcMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an arc property map that maps arc descriptor objects onto property values of type <code>T</code> (API: LEMON).  <a href="classvigra_1_1GridGraph_1_1ArcMap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph_1_1EdgeMap.html">EdgeMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of an edge property map that maps edge descriptor objects onto property values of type <code>T</code> (API: LEMON).  <a href="classvigra_1_1GridGraph_1_1EdgeMap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph_1_1InDegMap.html">InDegMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a property map that returns the number of incoming edges of a given node (API: LEMON, use via <code>lemon::InDegMap&lt;Graph&gt;</code>).  <a href="classvigra_1_1GridGraph_1_1InDegMap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph_1_1IndexMap.html">IndexMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a property map that returns the coordinate of a given node (API: LEMON).  <a href="classvigra_1_1GridGraph_1_1IndexMap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph_1_1NodeMap.html">NodeMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a node property map that maps node descriptor objects onto property values of type <code>T</code> (API: LEMON).  <a href="classvigra_1_1GridGraph_1_1NodeMap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph_1_1OutDegMap.html">OutDegMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a property map that returns the number of outgoing edges of a given node (API: LEMON, use via <code>lemon::OutDegMap&lt;Graph&gt;</code>).  <a href="classvigra_1_1GridGraph_1_1OutDegMap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvigra_1_1GridGraph_1_1traversal__category.html">traversal_category</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define several graph tags related to graph traversal (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::traversal_category</code>).  <a href="structvigra_1_1GridGraph_1_1traversal__category.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af5807aaf1566d6649293aa6764e2a847"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5807aaf1566d6649293aa6764e2a847"></a>
typedef <br class="typebreak"/>
GridGraphNeighborIterator&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#af5807aaf1566d6649293aa6764e2a847">adjacency_iterator</a></td></tr>
<tr class="memdesc:af5807aaf1566d6649293aa6764e2a847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the neighbor vertices of a given vertex (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::adjacency_iterator</code>). <br/></td></tr>
<tr class="separator:af5807aaf1566d6649293aa6764e2a847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b19293db7eb28e6573ff7afa5357520"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b19293db7eb28e6573ff7afa5357520"></a>
typedef GridGraphArcDescriptor&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a></td></tr>
<tr class="memdesc:a0b19293db7eb28e6573ff7afa5357520"><td class="mdescLeft">&#160;</td><td class="mdescRight">The arc (directed edge) descriptor (API: LEMON). <br/></td></tr>
<tr class="separator:a0b19293db7eb28e6573ff7afa5357520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650a6dad427839fba9132ecadd9c3cd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a650a6dad427839fba9132ecadd9c3cd3"></a>
typedef GridGraphArcIterator<br class="typebreak"/>
&lt; N, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a650a6dad427839fba9132ecadd9c3cd3">ArcIt</a></td></tr>
<tr class="memdesc:a650a6dad427839fba9132ecadd9c3cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the acrs (directed edges) of a node (API: LEMON). <br/></td></tr>
<tr class="separator:a650a6dad427839fba9132ecadd9c3cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6525aed07a098a70e67e66f84d71288d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6525aed07a098a70e67e66f84d71288d"></a>
typedef <br class="typebreak"/>
GridGraphNeighborIterator&lt; N, <br class="typebreak"/>
true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a6525aed07a098a70e67e66f84d71288d">back_neighbor_vertex_iterator</a></td></tr>
<tr class="memdesc:a6525aed07a098a70e67e66f84d71288d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over only those neighbor vertices of a given vertex that have smaller ID (API: VIGRA). <br/></td></tr>
<tr class="separator:a6525aed07a098a70e67e66f84d71288d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b9534ac40dd5571628044cbdbe0e29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0b9534ac40dd5571628044cbdbe0e29"></a>
typedef <a class="el" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aa0b9534ac40dd5571628044cbdbe0e29">degree_size_type</a></td></tr>
<tr class="memdesc:aa0b9534ac40dd5571628044cbdbe0e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to specify number of neighbors (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::degree_size_type</code>). <br/></td></tr>
<tr class="separator:aa0b9534ac40dd5571628044cbdbe0e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1aaf000670e40d32fabcbf6e31fc57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c1aaf000670e40d32fabcbf6e31fc57"></a>
typedef DirectedTag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a9c1aaf000670e40d32fabcbf6e31fc57">directed_category</a></td></tr>
<tr class="memdesc:a9c1aaf000670e40d32fabcbf6e31fc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the graph directed or undirected ? (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::directed_category</code>). <br/></td></tr>
<tr class="separator:a9c1aaf000670e40d32fabcbf6e31fc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ce9abaa3afe83da034f1119fe1936a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91ce9abaa3afe83da034f1119fe1936a"></a>
typedef <a class="el" href="classvigra_1_1MultiArrayShape.html">MultiArrayShape</a>&lt; N+1 &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a91ce9abaa3afe83da034f1119fe1936a">Edge</a></td></tr>
<tr class="memdesc:a91ce9abaa3afe83da034f1119fe1936a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge descriptor (API: LEMON). <br/></td></tr>
<tr class="separator:a91ce9abaa3afe83da034f1119fe1936a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669577a4ee8fa94d3063ba02c9018727"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a669577a4ee8fa94d3063ba02c9018727"></a>
typedef GridGraphArcDescriptor&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a669577a4ee8fa94d3063ba02c9018727">edge_descriptor</a></td></tr>
<tr class="memdesc:a669577a4ee8fa94d3063ba02c9018727"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge descriptor (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::edge_descriptor</code>). <br/></td></tr>
<tr class="separator:a669577a4ee8fa94d3063ba02c9018727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b23c17e1c04abf98902ffb076c16224"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b23c17e1c04abf98902ffb076c16224"></a>
typedef GridGraphArcIterator<br class="typebreak"/>
&lt; N,!<a class="el" href="classvigra_1_1GridGraph.html#a41a1e656512cef6a37e65752559fa4f6">is_directed</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a3b23c17e1c04abf98902ffb076c16224">edge_iterator</a></td></tr>
<tr class="memdesc:a3b23c17e1c04abf98902ffb076c16224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the edges of a graph (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::edge_iterator</code>). <br/></td></tr>
<tr class="separator:a3b23c17e1c04abf98902ffb076c16224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf27465886d9ee2a4a903642226e6ecb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf27465886d9ee2a4a903642226e6ecb"></a>
typedef <br class="typebreak"/>
boost_graph::disallow_parallel_edge_tag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aaf27465886d9ee2a4a903642226e6ecb">edge_parallel_category</a></td></tr>
<tr class="memdesc:aaf27465886d9ee2a4a903642226e6ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The graph does not allow multiple edges between the same vertices (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::edge_parallel_category</code>). <br/></td></tr>
<tr class="separator:aaf27465886d9ee2a4a903642226e6ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b460c4cb0f40a0d6a5448ce6d3e92a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b460c4cb0f40a0d6a5448ce6d3e92a0"></a>
typedef <a class="el" href="classvigra_1_1MultiArrayShape.html">MultiArrayShape</a>&lt; N+1 &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a4b460c4cb0f40a0d6a5448ce6d3e92a0">edge_propmap_shape_type</a></td></tr>
<tr class="memdesc:a4b460c4cb0f40a0d6a5448ce6d3e92a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape type of an edge property map (must have one additional dimension). <br/></td></tr>
<tr class="separator:a4b460c4cb0f40a0d6a5448ce6d3e92a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fce9e6587e22b4ee29011a76e67a134"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fce9e6587e22b4ee29011a76e67a134"></a>
typedef GridGraphEdgeIterator<br class="typebreak"/>
&lt; N,!<a class="el" href="classvigra_1_1GridGraph.html#a41a1e656512cef6a37e65752559fa4f6">is_directed</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a3fce9e6587e22b4ee29011a76e67a134">EdgeIt</a></td></tr>
<tr class="memdesc:a3fce9e6587e22b4ee29011a76e67a134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the edges of the graph (API: LEMON). <br/></td></tr>
<tr class="separator:a3fce9e6587e22b4ee29011a76e67a134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18c1c4442f3ed9a1c3cc5d81dc2f51a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad18c1c4442f3ed9a1c3cc5d81dc2f51a"></a>
typedef <a class="el" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#ad18c1c4442f3ed9a1c3cc5d81dc2f51a">edges_size_type</a></td></tr>
<tr class="memdesc:ad18c1c4442f3ed9a1c3cc5d81dc2f51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to specify number of edges (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::edges_size_type</code>). <br/></td></tr>
<tr class="separator:ad18c1c4442f3ed9a1c3cc5d81dc2f51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2d89a1dd3f491863049e9d8e7716a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb2d89a1dd3f491863049e9d8e7716a8"></a>
typedef GridGraphInArcIterator&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#adb2d89a1dd3f491863049e9d8e7716a8">in_edge_iterator</a></td></tr>
<tr class="memdesc:adb2d89a1dd3f491863049e9d8e7716a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the incoming edges of a given vertex (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::in_edge_iterator</code>). <br/></td></tr>
<tr class="separator:adb2d89a1dd3f491863049e9d8e7716a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13b4e8a2a7a170aaf8c98766e3ade0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa13b4e8a2a7a170aaf8c98766e3ade0e"></a>
typedef GridGraphInArcIterator&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aa13b4e8a2a7a170aaf8c98766e3ade0e">InArcIt</a></td></tr>
<tr class="memdesc:aa13b4e8a2a7a170aaf8c98766e3ade0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the incoming arcs of a node (API: LEMON). <br/></td></tr>
<tr class="separator:aa13b4e8a2a7a170aaf8c98766e3ade0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3140049d5868723f2c317c07913edc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea3140049d5868723f2c317c07913edc"></a>
typedef <br class="typebreak"/>
GridGraphOutEdgeIterator&lt; N, <br class="typebreak"/>
true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aea3140049d5868723f2c317c07913edc">IncBackEdgeIt</a></td></tr>
<tr class="memdesc:aea3140049d5868723f2c317c07913edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over only those incident edges of a node that end in a node with smaller ID (API: VIGRA). <br/></td></tr>
<tr class="separator:aea3140049d5868723f2c317c07913edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3919f123f8f58dce4929d2b2c851b25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3919f123f8f58dce4929d2b2c851b25"></a>
typedef <br class="typebreak"/>
GridGraphOutEdgeIterator&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#ae3919f123f8f58dce4929d2b2c851b25">IncEdgeIt</a></td></tr>
<tr class="memdesc:ae3919f123f8f58dce4929d2b2c851b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the incident edges of a node (API: LEMON). <br/></td></tr>
<tr class="separator:ae3919f123f8f58dce4929d2b2c851b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd38a63ae16a4ee1d35647347323025"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedd38a63ae16a4ee1d35647347323025"></a>
typedef <a class="el" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a></td></tr>
<tr class="memdesc:aedd38a63ae16a4ee1d35647347323025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of node and edge IDs. <br/></td></tr>
<tr class="separator:aedd38a63ae16a4ee1d35647347323025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012ffd7df07c424bd4dfa77d2049330d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a012ffd7df07c424bd4dfa77d2049330d"></a>
typedef <a class="el" href="classvigra_1_1GridGraph.html#af5807aaf1566d6649293aa6764e2a847">adjacency_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a012ffd7df07c424bd4dfa77d2049330d">neighbor_vertex_iterator</a></td></tr>
<tr class="memdesc:a012ffd7df07c424bd4dfa77d2049330d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as adjacency_iterator (API: VIGRA). <br/></td></tr>
<tr class="separator:a012ffd7df07c424bd4dfa77d2049330d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821af51b50a0bb348603bd9503e107c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a821af51b50a0bb348603bd9503e107c2"></a>
typedef <a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a></td></tr>
<tr class="memdesc:a821af51b50a0bb348603bd9503e107c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Node descriptor (API: LEMON). <br/></td></tr>
<tr class="separator:a821af51b50a0bb348603bd9503e107c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d31475152acfab3990658bebea5b3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5d31475152acfab3990658bebea5b3d"></a>
typedef <a class="el" href="classvigra_1_1GridGraph.html#ab166868273439e7967ee6f520b3edb75">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#ac5d31475152acfab3990658bebea5b3d">NodeIt</a></td></tr>
<tr class="memdesc:ac5d31475152acfab3990658bebea5b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over all nodes of the graph (API: LEMON). <br/></td></tr>
<tr class="separator:ac5d31475152acfab3990658bebea5b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e087dddb9c5f6029473fae9c1468c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54e087dddb9c5f6029473fae9c1468c7"></a>
typedef <br class="typebreak"/>
GridGraphOutArcIterator&lt; N, <br class="typebreak"/>
true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a54e087dddb9c5f6029473fae9c1468c7">out_back_edge_iterator</a></td></tr>
<tr class="memdesc:a54e087dddb9c5f6029473fae9c1468c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over only those outgoing edges of a given vertex that go to vertices with smaller IDs (API: VIGRA). <br/></td></tr>
<tr class="separator:a54e087dddb9c5f6029473fae9c1468c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0e4dd14f6919fe6a439a01e82b8f66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae0e4dd14f6919fe6a439a01e82b8f66"></a>
typedef <br class="typebreak"/>
GridGraphOutArcIterator&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aae0e4dd14f6919fe6a439a01e82b8f66">out_edge_iterator</a></td></tr>
<tr class="memdesc:aae0e4dd14f6919fe6a439a01e82b8f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the outgoing edges of a given vertex (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::out_edge_iterator</code>). <br/></td></tr>
<tr class="separator:aae0e4dd14f6919fe6a439a01e82b8f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f75c3e13272de9a91cb235ace22189"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38f75c3e13272de9a91cb235ace22189"></a>
typedef <br class="typebreak"/>
GridGraphOutArcIterator&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a38f75c3e13272de9a91cb235ace22189">OutArcIt</a></td></tr>
<tr class="memdesc:a38f75c3e13272de9a91cb235ace22189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the outgoing edges of a node (API: LEMON). <br/></td></tr>
<tr class="separator:a38f75c3e13272de9a91cb235ace22189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19971619717d067441599c7527d87fbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19971619717d067441599c7527d87fbe"></a>
typedef <br class="typebreak"/>
GridGraphOutArcIterator&lt; N, <br class="typebreak"/>
true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a19971619717d067441599c7527d87fbe">OutBackArcIt</a></td></tr>
<tr class="memdesc:a19971619717d067441599c7527d87fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over only those outgoing edges of a node that end in a node with smaller ID (API: VIGRA). <br/></td></tr>
<tr class="separator:a19971619717d067441599c7527d87fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1309b2bf2007a63794a58b72dcda16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e1309b2bf2007a63794a58b72dcda16"></a>
typedef <a class="el" href="classvigra_1_1MultiArrayShape.html">MultiArrayShape</a>&lt; N &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a1e1309b2bf2007a63794a58b72dcda16">shape_type</a></td></tr>
<tr class="memdesc:a1e1309b2bf2007a63794a58b72dcda16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape type of the graph and a node property map. <br/></td></tr>
<tr class="separator:a1e1309b2bf2007a63794a58b72dcda16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6219736822ff80c37d6cbd30f1bb01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b6219736822ff80c37d6cbd30f1bb01"></a>
typedef <a class="el" href="classvigra_1_1GridGraph.html#a1e1309b2bf2007a63794a58b72dcda16">shape_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a></td></tr>
<tr class="memdesc:a6b6219736822ff80c37d6cbd30f1bb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vertex descriptor (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::vertex_descriptor</code>). <br/></td></tr>
<tr class="separator:a6b6219736822ff80c37d6cbd30f1bb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab166868273439e7967ee6f520b3edb75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab166868273439e7967ee6f520b3edb75"></a>
typedef <br class="typebreak"/>
<a class="el" href="classvigra_1_1MultiCoordinateIterator.html">MultiCoordinateIterator</a>&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#ab166868273439e7967ee6f520b3edb75">vertex_iterator</a></td></tr>
<tr class="memdesc:ab166868273439e7967ee6f520b3edb75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over the vertices of the graph (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::vertex_iterator</code>). <br/></td></tr>
<tr class="separator:ab166868273439e7967ee6f520b3edb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a81ed94e775c37907d13c350a18915f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a81ed94e775c37907d13c350a18915f"></a>
typedef boost_graph::no_property&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a1a81ed94e775c37907d13c350a18915f">vertex_property_type</a></td></tr>
<tr class="memdesc:a1a81ed94e775c37907d13c350a18915f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The graph does not define internal property maps (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::vertex_property_type</code>). <br/></td></tr>
<tr class="separator:a1a81ed94e775c37907d13c350a18915f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c2076e346ddfeec3873170a00d5f00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93c2076e346ddfeec3873170a00d5f00"></a>
typedef <a class="el" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a93c2076e346ddfeec3873170a00d5f00">vertices_size_type</a></td></tr>
<tr class="memdesc:a93c2076e346ddfeec3873170a00d5f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to specify number of vertices (API: boost::graph, use via <code>boost::graph_traits&lt;Graph&gt;::vertices_size_type</code>). <br/></td></tr>
<tr class="separator:a93c2076e346ddfeec3873170a00d5f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a47dcbf26dd2745fa5e3585e41f9645bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a47dcbf26dd2745fa5e3585e41f9645bb">arcFromId</a> (<a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a> i) const </td></tr>
<tr class="memdesc:a47dcbf26dd2745fa5e3585e41f9645bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an arc descriptor for the given arc ID <em>i</em> (API: LEMON).  <a href="#a47dcbf26dd2745fa5e3585e41f9645bb">More...</a><br/></td></tr>
<tr class="separator:a47dcbf26dd2745fa5e3585e41f9645bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae830480a68145147f35eb7400dce3145"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae830480a68145147f35eb7400dce3145"></a>
<a class="el" href="classvigra_1_1GridGraph.html#ad18c1c4442f3ed9a1c3cc5d81dc2f51a">edges_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#ae830480a68145147f35eb7400dce3145">arcNum</a> () const </td></tr>
<tr class="memdesc:ae830480a68145147f35eb7400dce3145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of arc in this graph (API: LEMON). <br/></td></tr>
<tr class="separator:ae830480a68145147f35eb7400dce3145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1346aab84588e99f960eeb57ad0f9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf1346aab84588e99f960eeb57ad0f9e"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aa0b9534ac40dd5571628044cbdbe0e29">degree_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#acf1346aab84588e99f960eeb57ad0f9e">back_degree</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:acf1346aab84588e99f960eeb57ad0f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of outgoing backward edges of the given vertex (API: VIGRA). <br/></td></tr>
<tr class="separator:acf1346aab84588e99f960eeb57ad0f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af523a4e95ab69e0fcb656b9d9aaf8371"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af523a4e95ab69e0fcb656b9d9aaf8371"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#af523a4e95ab69e0fcb656b9d9aaf8371">baseNode</a> (<a class="el" href="classvigra_1_1GridGraph.html#ae3919f123f8f58dce4929d2b2c851b25">IncEdgeIt</a> const &amp;e) const </td></tr>
<tr class="memdesc:af523a4e95ab69e0fcb656b9d9aaf8371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start node of the edge the given iterator is referring to (API: LEMON). <br/></td></tr>
<tr class="separator:af523a4e95ab69e0fcb656b9d9aaf8371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc439161e6b57a0914df1123c8933de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecc439161e6b57a0914df1123c8933de"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aecc439161e6b57a0914df1123c8933de">baseNode</a> (<a class="el" href="classvigra_1_1GridGraph.html#aea3140049d5868723f2c317c07913edc">IncBackEdgeIt</a> const &amp;e) const </td></tr>
<tr class="memdesc:aecc439161e6b57a0914df1123c8933de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start node of the edge the given iterator is referring to (API: VIGRA). <br/></td></tr>
<tr class="separator:aecc439161e6b57a0914df1123c8933de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef1e63912f0ab1dc9079a5f9c0d785e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abef1e63912f0ab1dc9079a5f9c0d785e"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#abef1e63912f0ab1dc9079a5f9c0d785e">baseNode</a> (<a class="el" href="classvigra_1_1GridGraph.html#a38f75c3e13272de9a91cb235ace22189">OutArcIt</a> const &amp;a) const </td></tr>
<tr class="memdesc:abef1e63912f0ab1dc9079a5f9c0d785e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start node of the edge the given iterator is referring to (API: LEMON). <br/></td></tr>
<tr class="separator:abef1e63912f0ab1dc9079a5f9c0d785e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa5ede09d60d48b1fd91cd9c50d4998"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0aa5ede09d60d48b1fd91cd9c50d4998"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a0aa5ede09d60d48b1fd91cd9c50d4998">baseNode</a> (<a class="el" href="classvigra_1_1GridGraph.html#a19971619717d067441599c7527d87fbe">OutBackArcIt</a> const &amp;a) const </td></tr>
<tr class="memdesc:a0aa5ede09d60d48b1fd91cd9c50d4998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start node of the edge the given iterator is referring to (API: VIGRA). <br/></td></tr>
<tr class="separator:a0aa5ede09d60d48b1fd91cd9c50d4998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3056f6246bd45f8d20c7a90e7d9d2cb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3056f6246bd45f8d20c7a90e7d9d2cb1"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aa0b9534ac40dd5571628044cbdbe0e29">degree_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a3056f6246bd45f8d20c7a90e7d9d2cb1">degree</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:a3056f6246bd45f8d20c7a90e7d9d2cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of edges (incoming plus outgoing) of the given vertex (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::degree(v, graph)</code>,<br/>
 LEMON has no analogue). <br/></td></tr>
<tr class="separator:a3056f6246bd45f8d20c7a90e7d9d2cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b65acbe8ed541cedf46e213dcc202e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52b65acbe8ed541cedf46e213dcc202e"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a52b65acbe8ed541cedf46e213dcc202e">direct</a> (<a class="el" href="classvigra_1_1GridGraph.html#a91ce9abaa3afe83da034f1119fe1936a">Edge</a> const &amp;e, bool forward) const </td></tr>
<tr class="memdesc:a52b65acbe8ed541cedf46e213dcc202e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an arc for the given edge <em>e</em>, oriented along the edge's natural (<code>forward = true</code>) or reversed (<code>forward = false</code>) direction (API: LEMON). <br/></td></tr>
<tr class="separator:a52b65acbe8ed541cedf46e213dcc202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fa530dd814473e25bf73d8c626d131"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04fa530dd814473e25bf73d8c626d131"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a04fa530dd814473e25bf73d8c626d131">direct</a> (<a class="el" href="classvigra_1_1GridGraph.html#a91ce9abaa3afe83da034f1119fe1936a">Edge</a> const &amp;e, <a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a> const &amp;n) const </td></tr>
<tr class="memdesc:a04fa530dd814473e25bf73d8c626d131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an arc for the given edge <em>e</em> oriented so that node <em>n</em> is the starting node of the arc (API: LEMON), or return <code>lemon::INVALID</code> if the edge is not incident to this node. <br/></td></tr>
<tr class="separator:a04fa530dd814473e25bf73d8c626d131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f66f3d209d78ca5b7cab3b14084285b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f66f3d209d78ca5b7cab3b14084285b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a4f66f3d209d78ca5b7cab3b14084285b">direction</a> (<a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a> const &amp;a) const </td></tr>
<tr class="memdesc:a4f66f3d209d78ca5b7cab3b14084285b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> when the arc is looking on the underlying edge in its natural (i.e. forward) direction, <code>false</code> otherwise (API: LEMON). <br/></td></tr>
<tr class="separator:a4f66f3d209d78ca5b7cab3b14084285b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd24b7b382b7e0faf25274792b12afb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd24b7b382b7e0faf25274792b12afb9"></a>
std::pair&lt; <a class="el" href="classvigra_1_1GridGraph.html#a669577a4ee8fa94d3063ba02c9018727">edge_descriptor</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#abd24b7b382b7e0faf25274792b12afb9">edge</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a6eeb39aa607cd2e17e8884ba781809ba">u</a>, <a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:abd24b7b382b7e0faf25274792b12afb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a descriptor for the edge connecting vertices <em>u</em> and <em>v</em>,<br/>
 or <code>(lemon::INVALID, false)</code> if no such edge exists (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::edge(u, v, graph)</code>). <br/></td></tr>
<tr class="separator:abd24b7b382b7e0faf25274792b12afb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a53908867919234c360c9f92e35589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1GridGraph.html#a91ce9abaa3afe83da034f1119fe1936a">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aa7a53908867919234c360c9f92e35589">edgeFromId</a> (<a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a> i) const </td></tr>
<tr class="memdesc:aa7a53908867919234c360c9f92e35589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge descriptor for the given edge ID <em>i</em> (API: LEMON).  <a href="#aa7a53908867919234c360c9f92e35589">More...</a><br/></td></tr>
<tr class="separator:aa7a53908867919234c360c9f92e35589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa6a95dd82d13241576eeb6df35a7e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaa6a95dd82d13241576eeb6df35a7e9"></a>
<a class="el" href="classvigra_1_1GridGraph.html#ad18c1c4442f3ed9a1c3cc5d81dc2f51a">edges_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#acaa6a95dd82d13241576eeb6df35a7e9">edgeNum</a> () const </td></tr>
<tr class="memdesc:acaa6a95dd82d13241576eeb6df35a7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges in this graph (API: LEMON). <br/></td></tr>
<tr class="separator:acaa6a95dd82d13241576eeb6df35a7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a8f471dff8ca4c5b78bf66fbca9f0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7a8f471dff8ca4c5b78bf66fbca9f0f"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#af7a8f471dff8ca4c5b78bf66fbca9f0f">findArc</a> (<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a6eeb39aa607cd2e17e8884ba781809ba">u</a>, <a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>, <a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a> const &amp;=lemon::INVALID) const </td></tr>
<tr class="memdesc:af7a8f471dff8ca4c5b78bf66fbca9f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a descriptor for the arc connecting vertices <em>u</em> and <em>v</em>,<br/>
or <code>lemon::INVALID</code> if no such edge exists (API: LEMON). <br/></td></tr>
<tr class="separator:af7a8f471dff8ca4c5b78bf66fbca9f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e48c2a72e387cee69aeab9256b7e442"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e48c2a72e387cee69aeab9256b7e442"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a91ce9abaa3afe83da034f1119fe1936a">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a6e48c2a72e387cee69aeab9256b7e442">findEdge</a> (<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a6eeb39aa607cd2e17e8884ba781809ba">u</a>, <a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>, <a class="el" href="classvigra_1_1GridGraph.html#a91ce9abaa3afe83da034f1119fe1936a">Edge</a> const &amp;=lemon::INVALID) const </td></tr>
<tr class="memdesc:a6e48c2a72e387cee69aeab9256b7e442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a descriptor for the edge connecting vertices <em>u</em> and <em>v</em>,<br/>
or <code>lemon::INVALID</code> if no such edge exists (API: LEMON). <br/></td></tr>
<tr class="separator:a6e48c2a72e387cee69aeab9256b7e442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b37932ec6498ae6c9e4eccf0b41ad0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4b37932ec6498ae6c9e4eccf0b41ad0"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aa0b9534ac40dd5571628044cbdbe0e29">degree_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#ac4b37932ec6498ae6c9e4eccf0b41ad0">forward_degree</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:ac4b37932ec6498ae6c9e4eccf0b41ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of outgoing forward edges of the given vertex (API: VIGRA). <br/></td></tr>
<tr class="separator:ac4b37932ec6498ae6c9e4eccf0b41ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177cec05d1e5206c45001cabe9bc1148"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a177cec05d1e5206c45001cabe9bc1148"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a6525aed07a098a70e67e66f84d71288d">back_neighbor_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a177cec05d1e5206c45001cabe9bc1148">get_back_neighbor_vertex_end_iterator</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:a177cec05d1e5206c45001cabe9bc1148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator pointing beyond the range of backward neighbors of the given vertex (API: VIGRA,<br/>
 in analogy to the boost::graph API, we also provide a free function <code>boost::back_adjacent_vertices(v, g)</code>,<br/>
 and LEMON just uses <code>lemon::INVALID</code> instead). <br/></td></tr>
<tr class="separator:a177cec05d1e5206c45001cabe9bc1148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad63569dd79e58b42fb9eb1ea12bee8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad63569dd79e58b42fb9eb1ea12bee8f"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a6525aed07a098a70e67e66f84d71288d">back_neighbor_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aad63569dd79e58b42fb9eb1ea12bee8f">get_back_neighbor_vertex_iterator</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:aad63569dd79e58b42fb9eb1ea12bee8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator pointing to the first backward neighbor of the given vertex (API: VIGRA,<br/>
 in analogy to the boost::graph API, we also provide a free function <code>boost::back_adjacent_vertices(v, g)</code>,<br/>
 and the LEMON analogue is <code>Graph::OutBackArcIt(graph, v)</code>). <br/></td></tr>
<tr class="separator:aad63569dd79e58b42fb9eb1ea12bee8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb97a93c59d695c52dd7a6e0a98951e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fb97a93c59d695c52dd7a6e0a98951e"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a3b23c17e1c04abf98902ffb076c16224">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a5fb97a93c59d695c52dd7a6e0a98951e">get_edge_end_iterator</a> () const </td></tr>
<tr class="memdesc:a5fb97a93c59d695c52dd7a6e0a98951e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get edge iterator pointing beyond the valid range of edges of this graph (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::vertices(graph)</code>,<br/>
 LEMON uses the special value <code>lemon::INVALID</code> instead). <br/></td></tr>
<tr class="separator:a5fb97a93c59d695c52dd7a6e0a98951e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9109cce5345d7f3b45b20d2cd4cd280c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9109cce5345d7f3b45b20d2cd4cd280c"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a3b23c17e1c04abf98902ffb076c16224">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a9109cce5345d7f3b45b20d2cd4cd280c">get_edge_iterator</a> () const </td></tr>
<tr class="memdesc:a9109cce5345d7f3b45b20d2cd4cd280c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get edge iterator pointing to the first edge of the graph (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::edges(graph)</code>,<br/>
 LEMON uses <code>Graph::EdgeIt(graph)</code>). <br/></td></tr>
<tr class="separator:a9109cce5345d7f3b45b20d2cd4cd280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2944d3ce94cfe39e45687dd4468ca5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c2944d3ce94cfe39e45687dd4468ca5"></a>
<a class="el" href="classvigra_1_1GridGraph.html#adb2d89a1dd3f491863049e9d8e7716a8">in_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a6c2944d3ce94cfe39e45687dd4468ca5">get_in_edge_end_iterator</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:a6c2944d3ce94cfe39e45687dd4468ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator pointing beyond the range of incoming edges of the given vertex (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::in_edges(v, graph)</code>,<br/>
 LEMON uses the special value <code>lemon::INVALID</code> instead). <br/></td></tr>
<tr class="separator:a6c2944d3ce94cfe39e45687dd4468ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d7e808e47717e4e5876028f87e6521"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8d7e808e47717e4e5876028f87e6521"></a>
<a class="el" href="classvigra_1_1GridGraph.html#adb2d89a1dd3f491863049e9d8e7716a8">in_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aa8d7e808e47717e4e5876028f87e6521">get_in_edge_iterator</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:aa8d7e808e47717e4e5876028f87e6521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator pointing to the first incoming edge of the given vertex (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::in_edges(v, graph)</code>,<br/>
 LEMON uses <code>Graph::InArcIt(g, v)</code>). <br/></td></tr>
<tr class="separator:aa8d7e808e47717e4e5876028f87e6521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12f2390e5f6347ef14644b6a8dcee06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af12f2390e5f6347ef14644b6a8dcee06"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a012ffd7df07c424bd4dfa77d2049330d">neighbor_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#af12f2390e5f6347ef14644b6a8dcee06">get_neighbor_vertex_end_iterator</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:af12f2390e5f6347ef14644b6a8dcee06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator pointing beyond the range of neighbors of the given vertex (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::adjacent_vertices(v, graph)</code>,<br/>
 LEMON uses the speical value <code>lemon::INVALID</code> instead). <br/></td></tr>
<tr class="separator:af12f2390e5f6347ef14644b6a8dcee06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953267f2cb81f436a15bce3c58880a41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a953267f2cb81f436a15bce3c58880a41"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a012ffd7df07c424bd4dfa77d2049330d">neighbor_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a953267f2cb81f436a15bce3c58880a41">get_neighbor_vertex_iterator</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:a953267f2cb81f436a15bce3c58880a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator pointing to the first neighbor of the given vertex (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::adjacent_vertices(v, graph)</code>,<br/>
 LEMON uses <code>Graph::ArcIt(g, v)</code>). <br/></td></tr>
<tr class="separator:a953267f2cb81f436a15bce3c58880a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ad3870fc30ae4bfa34c1167353633e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0ad3870fc30ae4bfa34c1167353633e"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a54e087dddb9c5f6029473fae9c1468c7">out_back_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#af0ad3870fc30ae4bfa34c1167353633e">get_out_back_edge_end_iterator</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:af0ad3870fc30ae4bfa34c1167353633e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator pointing beyond the range of outgoing backward edges of the given vertex (API: VIGRA,<br/>
 in analogy to the boost::graph API, we also provide a free function <code>boost::out_back_edges(v, g)</code>,<br/>
 and LEMON uses the special value <code>lemon::INVALID</code> instead). <br/></td></tr>
<tr class="separator:af0ad3870fc30ae4bfa34c1167353633e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461a140f5bb37009ae3345e3860ead0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a461a140f5bb37009ae3345e3860ead0f"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a54e087dddb9c5f6029473fae9c1468c7">out_back_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a461a140f5bb37009ae3345e3860ead0f">get_out_back_edge_iterator</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:a461a140f5bb37009ae3345e3860ead0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator pointing to the first outgoing backward edge of the given vertex (API: VIGRA,<br/>
 in analogy to the boost::graph API, we also provide a free function <code>boost::out_back_edges(v, g)</code>,<br/>
 and the LEMON analogue is <code>Graph::IncBackEdgeIt(graph, v)</code>). <br/></td></tr>
<tr class="separator:a461a140f5bb37009ae3345e3860ead0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b7cf653109628c188a52d78750e64d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04b7cf653109628c188a52d78750e64d"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aae0e4dd14f6919fe6a439a01e82b8f66">out_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a04b7cf653109628c188a52d78750e64d">get_out_edge_end_iterator</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:a04b7cf653109628c188a52d78750e64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator pointing beyond the range of outgoing edges of the given vertex (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::out_edges(v, graph)</code>,<br/>
 LEMON uses the special value <code>lemon::INVALID</code> instead). <br/></td></tr>
<tr class="separator:a04b7cf653109628c188a52d78750e64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdf742595f2effa2813000ed95bb3f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fdf742595f2effa2813000ed95bb3f3"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aae0e4dd14f6919fe6a439a01e82b8f66">out_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a5fdf742595f2effa2813000ed95bb3f3">get_out_edge_iterator</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:a5fdf742595f2effa2813000ed95bb3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator pointing to the first outgoing edge of the given vertex (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::out_edges(v, graph)</code>,<br/>
 LEMON uses <code>Graph::OutArcIt(g, v)</code>). <br/></td></tr>
<tr class="separator:a5fdf742595f2effa2813000ed95bb3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee8bee75005be0ba40515d6f20490cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaee8bee75005be0ba40515d6f20490cb"></a>
<a class="el" href="classvigra_1_1GridGraph.html#ab166868273439e7967ee6f520b3edb75">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aaee8bee75005be0ba40515d6f20490cb">get_vertex_end_iterator</a> () const </td></tr>
<tr class="memdesc:aaee8bee75005be0ba40515d6f20490cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vertex iterator pointing beyond the valid range of vertices of this graph (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::vertices(graph)</code>,<br/>
 LEMON uses the special value <code>lemon::INVALID</code> instead). <br/></td></tr>
<tr class="separator:aaee8bee75005be0ba40515d6f20490cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22aa658519ca817c2689cfb8f4f0e68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad22aa658519ca817c2689cfb8f4f0e68"></a>
<a class="el" href="classvigra_1_1GridGraph.html#ab166868273439e7967ee6f520b3edb75">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#ad22aa658519ca817c2689cfb8f4f0e68">get_vertex_iterator</a> () const </td></tr>
<tr class="memdesc:ad22aa658519ca817c2689cfb8f4f0e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vertex iterator pointing to the first vertex of this graph (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::vertices(graph)</code>,<br/>
 LEMON uses <code>Graph::NodeIt(graph)</code>). <br/></td></tr>
<tr class="separator:ad22aa658519ca817c2689cfb8f4f0e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed62be778d3065771d245e3b1774b929"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed62be778d3065771d245e3b1774b929"></a>
<a class="el" href="classvigra_1_1GridGraph.html#ab166868273439e7967ee6f520b3edb75">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aed62be778d3065771d245e3b1774b929">get_vertex_iterator</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:aed62be778d3065771d245e3b1774b929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vertex iterator pointing to the given vertex (API: VIGRA). <br/></td></tr>
<tr class="separator:aed62be778d3065771d245e3b1774b929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7188455c1315f24d326f037b97088de4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a7188455c1315f24d326f037b97088de4">GridGraph</a> (<a class="el" href="classvigra_1_1GridGraph.html#a1e1309b2bf2007a63794a58b72dcda16">shape_type</a> const &amp;shape, <a class="el" href="group__MultiIteratorGroup.html#ga9d75de3edc093f215c3f4d42a966167a">NeighborhoodType</a> ntype=<a class="el" href="group__MultiIteratorGroup.html#gga9d75de3edc093f215c3f4d42a966167aaf5b533c53c0491107c6c9b890b635372">DirectNeighborhood</a>)</td></tr>
<tr class="memdesc:a7188455c1315f24d326f037b97088de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a grid graph with given <em>shape</em> and neighborhood type <em>ntype</em>.  <a href="#a7188455c1315f24d326f037b97088de4">More...</a><br/></td></tr>
<tr class="separator:a7188455c1315f24d326f037b97088de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc9a3565819a263aeeac38634e58e8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dc9a3565819a263aeeac38634e58e8c"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a1dc9a3565819a263aeeac38634e58e8c">id</a> (<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:a1dc9a3565819a263aeeac38634e58e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID (i.e. scan-order index) for node desciptor <em>v</em> (API: LEMON). <br/></td></tr>
<tr class="separator:a1dc9a3565819a263aeeac38634e58e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fc3cf81061a6505fe6053c7b8a500e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9fc3cf81061a6505fe6053c7b8a500e"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#ad9fc3cf81061a6505fe6053c7b8a500e">id</a> (<a class="el" href="classvigra_1_1GridGraph.html#a91ce9abaa3afe83da034f1119fe1936a">Edge</a> const &amp;e) const </td></tr>
<tr class="memdesc:ad9fc3cf81061a6505fe6053c7b8a500e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID (i.e. scan-order index in an edge property map) for the given edges descriptor <em>e</em> (API: LEMON). <br/></td></tr>
<tr class="separator:ad9fc3cf81061a6505fe6053c7b8a500e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ac272d8c5216612af33d359655bb81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48ac272d8c5216612af33d359655bb81"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a48ac272d8c5216612af33d359655bb81">id</a> (<a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a> const &amp;a) const </td></tr>
<tr class="memdesc:a48ac272d8c5216612af33d359655bb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID (i.e. scan-order index an an arc property map) for the given ar <em>a</em> (API: LEMON). <br/></td></tr>
<tr class="separator:a48ac272d8c5216612af33d359655bb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71c72ef42fc8d9f4d1609542ac70f3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa71c72ef42fc8d9f4d1609542ac70f3a"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aa0b9534ac40dd5571628044cbdbe0e29">degree_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#aa71c72ef42fc8d9f4d1609542ac70f3a">in_degree</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:aa71c72ef42fc8d9f4d1609542ac70f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of incoming edges of the given vertex (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::in_degree(v, graph)</code>,<br/>
 LEMON uses a special property map <code>lemon::InDegMap&lt;Graph&gt;</code>). <br/></td></tr>
<tr class="separator:aa71c72ef42fc8d9f4d1609542ac70f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f999c4f26c4306119a5be087ad88c3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f999c4f26c4306119a5be087ad88c3d"></a>
<a class="el" href="classvigra_1_1GridGraph_1_1IndexMap.html">IndexMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a5f999c4f26c4306119a5be087ad88c3d">indexMap</a> () const </td></tr>
<tr class="memdesc:a5f999c4f26c4306119a5be087ad88c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a property map that returns the coordinate of each node (API: LEMON <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a>). <br/></td></tr>
<tr class="separator:a5f999c4f26c4306119a5be087ad88c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e482bb7565bb7be9052994335acb98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99e482bb7565bb7be9052994335acb98"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a99e482bb7565bb7be9052994335acb98">maxArcId</a> () const </td></tr>
<tr class="memdesc:a99e482bb7565bb7be9052994335acb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximal ID af any arc in this graph (API: LEMON). <br/></td></tr>
<tr class="separator:a99e482bb7565bb7be9052994335acb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935de87077030ab2924901a842e1aa1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a935de87077030ab2924901a842e1aa1d"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a935de87077030ab2924901a842e1aa1d">maxEdgeId</a> () const </td></tr>
<tr class="memdesc:a935de87077030ab2924901a842e1aa1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum ID of any edge in this graph (API: LEMON). <br/></td></tr>
<tr class="separator:a935de87077030ab2924901a842e1aa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf30ad78b8b54b3a8d4bd61a7bb7665c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf30ad78b8b54b3a8d4bd61a7bb7665c"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#abf30ad78b8b54b3a8d4bd61a7bb7665c">maxNodeId</a> () const </td></tr>
<tr class="memdesc:abf30ad78b8b54b3a8d4bd61a7bb7665c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum ID of any node in this graph (API: LEMON). <br/></td></tr>
<tr class="separator:abf30ad78b8b54b3a8d4bd61a7bb7665c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5532d49784adaf5b8086f8b3855a2fda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a5532d49784adaf5b8086f8b3855a2fda">nodeFromId</a> (<a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a> i) const </td></tr>
<tr class="memdesc:a5532d49784adaf5b8086f8b3855a2fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node descriptor for given node ID <em>i</em> (API: LEMON).  <a href="#a5532d49784adaf5b8086f8b3855a2fda">More...</a><br/></td></tr>
<tr class="separator:a5532d49784adaf5b8086f8b3855a2fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4dc312c44ebf80cda6b956e2555c6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a4dc312c44ebf80cda6b956e2555c6a"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a93c2076e346ddfeec3873170a00d5f00">vertices_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a9a4dc312c44ebf80cda6b956e2555c6a">nodeNum</a> () const </td></tr>
<tr class="memdesc:a9a4dc312c44ebf80cda6b956e2555c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nodes in this graph (API: LEMON). <br/></td></tr>
<tr class="separator:a9a4dc312c44ebf80cda6b956e2555c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb50350796dac7ede505dee3404a75e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addb50350796dac7ede505dee3404a75e"></a>
<a class="el" href="classvigra_1_1GridGraph.html#ad18c1c4442f3ed9a1c3cc5d81dc2f51a">edges_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#addb50350796dac7ede505dee3404a75e">num_edges</a> () const </td></tr>
<tr class="memdesc:addb50350796dac7ede505dee3404a75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges in this graph (convenience function, boost::graph API provides the free function <code>boost::num_edges(graph)</code>). <br/></td></tr>
<tr class="separator:addb50350796dac7ede505dee3404a75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa5152e9387940b26cbe790e303ad0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfa5152e9387940b26cbe790e303ad0c"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a93c2076e346ddfeec3873170a00d5f00">vertices_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#abfa5152e9387940b26cbe790e303ad0c">num_vertices</a> () const </td></tr>
<tr class="memdesc:abfa5152e9387940b26cbe790e303ad0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertices in this graph (convenience function, the boost::graph API provides the free function <code>boost::num_vertices(graph)</code>). <br/></td></tr>
<tr class="separator:abfa5152e9387940b26cbe790e303ad0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2440b92f5fa81d8d47e2c52f337cce0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2440b92f5fa81d8d47e2c52f337cce0"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#af2440b92f5fa81d8d47e2c52f337cce0">oppositeArc</a> (<a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a> const &amp;a) const </td></tr>
<tr class="memdesc:af2440b92f5fa81d8d47e2c52f337cce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an arc referring to the same edge as the given arc <em>a</em>, but with reversed direction (API: LEMON). <br/></td></tr>
<tr class="separator:af2440b92f5fa81d8d47e2c52f337cce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851d33edfee4920484b74c0f72e9411c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a851d33edfee4920484b74c0f72e9411c"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a851d33edfee4920484b74c0f72e9411c">oppositeNode</a> (<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a> const &amp;n, <a class="el" href="classvigra_1_1GridGraph.html#a91ce9abaa3afe83da034f1119fe1936a">Edge</a> const &amp;e) const </td></tr>
<tr class="memdesc:a851d33edfee4920484b74c0f72e9411c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the opposite node of the given node <em>n</em> along edge <em>e</em> (API: LEMON), or return <code>lemon::INVALID</code> if the edge is not incident to this node. <br/></td></tr>
<tr class="separator:a851d33edfee4920484b74c0f72e9411c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64c005c36c0266af034ced48668210e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae64c005c36c0266af034ced48668210e"></a>
<a class="el" href="classvigra_1_1GridGraph.html#aa0b9534ac40dd5571628044cbdbe0e29">degree_size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#ae64c005c36c0266af034ced48668210e">out_degree</a> (<a class="el" href="classvigra_1_1GridGraph.html#a6b6219736822ff80c37d6cbd30f1bb01">vertex_descriptor</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:ae64c005c36c0266af034ced48668210e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of outgoing edges of the given vertex (convenience function,<br/>
 the boost::graph API provides the free function <code>boost::out_degree(v, graph)</code>,<br/>
 LEMON uses a special property map <code>lemon::OutDegMap&lt;Graph&gt;</code>). <br/></td></tr>
<tr class="separator:ae64c005c36c0266af034ced48668210e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae531ff20100257d10b327a21a939c52f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae531ff20100257d10b327a21a939c52f"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#ae531ff20100257d10b327a21a939c52f">pos</a> (<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a> const &amp;<a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a>) const </td></tr>
<tr class="memdesc:ae531ff20100257d10b327a21a939c52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the grid cordinate of the given node <em>v</em> (convenience function). <br/></td></tr>
<tr class="separator:ae531ff20100257d10b327a21a939c52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc9c8a6839b1eb3a4c6002d5cc6b365"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fc9c8a6839b1eb3a4c6002d5cc6b365"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a2fc9c8a6839b1eb3a4c6002d5cc6b365">runningNode</a> (<a class="el" href="classvigra_1_1GridGraph.html#ae3919f123f8f58dce4929d2b2c851b25">IncEdgeIt</a> const &amp;e) const </td></tr>
<tr class="memdesc:a2fc9c8a6839b1eb3a4c6002d5cc6b365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end node of the edge the given iterator is referring to (API: LEMON). <br/></td></tr>
<tr class="separator:a2fc9c8a6839b1eb3a4c6002d5cc6b365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9689945d301970bfea1248c11ca535cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9689945d301970bfea1248c11ca535cb"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a9689945d301970bfea1248c11ca535cb">runningNode</a> (<a class="el" href="classvigra_1_1GridGraph.html#aea3140049d5868723f2c317c07913edc">IncBackEdgeIt</a> const &amp;e) const </td></tr>
<tr class="memdesc:a9689945d301970bfea1248c11ca535cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end node of the edge the given iterator is referring to (API: VIGRA). <br/></td></tr>
<tr class="separator:a9689945d301970bfea1248c11ca535cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d8eed5cb1af5be21f6e3cd2f33e933"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96d8eed5cb1af5be21f6e3cd2f33e933"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a96d8eed5cb1af5be21f6e3cd2f33e933">runningNode</a> (<a class="el" href="classvigra_1_1GridGraph.html#a38f75c3e13272de9a91cb235ace22189">OutArcIt</a> const &amp;a) const </td></tr>
<tr class="memdesc:a96d8eed5cb1af5be21f6e3cd2f33e933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end node of the edge the given iterator is referring to (API: LEMON). <br/></td></tr>
<tr class="separator:a96d8eed5cb1af5be21f6e3cd2f33e933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c7a3f07dba02607cbbff8b8e90970a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84c7a3f07dba02607cbbff8b8e90970a"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a84c7a3f07dba02607cbbff8b8e90970a">runningNode</a> (<a class="el" href="classvigra_1_1GridGraph.html#a19971619717d067441599c7527d87fbe">OutBackArcIt</a> const &amp;a) const </td></tr>
<tr class="memdesc:a84c7a3f07dba02607cbbff8b8e90970a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the end node of the edge the given iterator is referring to (API: VIGRA). <br/></td></tr>
<tr class="separator:a84c7a3f07dba02607cbbff8b8e90970a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a2d47db1f8353fea1c34162db9c8fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44a2d47db1f8353fea1c34162db9c8fa"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a44a2d47db1f8353fea1c34162db9c8fa">source</a> (<a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a> const &amp;a) const </td></tr>
<tr class="memdesc:a44a2d47db1f8353fea1c34162db9c8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start node of the given arc <em>a</em> (API: LEMON). <br/></td></tr>
<tr class="separator:a44a2d47db1f8353fea1c34162db9c8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a69c8dd54fb0db639d0022ac4b6dabe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a69c8dd54fb0db639d0022ac4b6dabe"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a3a69c8dd54fb0db639d0022ac4b6dabe">target</a> (<a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a> const &amp;a) const </td></tr>
<tr class="memdesc:a3a69c8dd54fb0db639d0022ac4b6dabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end node of the given arc <em>a</em> (API: LEMON). <br/></td></tr>
<tr class="separator:a3a69c8dd54fb0db639d0022ac4b6dabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeb39aa607cd2e17e8884ba781809ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eeb39aa607cd2e17e8884ba781809ba"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a6eeb39aa607cd2e17e8884ba781809ba">u</a> (<a class="el" href="classvigra_1_1GridGraph.html#a91ce9abaa3afe83da034f1119fe1936a">Edge</a> const &amp;e) const </td></tr>
<tr class="memdesc:a6eeb39aa607cd2e17e8884ba781809ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start node of the given edge <em>e</em> (API: LEMON,<br/>
 the boost::graph API provides the free function <code>boost::source(e, graph)</code>). <br/></td></tr>
<tr class="separator:a6eeb39aa607cd2e17e8884ba781809ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714fad7e4012c93bf63d73337723f1c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a714fad7e4012c93bf63d73337723f1c4"></a>
<a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a714fad7e4012c93bf63d73337723f1c4">v</a> (<a class="el" href="classvigra_1_1GridGraph.html#a91ce9abaa3afe83da034f1119fe1936a">Edge</a> const &amp;e) const </td></tr>
<tr class="memdesc:a714fad7e4012c93bf63d73337723f1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end node of the given edge <em>e</em> (API: LEMON,<br/>
 the boost::graph API provides the free function <code>boost::target(e, graph)</code>). <br/></td></tr>
<tr class="separator:a714fad7e4012c93bf63d73337723f1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9030a4c0955603c53aa62f469e909d47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9030a4c0955603c53aa62f469e909d47"></a>
static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a9030a4c0955603c53aa62f469e909d47">dimension</a> = N</td></tr>
<tr class="memdesc:a9030a4c0955603c53aa62f469e909d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of the grid. <br/></td></tr>
<tr class="separator:a9030a4c0955603c53aa62f469e909d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a1e656512cef6a37e65752559fa4f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41a1e656512cef6a37e65752559fa4f6"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html#a41a1e656512cef6a37e65752559fa4f6">is_directed</a> = IsSameType&lt;DirectedTag, directed_tag&gt;::value</td></tr>
<tr class="memdesc:a41a1e656512cef6a37e65752559fa4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">'true' if the graph is directed (API: boost::graph) <br/></td></tr>
<tr class="separator:a41a1e656512cef6a37e65752559fa4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<div class="textblock"><h3>template&lt;unsigned int N, class DirectedTag&gt;<br/>
class vigra::GridGraph&lt; N, DirectedTag &gt;</h3>

<p>Define a grid graph in arbitrary dimensions. </p>
<p>A <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a> connects each pixel to its direct or indirect neighbors. Direct neighbors are the adjacent point along the coordinate axes, whereas indirect neighbors include the diagonally adjacent points. Thus, direct neighbors correspond to the 4-neighborhood in 2D and the 6-neighborhood in 3D, whereas indirect neighbors correspond to the 8-neighborhood and 26-neighborhood respectively. The <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a> class extends this scheme to arbitrary dimensions. While the dimension must be defined at compile time via the template parameter <code>N</code>, the desired neighborhood can be chosen at runtime in the <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a>'s constructor. The shape of the grid is also specified at runtime in terms of a suitable shape object.</p>
<p>Another choice to be made at compile time is whether the graph should be directed or undirected. This is defined via the <code>DirectedTag</code> template parameter which can take the values <code>directed_tag</code> or <code>undirected_tag</code> (default).</p>
<p>The main difficulty in a grid graph is to skip the missing neighbors of the pixels near the grid's border. For example, the upper left pixel in a 2D grid has only two direct neighbors instead of the usual four. The <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a> class uses a precomputed set of internal look-up tables to efficiently determine the appropriate number and location of the existing neighbors. A key design decision to make this fast was to give up the requirement that edge IDs are contiguous integers (as in LEMON's implementation of a 2D grid graph, which became very complicated and slow by enforcing this requirement). Instead, edges are numbered as if all nodes (including nodes at the grid's border) had the same degree. Since edges crossing the border are not actually present in the graph, these IDs are missing, leading to gaps in the sequence of IDs.</p>
<p>For the sake of compatibility, the <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a> class implements two popular graph APIs: the one defined by the <a href="http://www.boost.org/doc/libs/release/libs/graph/">boost::graph</a> library and the one defined by the <a href="http://lemon.cs.elte.hu/">LEMON</a> library. Their basic principles are very similar: The graph's nodes, edges and adjacency structure are accessed via a set of iterators, whereas additional properties (like node and edge weights) are provided via <em>property maps</em> that are indexed with suitable node or edge descriptor objects returned by the iterators.</p>
<p>Specifically, <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a> implements the requirements of the following <a href="http://www.boost.org/doc/libs/release/libs/graph/doc/graph_concepts.html">concepts of the boost::graph API</a>: <b>Graph, IncidenceGraph, BidirectionalGraph, AdjacencyGraph, VertexListGraph, EdgeListGraph,</b> and <b>AdjacencyMatrix</b>. Likewise, it supports the concepts <b>Graph</b> and <b>Digraph</b> of the LEMON API. The property maps associated with a <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a> support the boost concepts ReadablePropertyMap, WritablePropertyMap, ReadWritePropertyMap, and LvaluePropertyMap as well as the LEMON concepts ReadMap, WriteMap, ReadWriteMap, and ReferenceMap.</p>
<p>VIGRA's <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a> class is designed such that multi-dimensional coordinates (i.e. <code>TinyVector&lt;MultiArrayIndex&gt;</code>) serve as descriptor objects, which means that normal <code><a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management. ">MultiArray</a></code>s or <code><a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray. ">MultiArrayView</a></code>s can serve as property maps in most situations. Thus, node properties like a foreground probability for foreground/background segmentation can simply be stored as normal images.</p>
<p>Since the boost::graph and LEMON APIs differ in how they call corresponding functionality (e.g., they use the terms <code>vertex</code> and <code>node</code> respectively in an exactly synonymous way), most <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a> helper classes and functions are exposed under two different names. To implement your own algorithms, you can choose the API you like most. VIGRA adopts the convention that algorithms using the boost::graph API go into the namespace <code>vigra::boost_graph</code>, while those using the LEMON API are placed into the namespace <code>vigra::lemon_graph</code>. This helps to avoid name clashes when the two APIs happen to use the same name for different things. The documentation of the <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a> members specifies which API the respective function or class belongs to. Please consult the documentation of these libraries for tutorial introductions and full reference of the respective APIs.</p>
<p>VIGRA adds an important new concept of its own: the back neighborhood and associated adjacency and edge iterators. The back neighborhood of a given vertex with ID <code>i</code> is the set of all neighbor vertices whose ID is smaller than <code>i</code>. This concept is useful if you work on the grid graph's vertices in scan order and want to access just those neighbors that have already been processed. Connected components labeling is a typical example of an algorithm that can take advantage of this possibility. In principle, a back neighborhood iterator could be implemented as a filter iterator that simply skips all neighbors with inappropriate IDs. However, in case of grid graphs it is more efficient to provide a special iterator for this purpose.</p>
<p><b>Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__gridgraph_8hxx_source.html">vigra/multi_gridgraph.hxx</a>&gt; <br/>
 Namespace: vigra</p>
<p>At present, the <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a> class is mainly used internally to implement image analysis functions for arbitrary dimensional arrays (e.g. detection of local extrema, connected components labeling, watersheds, SLIC superpixels). For example, a dimension-independent algorithm to detect local maxima using the LEMON API might look like this:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra { <span class="keyword">namespace </span>lemon_graph { </div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Graph, <span class="keyword">class</span> InputMap, <span class="keyword">class</span> OutputMap&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="group__LocalMinMax.html#ga00086937b5ac265fc74b5a8ee0c15c47">localMaxima</a>(Graph <span class="keyword">const</span> &amp; g, </div>
<div class="line">            InputMap <span class="keyword">const</span> &amp; src,</div>
<div class="line">            OutputMap &amp; local_maxima,</div>
<div class="line">            <span class="keyword">typename</span> OutputMap::value_type marker)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// define abreviations for the required iterators</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvigra_1_1GridGraph.html#ac5d31475152acfab3990658bebea5b3d">Graph::NodeIt</a>    graph_scanner;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classvigra_1_1GridGraph.html#a38f75c3e13272de9a91cb235ace22189">Graph::OutArcIt</a>  neighbor_iterator;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// iterate over all nodes (i.e. pixels)</span></div>
<div class="line">    <span class="keywordflow">for</span> (graph_scanner node(g); node != INVALID; ++node) </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// remember the value of the current node</span></div>
<div class="line">        <span class="keyword">typename</span> InputMap::value_type current = src[*node];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// iterate over all neighbors of the current node</span></div>
<div class="line">        <span class="keywordtype">bool</span> is_local_maximum = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (neighbor_iterator arc(g, node); arc != INVALID; ++arc)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// if a neighbor has larger value, the center node is not a local maximum</span></div>
<div class="line">            <span class="keywordflow">if</span> (current &lt; src[g.target(*arc)]) </div>
<div class="line">                is_local_maximum = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// mark the node when it is a local maximum</span></div>
<div class="line">        <span class="keywordflow">if</span> (is_local_maximum)</div>
<div class="line">            local_maxima[*node] = marker;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">}} <span class="comment">// namespace vigra::lemon_graph</span></div>
</div><!-- fragment --><p>It should be noted that this algorithm will work for any LEMON-compatible graph class, not just our <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a>. When implemented in terms of the boost::graph API, the same algorithm looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra { <span class="keyword">namespace </span>boost_graph {</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Graph, <span class="keyword">class</span> InputMap, <span class="keyword">class</span> OutputMap&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="group__LocalMinMax.html#ga00086937b5ac265fc74b5a8ee0c15c47">localMaxima</a>(Graph <span class="keyword">const</span> &amp; g, </div>
<div class="line">            InputMap <span class="keyword">const</span> &amp; src,</div>
<div class="line">            OutputMap &amp; local_maxima,</div>
<div class="line">            <span class="keyword">typename</span> property_traits&lt;OutputMap&gt;::value_type marker)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// define abreviations and variables for the required iterators</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> graph_traits&lt;Graph&gt;::vertex_iterator graph_scanner;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> graph_traits&lt;Graph&gt;::adjacency_iterator neighbor_iterator;</div>
<div class="line"></div>
<div class="line">    graph_scanner      node, node_end;</div>
<div class="line">    neighbor_iterator  arc, arc_end;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// iterate over all nodes (i.e. pixels)</span></div>
<div class="line">    tie(node, node_end) = <a class="code" href="group__BoostGraphExtensions.html#ga0b1f49082a282771c07aa9563735080c">vertices</a>(g);</div>
<div class="line">    <span class="keywordflow">for</span> (; node != node_end; ++node) </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// remember the value of the current node</span></div>
<div class="line">        <span class="keyword">typename</span> property_traits&lt;InputMap&gt;::value_type current = <span class="keyword">get</span>(src, *node);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// iterate over all neighbors of the current node</span></div>
<div class="line">        <span class="keywordtype">bool</span> is_local_maximum = <span class="keyword">true</span>;</div>
<div class="line">        tie(arc, arc_end) = <a class="code" href="group__BoostGraphExtensions.html#gafd7bc995bace604067a5e38262da6321">adjacent_vertices</a>(*node, g);</div>
<div class="line">        <span class="keywordflow">for</span> (;arc != arc_end; ++arc)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// if a neighbor has larger value, the center node is not a local maximum</span></div>
<div class="line">            <span class="keywordflow">if</span> (current &lt; <span class="keyword">get</span>(src, *arc))</div>
<div class="line">                is_local_maximum = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// mark the node when it is a local maximum</span></div>
<div class="line">        <span class="keywordflow">if</span> (is_local_maximum)</div>
<div class="line">            <a class="code" href="group__BoostGraphExtensions.html#gad47aa309735db69c586e5be95d3edffd">put</a>(local_maxima, *node, marker);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">}} <span class="comment">// namespace vigra::boost_graph</span></div>
</div><!-- fragment --><p>It can be seen that the differences between the APIs are mainly syntactic (especially note that boost::graph users traits classes and free functions, whereas LEMON uses nested typedefs and member functions). Either of these algorithms can now serve as the backend of a local maxima detector for <code>MultiArrayViews</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, </div>
<div class="line">                          <span class="keyword">class </span>T2&gt;</div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line"><a class="code" href="group__LocalMinMax.html#ga00086937b5ac265fc74b5a8ee0c15c47">localMaxima</a>(MultiArrayView&lt;N, T1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">            MultiArrayView&lt;N, T2&gt; local_maxima,</div>
<div class="line">            T2 marker,</div>
<div class="line">            <a class="code" href="group__MultiIteratorGroup.html#ga9d75de3edc093f215c3f4d42a966167a">NeighborhoodType</a> neighborhood = <a class="code" href="group__MultiIteratorGroup.html#gga9d75de3edc093f215c3f4d42a966167aabee0bb96274e332d294c1aa2893f6cac">IndirectNeighborhood</a>)</div>
<div class="line">{</div>
<div class="line">    vigra_precondition(src.shape() == local_maxima.shape(),</div>
<div class="line">        <span class="stringliteral">&quot;localMinMax(): shape mismatch between input and output.&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// create a grid graph with appropriate shape and desired neighborhood</span></div>
<div class="line">    GridGraph&lt;N, undirected_tag&gt; graph(src.shape(), neighborhood);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// forward the call to the graph-based algorithm, using </span></div>
<div class="line">    <span class="comment">// the given MultiArrayViews as property maps</span></div>
<div class="line">    <a class="code" href="group__LocalMinMax.html#ga00086937b5ac265fc74b5a8ee0c15c47">lemon_graph::localMaxima</a>(graph, src, local_maxima, marker);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace vigra</span></div>
</div><!-- fragment --><p>A slightly enhanced version of this code is actually used to implement this functionality in VIGRA. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="graph_agglomerative_clustering_8cxx-example.html#_a15">graph_agglomerative_clustering.cxx</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7188455c1315f24d326f037b97088de4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1GridGraph.html">GridGraph</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1GridGraph.html#a1e1309b2bf2007a63794a58b72dcda16">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MultiIteratorGroup.html#ga9d75de3edc093f215c3f4d42a966167a">NeighborhoodType</a>&#160;</td>
          <td class="paramname"><em>ntype</em> = <code><a class="el" href="group__MultiIteratorGroup.html#gga9d75de3edc093f215c3f4d42a966167aaf5b533c53c0491107c6c9b890b635372">DirectNeighborhood</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a grid graph with given <em>shape</em> and neighborhood type <em>ntype</em>. </p>
<p>The shape must have type <code><a class="el" href="classvigra_1_1MultiArrayShape.html#a9332e35fe85b77b01fdeeacdea0f3504">MultiArrayShape&lt;N&gt;::type</a></code> with the appropriate dimension <code>N</code>. The neighborhood type can take the values <code>DirectNeighborhood</code> to use only the axis-aligned edges (2N-neighborhood) and <code>IndirectNeighborhood</code> to use all diagonal edges as well ((3<sup>N</sup>-1)-neighborhood). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5532d49784adaf5b8086f8b3855a2fda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1GridGraph.html#a821af51b50a0bb348603bd9503e107c2">Node</a> nodeFromId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get node descriptor for given node ID <em>i</em> (API: LEMON). </p>
<p>Return <code>Node(lemon::INVALID)</code> when the ID does not exist in this graph. </p>

</div>
</div>
<a class="anchor" id="aa7a53908867919234c360c9f92e35589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1GridGraph.html#a91ce9abaa3afe83da034f1119fe1936a">Edge</a> edgeFromId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge descriptor for the given edge ID <em>i</em> (API: LEMON). </p>
<p>Return <code>Edge(lemon::INVALID)</code> when the ID does not exist in this graph. </p>

</div>
</div>
<a class="anchor" id="a47dcbf26dd2745fa5e3585e41f9645bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1GridGraph.html#a0b19293db7eb28e6573ff7afa5357520">Arc</a> arcFromId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1GridGraph.html#aedd38a63ae16a4ee1d35647347323025">index_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an arc descriptor for the given arc ID <em>i</em> (API: LEMON). </p>
<p>Return <code>Arc(lemon::INVALID)</code> when the ID does not exist in this graph. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>vigra/<a class="el" href="multi__fwd_8hxx_source.html">multi_fwd.hxx</a></li>
<li>vigra/<a class="el" href="multi__gridgraph_8hxx_source.html">multi_gridgraph.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.0 (Fri May 19 2017)
</i>
</tr>
</table>
</BODY>
</HTML>
