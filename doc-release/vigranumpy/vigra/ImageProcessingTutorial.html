<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Image Processing</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
<script>
var runOnLoad=function(c,o,d,e){function x(){for(e=1;c.length;)c.shift()()}o[d]?(document[d]('DOMContentLoaded',x,0),o[d]('load',x,0)):o.attachEvent('onload',x);return function(t){e?o.setTimeout(t,0):c.push(t)}}([],window,'addEventListener');
</script>
<script type="text/javascript" src="documents/CollapsibleLists.js"></script>
<script type="text/javascript">
    runOnLoad(function(){ CollapsibleLists.apply(); });
</script>
<style type="text/css">
.collapsibleList li.collapsibleListOpen{
  list-style-image:url('documents/pfeil.gif');
  cursor:pointer;
}
.collapsibleList li.collapsibleListClosed{
  list-style-image:url('documents/bullet.gif');
  cursor:pointer;
}
.collapsibleList li.lastItem{
  list-style-image:url('documents/diamond.gif');
}
</style>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://ukoethe.github.io/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">Image Processing 
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="textblock"><h2>Section Contents</h2>
<p>In this chapter we'll use VIGRA's methods for some applications of Image Processing.</p>
<ul style="list-style-image:url(documents/diamond.gif)">
<li>
<a class="el" href="ImageProcessingTutorial.html#CallingConventions">Calling Conventions</a> </li>
<li>
<a class="el" href="ImageProcessingTutorial.html#ImageInversion">Inverting an Image</a> </li>
<li>
<a class="el" href="ImageProcessingTutorial.html#ImageBlending">Image Blending</a> </li>
<li>
<a class="el" href="ImageProcessingTutorial.html#CompositeImage">Creating a Composite Image</a> </li>
<li>
<a class="el" href="ImageProcessingTutorial.html#SmoothingTutorial">Smoothing</a> <ul>
<li>
<a class="el" href="ImageProcessingTutorial.html#Convolve2DTutorial">2-dimensional Convolution</a> </li>
<li>
<a class="el" href="ImageProcessingTutorial.html#SeparableConvolveTutorial">Separable Convolution in 2D and nD Images</a> </li>
<li>
<a class="el" href="ImageProcessingTutorial.html#ParallelConvolveTutorial">Parallel Execution of Gaussian Filters</a> </li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="CallingConventions"></a>
Calling Conventions</h1>
<p>VIGRA's image processing functions follow a uniform calling convention: The argument list start with the input images or arrays, followed by the output images or arrays, followed by the function's parameters (if any). Some functions additionally accept an option object that allows more fine-grained control of the function's actions and must be passed as the last argument. Most functions assume that the output arrays already have the appropriate shape.</p>
<p>All functions working on arrays expect their arguments to be passed as <a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a> instances. Functions that only support 2-dimensional images usually contain the term "Image" in their name, whereas functions that act on arbitrary many dimensions usually contain the term "Multi" in their name. <br/>
 Examples: </p>
<div class="fragment"><div class="line"><span class="comment">// determine the connected components in a binary image, using the 8-neighborhood</span></div>
<div class="line">MultiArray&lt;2, UInt8&gt;   image(width, height);</div>
<div class="line">MultiArray&lt;2, UInt32&gt;  labels(width, height);</div>
<div class="line">... <span class="comment">// fill image</span></div>
<div class="line"><a class="code" href="group__Labeling.html#ga25fed81e4512334de2cfa257d38972b2">labelImage</a>(image, labels, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// smooth a 3D array with a gaussian filter with sigma=2.0</span></div>
<div class="line">MultiArray&lt;3, float&gt; volume(Shape3(300, 200, 100)),</div>
<div class="line">                     smoothed(Shape3(300, 200, 100));</div>
<div class="line">... <span class="comment">// fill volume</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(volume, smoothed, 2.0);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// compute the determinant of a 5x5 matrix</span></div>
<div class="line">MultiArray&lt;2, float&gt; matrix(Shape2(5, 5));</div>
<div class="line">... <span class="comment">// fill matrix with data</span></div>
<div class="line"><span class="keywordtype">float</span> det = <a class="code" href="group__MatrixAlgebra.html#gad797f68659e74b21c204d1eb99d98efa">linalg::determinant</a>(matrix);</div>
</div><!-- fragment --><p>For historical reasons, VIGRA also supports two alternative APIs in terms of iterators. These APIs used to be considerably faster, but meanwhile compilers and processors have improved to the point where the much simpler MultiArrayView API no longer imposes a significant abstraction penalty. While there are no plans to remove support for the old APIs, they should not be used in new code.</p>
<ul>
<li>
<p class="startli">Functions on 2-dimensional images may support an <a class="el" href="group__ImageIterators.html">Image Iterators</a> API. These iterators are best passed to the functions via the convenience functions <code>srcImageRange(array)</code>, <code>srcImage(array)</code>, and <code>destImage(array)</code>. A detailed description of the convenience functions can be found in section <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a>. Example: </p>
<div class="fragment"><div class="line"><span class="comment">// compute the pixel-wise square root of an image</span></div>
<div class="line">MultiArray&lt;2, float&gt; input(Shape2(200, 100)),</div>
<div class="line">                     result(imput.shape());</div>
<div class="line">... <span class="comment">// fill input with data</span></div>
<div class="line"><a class="code" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314">transformImage</a>(srcImageRange(input), destImage(result), &amp;<a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c">sqrt</a>);  <span class="comment">// deprecated API</span></div>
</div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Functions for arbitrary-dimensional arrays may support hierarchical <a class="el" href="MultiIteratorPage.html">Multi-dimensional Array Iterators</a>. These iterators are best passed to the functions via the convenience functions <code>srcMultiArrayRange(array)</code>, <code>srcMultiArray(array)</code>, and <code>destMultiArray(array)</code>. A detailed description of these convenience functions can also be found in section <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a>. Example: </p>
<div class="fragment"><div class="line"><span class="comment">// compute the element-wise square root of a 4-dimensional array</span></div>
<div class="line">MultiArray&lt;4, float&gt; input(Shape4(200, 100, 50, 30)),</div>
<div class="line">                     result(imput.shape());</div>
<div class="line">... <span class="comment">// fill input with data</span></div>
<div class="line"><a class="code" href="group__MultiPointoperators.html#ga4e3f906de480f4a867340968da8a98dd">transformMultiArray</a>(srcMultiArrayRange(input), destMultiArray(result), &amp;<a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c">sqrt</a>);  <span class="comment">// deprecated API</span></div>
</div><!-- fragment --><p class="endli"></p>
</li>
</ul>
<h1><a class="anchor" id="ImageInversion"></a>
Inverting an Image</h1>
<p>Inverting an (gray scale) image is quite easy. We just need to subtract every pixel's value from white (255). This simple task doesn't need an explicit function call at all, but is best solved with a arithmetic expression implemented in namespace <a class="el" href="group__MultiMathModule.html">vigra::multi_math</a>. To avoid possible overload ambiguities, you must explicitly activate array arithmetic via the command <code>using namespace <a class="el" href="namespacevigra_1_1multi__math.html">vigra::multi_math</a></code> before use. To invert <code>imageArray</code> and overwrite its original contents, you write:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::multi_math;</div>
<div class="line">imageArray = 255-imageArray;</div>
</div><!-- fragment --><p>See here for a complete example: <a href="invert_tutorial_8cxx-example.html">invert_tutorial.cxx</a></p>
<p>This is the result: </p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_small.gif" alt="lenna_small.gif"/>
<div class="caption">
input file</div></div>
  </td><td><div class="image">
<img src="lenna_inverted.gif" alt="lenna_inverted.gif"/>
<div class="caption">
inverted output file</div></div>
   </td></tr>
</table>
<h1><a class="anchor" id="ImageBlending"></a>
Image Blending</h1>
<p>In this example, we have two input images and want to blend them into one another. In the combined output image every pixel value is the mean of the two appropriate original pixels. This is also best solved with array arithmetic:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::multi_math;</div>
<div class="line">exportArray = 0.5*imageArray1 + 0.5*imageArray2;</div>
</div><!-- fragment --><p>Since it is not guaranteed that the two input images have the same shape, we first determine the maximum possible shape of the blended image, which equals the minimum size along each axis. With the help of subarray-method we just blend the appropriate parts of the two images. These parts (subimages) are aligned around the centers of the original images.</p>
<p>Here's the code: <a href="dissolve_8cxx-example.html">dissolve.cxx</a></p>
<p>And here are the results: </p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_color_small.gif" alt="lenna_color_small.gif"/>
<div class="caption">
input file 1</div></div>
  </td><td><div class="image">
<img src="oi_small.jpg" alt="oi_small.jpg"/>
<div class="caption">
input file 2</div></div>
  </td><td><div class="image">
<img src="dissolved_color.gif" alt="dissolved_color.gif"/>
<div class="caption">
dissolved output file</div></div>
   </td></tr>
</table>
<h1><a class="anchor" id="CompositeImage"></a>
Creating a Composite Image</h1>
<p>Let's come to a little gimmick. Given one input image we want to create a composite image of 4 images reflected with respect to each other. The result resembles the effect of a kaleidoscope. Two of VIGRA's functions are sufficient for this purpose: <a class="el" href="MultiDimensionalArrayTutorial.html#MultiArray_subarray">subarray(p,q)</a> and <a class="el" href="group__GeometricTransformations.html#ga02b427bf3ae88c68505d5e18518d99b0">reflectImage()</a>. Input and output images of <a class="el" href="group__GeometricTransformations.html#ga02b427bf3ae88c68505d5e18518d99b0" title="Reflect image horizontally or vertically. ">reflectImage()</a> are specified by MultiArrayViews. The third parameter specifies the desired reflection axis. The axis can either be horizontal, vertical or both (as in this example):</p>
<div class="fragment"><div class="line"><a class="code" href="group__GeometricTransformations.html#ga02b427bf3ae88c68505d5e18518d99b0">reflectImage</a>(inputArray, outputArray, horizontal | vertical);</div>
</div><!-- fragment --><p>Here's the code: <a href="composite_8cxx-example.html">composite.cxx</a></p>
<p>And here are the results: </p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_color_small.gif" alt="lenna_color_small.gif"/>
<div class="caption">
input file</div></div>
  </td><td><div class="image">
<img src="lenna_composite_color.gif" alt="lenna_composite_color.gif"/>
<div class="caption">
composite output file</div></div>
   </td></tr>
</table>
<h1><a class="anchor" id="SmoothingTutorial"></a>
Smoothing</h1>
<h2><a class="anchor" id="Convolve2DTutorial"></a>
2-dimensional Convolution</h2>
<p>There are many different ways to smooth an image. Before we use VIGRA's methods, we want to write a smoothing code of our own. The idea is to choose each pixel in turn and replace it with the mean of itself and the pixels in 5x5 window around it. To calculate the mean in a window, we can just devide the sum of the pixel values within the corresponding subarray by their number. MultiArrayView provides two useful methods for doing this: <code>sum</code> and <code>size</code>. In our code we iterate over every pixel, construct the surrounding 5x5 window via <code>subarray</code>, and write the average of the window into the corresponding output pixel. Near the borders of the image we truncate the window appropriately so that it remains inside the image, and only take the average over the actually existing neighbours of the pixel.</p>
<p>See the code: <a href="smooth_explicitly_8cxx-example.html">smooth_explicitly.cxx</a></p>
<p>The results: </p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_small.gif" alt="lenna_small.gif"/>
<div class="caption">
input file</div></div>
  </td><td><div class="image">
<img src="lenna_smoothed.gif" alt="lenna_smoothed.gif"/>
<div class="caption">
smoothed output file</div></div>
   </td></tr>
</table>
<p>The technical term for this kind of operation is <em>convolution</em>. VIGRA provides <code>convolveImage</code> as a comfortable way to perform 2-dimensional convolutions with arbitrary filters. You may use it as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(inputImage, resultImage, filter);</div>
</div><!-- fragment --><p>The filter of <em>convolution kernel</em> is given as argument object by <code>kernel2d()</code>. To implement the above smoothing by taking averages in 3x3 windows, you need an averaging kernel with radius 1. Kernel truncation near the image borders is performed when the filter's border treatment mode is set to <code>BORDER_TREATMENT_CLIP</code>:</p>
<div class="fragment"><div class="line">Kernel2D&lt;double&gt; filter;</div>
<div class="line">filter.initAveraging(1);</div>
<div class="line">filter.setBorderTreatment(BORDER_TREATMENT_CLIP);</div>
</div><!-- fragment --><p>By default, VIGRA's convolution functions use <code>BORDER_TREATMENT_REFLECT</code> (i.e. the image is virtually enlarged by reflecting the pixel values about the border), which usually leads to superior results. The strength of smoothing can be controlled by increasing the filter radius.</p>
<p>Another improvement over simple averaging can be achieved when one takes a <em>weighted average</em> such that pixels near the center have more influence on the result. A popular choice here is the 5x5 binomial filter. VIGRA allows to specify arbitrary filter shapes and coefficients via the <code>Kernel2D::initExplicitly()</code>:</p>
<div class="fragment"><div class="line">Kernel2D&lt;float&gt; filter;</div>
<div class="line"></div>
<div class="line"><span class="comment">// specify filter shape (lower right corner is inclusive here!)</span></div>
<div class="line">filter.initExplicitly(Shape2(-2,-2), Shape2(2,2));</div>
<div class="line"></div>
<div class="line"><span class="comment">// specify filter coefficients</span></div>
<div class="line">filter =  1.0/256.0,  4.0/256.0,  6.0/256.0,  4.0/256.0,  1.0/256.0,</div>
<div class="line">          4.0/256.0, 16.0/256.0, 24.0/256.0, 16.0/256.0,  4.0/256.0,</div>
<div class="line">          6.0/256.0, 24.0/256.0, 36.0/256.0, 24.0/256.0,  6.0/256.0,</div>
<div class="line">          4.0/256.0, 16.0/256.0, 24.0/256.0, 16.0/256.0,  4.0/256.0,</div>
<div class="line">          1.0/256.0,  4.0/256.0,  6.0/256.0,  4.0/256.0,  1.0/256.0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// apply filter</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(inputImage, resultImage, filter);</div>
</div><!-- fragment --><p><code>initExplicitly()</code> receives the upper left and lower right corners of the filter window. Note that the lower right corner here is <em>included</em> in the window, in contrast to <code>MultiArray::subarray()</code> where the end point is not included.</p>
<p>The filter weights are provided in a comma separated list. Normally, the sum of the coefficients should to be 1 in order to preserve the average intensity of the image. You must provide either as many coefficients as needed for the given filter size, or exactly one value which will be used for all filter coefficients. Thus, the 3x3 averaging filter can also be created like this:</p>
<div class="fragment"><div class="line">Kernel2D&lt;double&gt; filter;</div>
<div class="line">filter.initExplicitly(Shape2(-1,-1), Shape2(1,1)) = 1.0/9.0;</div>
</div><!-- fragment --><p>For various theoretical and practical reasons, the Gaussian filter is the best choice in most situations. Its coefficients are chosen according to a Gaussian (i.e. bell-shaped) function with given standard deviation. The kernel class has a convenient <code>initGaussian(std_dev)</code> method that creates the appropriate coefficients:</p>
<div class="fragment"><div class="line"><a class="code" href="classvigra_1_1Kernel2D.html">vigra::Kernel2D&lt;float&gt;</a> filter;</div>
<div class="line">filter.<a class="code" href="classvigra_1_1Kernel2D.html#a27d9971d7859098dc18549fd6b8b996f">initGaussian</a>(1.5);</div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(inputImage, resultImage, filter);</div>
</div><!-- fragment --><p>A complete example using these possibilities can be found in <a href="smooth_convolve_8cxx-example.html">smooth_convolve.cxx</a>.</p>
<hr/>
<h2><a class="anchor" id="SeparableConvolveTutorial"></a>
Separable Convolution in 2D and nD Images</h2>
<p>When filtering is implemented with 2-dimensional windows as in the previous section, we need as many multiplications per pixel as there are coefficients in the filter. Fortunately, many important filters (including averaging and Gaussian smoothing) have the property of beeing <em>separable</em>, which allows a much more efficient implementation in terms of 1-dimensional windows. A 2-dimensional filter is separable if its coefficients <img class="formulaInl" alt="$f_{ij}$" src="form_126.png"/> can be expressend as an outer product of two 1-dimensional filters <img class="formulaInl" alt="$h_i$" src="form_127.png"/> and <img class="formulaInl" alt="$c_j$" src="form_128.png"/>:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_{ij} = h_i \cdot c_j \]" src="form_129.png"/>
</p>
<p>For example, the 3x3 averaging filter (with coefficients 1/9) is obtained as the outer product of two 3x1 filters (with coefficients 1/3):</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left( \begin{array}{ccc} \frac{1}{9} &amp; \frac{1}{9} &amp; \frac{1}{9} \\[1ex] \frac{1}{9} &amp; \frac{1}{9} &amp; \frac{1}{9} \\[1ex] \frac{1}{9} &amp; \frac{1}{9} &amp; \frac{1}{9} \end{array} \right) = \left( \begin{array}{c} \frac{1}{3} \\[1ex] \frac{1}{3} \\[1ex] \frac{1}{3} \end{array} \right) \cdot \left( \begin{array}{ccc} \frac{1}{3} &amp; \frac{1}{3} &amp; \frac{1}{3} \end{array} \right) \]" src="form_130.png"/>
</p>
<p>The convolution with separable filters can be implemented by two consecutive 1-dimensional convolutions: first, one filters all rows of the image with the horizontal filter, and then all columns of the result with the vertical filter. Instead of the (n x m) operations required for a 2-dimensional window, we now only need (n + m) operations for the two 1-dimensional ones. Already for a 5x5 window, this reduces the number of operations from 25 to 10, and the difference becomes even bigger with increasing window size.</p>
<p>To construct and apply 1-dimensional filters, VIGRA provides the class <a class="el" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D</a> and the functions <a class="el" href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848" title="Performs a 1 dimensional convolution in x direction. ">separableConvolveX()</a> resp. <a class="el" href="group__SeparableConvolution.html#gaee4f7ee32121e37112a20f5fb8ad4610" title="Performs a 1 dimensional convolution in y direction. ">separableConvolveY()</a>. To compute a 2D Gaussian filter we use the following code:</p>
<div class="fragment"><div class="line">Kernel1D&lt;double&gt; filter;</div>
<div class="line">filter.<a class="code" href="classvigra_1_1Kernel2D.html#a27d9971d7859098dc18549fd6b8b996f">initGaussian</a>(1.5);</div>
<div class="line"></div>
<div class="line">MultiArray&lt;2, float&gt; tmpImage(inputImage.shape());</div>
<div class="line">separateConvolveX(inputImage, tmpImage, filter);</div>
<div class="line">separateConvolveY(tmpImage, resultImage, filter);</div>
</div><!-- fragment --><p>Note that we need an intermediate image to hold the result of the horizontal filtering. The same result is more conveniently achieved by the functions <a class="el" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage()</a> and <a class="el" href="group__ConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113">gaussianSmoothing()</a> (see <a href="smooth_convolve_8cxx-example.html">smooth_convolve.cxx</a> for a working example):</p>
<div class="fragment"><div class="line"><span class="comment">// apply &#39;filter&#39; to both the x- and y-axis</span></div>
<div class="line"><span class="comment">// (calls separateConvolveX() and separateConvolveY() internally)</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(inputImage, resultImage, filter, filter);</div>
<div class="line"></div>
<div class="line"><span class="comment">// smooth image with Gaussian filter with sigma=1.5</span></div>
<div class="line"><span class="comment">// (calls convolveImage() with Gaussian filter internally)</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113">gaussianSmoothing</a>(inputImage, resultImage, 1.5);</div>
</div><!-- fragment --><p>It is, of course, also possible to apply different filters in the x- and y-directions. This is especially useful for derivative filters which are commonly used to compute image features, for example <a class="el" href="group__ConvolutionFilters.html#ga1eedd3703e4ab90a2f8926a453fe6a8f">gaussianGradient()</a> and <a class="el" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude()</a>. For more information see <a class="el" href="group__ConvolutionFilters.html">Convolution Filters</a>.</p>
<p>Separable filters are also the key for efficient convolution of higher-dimensional images and arrays: An n-dimensional filter is simply implemented by n consecutive 1-dimensional filter applications, regardless of the size of n. This is the basis for VIGRA's multi-dimensional filter functions. For example, Gaussian smoothing in arbitrary many dimensions is implemented in <a class="el" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray()</a>:</p>
<div class="fragment"><div class="line">MultiArray&lt;3, UInt8&gt; inputArray(Shape3(100, 100, 100));</div>
<div class="line">... <span class="comment">// fill inputArray with data</span></div>
<div class="line"></div>
<div class="line">MultiArray&lt;3, float&gt; resultArray(inputArray.shape());</div>
<div class="line"></div>
<div class="line"><span class="comment">// perform isotropic Gaussian smoothing at scale 1.5</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(inputArray, resultArray, 1.5);</div>
</div><!-- fragment --><p>More information about VIGRA's multi-dimensional convolution funcions can be found in the reference manual under <a class="el" href="group__ConvolutionFilters.html">Convolution Filters</a>.</p>
<h2><a class="anchor" id="ParallelConvolveTutorial"></a>
Parallel Execution of Gaussian Filters</h2>
<p>The computation of Gaussian filters and their derivatives can be accelerated significantly when rectangular blocks of a large image as processed in parallel. This is easily achieved in VIGRA by passing the option object <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> to the convolution functions:</p>
<div class="fragment"><div class="line"><span class="comment">// create a big array</span></div>
<div class="line">MultiArray&lt;3, UInt8&gt; inputArray(Shape3(1000, 1000, 100));</div>
<div class="line">... <span class="comment">// fill inputArray with data</span></div>
<div class="line"></div>
<div class="line">MultiArray&lt;3, float&gt; resultArray(inputArray.shape());</div>
<div class="line"></div>
<div class="line"><span class="comment">// perform isotropic Gaussian smoothing at scale 1.5 in parallel</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(inputArray, resultArray, 1.5,</div>
<div class="line">                         BlockwiseConvolutionOptions&lt;3&gt;());</div>
</div><!-- fragment --><p>This call will spawn the standard number of threads for the present platform (as returned by <code>std::thread::hardware_concurrency()</code>) and distributes the work across these threads in blocks with a suitable default shape. You can customize the number of threads and the block shape via the option object:</p>
<div class="fragment"><div class="line"><a class="code" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(inputArray, resultArray, 1.5,</div>
<div class="line">                         BlockwiseConvolutionOptions&lt;3&gt;().numThreads(6)</div>
<div class="line">                                                         .blockShape(Shape3(128, 128, 100)));</div>
</div><!-- fragment --><p>The same works for Gaussian derivative filters such as <a class="el" href="group__ConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray()</a>, <a class="el" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude()</a>, and <a class="el" href="group__ConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray()</a>. Refer to section <a class="el" href="group__ConvolutionFilters.html">Convolution Filters</a> for more details. </p>
</div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.0 (Fri May 19 2017)
</i>
</tr>
</table>
</BODY>
</HTML>
