<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - IteratorAdaptor&lt; Policy &gt; Class Template Reference</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.4 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">IteratorAdaptor&lt; Policy &gt; Class Template Reference
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>


<p>Quickly create 1-dimensional iterator adapters.  
 <a href="classvigra_1_1IteratorAdaptor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iteratoradapter_8hxx_source.html">vigra/iteratoradapter.hxx</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4508aff81c9d94e0a3c317068f7fd4fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1IteratorAdaptor.html#a4508aff81c9d94e0a3c317068f7fd4fc">IteratorAdaptor</a> (BaseType const &amp;o)</td></tr>
<tr class="separator:a4508aff81c9d94e0a3c317068f7fd4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Policy&gt;<br/>
class vigra::IteratorAdaptor&lt; Policy &gt;</h3>

<p>Quickly create 1-dimensional iterator adapters. </p>
<p>This class supports the easy creation of 1D iterator adapters out of existing iterators. To use it, you must first implement a policy class that defines the iterator's behavior. The policy is used to instantiate the IteratorAdapter template, which thus automatically obtains all required functions of an STL-compatible iterator. General information on how this works can be found on the <a href="http://www.boost.org/libs/utility/iterator_adaptors.htm">Boost Iterator Adaptor</a> page, although there are some differences in the details of the boost and VIGRA implementations. Here is an example policy class that just exports the behaviour of the underlying iterator:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div>
<div class="line"><span class="keyword">class </span>TrivialIteratorAdaptorPolicy</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// the underlying iterator</span></div>
<div class="line">    <span class="keyword">typedef</span> Iterator                               BaseType;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the adaptor&#39;s value type</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type          value_type;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the adaptor&#39;s difference type (result of &#39;iter1 - iter2&#39;,</span></div>
<div class="line">    <span class="comment">//                                argument of &#39;iter[n]&#39;)</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type     difference_type;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the adaptor&#39;s reference type (result of &#39;*iter&#39;)</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference           reference;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the adaptor&#39;s index_reference type (result of &#39;iter[n]&#39;)</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::index_reference     index_reference;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the adaptor&#39;s pointer type (result of &#39;iter.operator-&gt;()&#39;)</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer             pointer;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the adaptor&#39;s iterator category</span></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category   iterator_category;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// do some additional initialization in the adaptor&#39;s constructor</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> initialize(BaseType &amp; d) {}</div>
<div class="line"></div>
<div class="line">    <span class="comment">// called by &#39;*iter&#39;, &#39;iter-&gt;&#39;</span></div>
<div class="line">    <span class="keyword">static</span> reference dereference(BaseType <span class="keyword">const</span> &amp; d)</div>
<div class="line">        { <span class="keywordflow">return</span> *d; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// called by &#39;iter[n]&#39;</span></div>
<div class="line">    <span class="keyword">static</span> index_reference dereference(BaseType d, difference_type n)</div>
<div class="line">        { <span class="keywordflow">return</span> d[n]; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// called by &#39;iter1 == iter2&#39;, &#39;iter1 != iter2&#39;</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> equal(BaseType <span class="keyword">const</span> &amp; d1, BaseType <span class="keyword">const</span> &amp; d2)</div>
<div class="line">        { <span class="keywordflow">return</span> d1 == d2; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// called by &#39;iter1 &lt; iter2&#39;, &#39;iter1 &lt;= iter2&#39;, &#39;iter1 &gt; iter2&#39;, &#39;iter1 &gt;= iter2&#39;</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> less(BaseType <span class="keyword">const</span> &amp; d1, BaseType <span class="keyword">const</span> &amp; d2)</div>
<div class="line">        { <span class="keywordflow">return</span> d1 &lt; d2; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// called by &#39;iter1 - iter2&#39;</span></div>
<div class="line">    <span class="keyword">static</span> difference_type difference(BaseType <span class="keyword">const</span> &amp; d1, BaseType <span class="keyword">const</span> &amp; d2)</div>
<div class="line">        { <span class="keywordflow">return</span> d1 - d2; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// called by &#39;++iter&#39;, &#39;iter++&#39;</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> increment(BaseType &amp; d)</div>
<div class="line">        { ++d; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// called by &#39;--iter&#39;, &#39;iter--&#39;</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> decrement(BaseType &amp; d)</div>
<div class="line">        { --d; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// called by &#39;iter += n&#39;, &#39;iter -= n&#39;</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> advance(BaseType &amp; d, difference_type n)</div>
<div class="line">        { d += n; }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This policy class is used like this:</p>
<div class="fragment"><div class="line">SomeIterator iter = ...;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1IteratorAdaptor.html" title="Quickly create 1-dimensional iterator adapters. ">vigra::IteratorAdaptor&lt;vigra::TrivialIteratorAdaptorPolicy&lt;SomeIterator&gt;</a> &gt; iter_adaptor(iter);</div>
</div><!-- fragment --><p>By changing the definition of the policy members, a wide range of adaptor behaviors can be achieved. If the base iterator isn't a random access iterator, just drop the functions that cannot be implemented. This simply means that some adaptor functions may not be called, as one would expect from an iterator that doesn't support random access. Note also that the <code>BaseType</code> needs not be an iterator - it can be any type that contains the information necessary for the adaptor to do it's work.</p>
<p><b>#include</b> &lt;<a class="el" href="iteratoradapter_8hxx_source.html">vigra/iteratoradapter.hxx</a>&gt;<br/>
 Namespace: vigra </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4508aff81c9d94e0a3c317068f7fd4fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1IteratorAdaptor.html">IteratorAdaptor</a> </td>
          <td>(</td>
          <td class="paramtype">BaseType const &amp;&#160;</td>
          <td class="paramname"><em>o</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct from an instance of the policy class' BaseType Note that the functions of the adaptor implement the interface of an random access iterator as defined in the C++ standard, so there is no need for explicit documentation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vigra/<a class="el" href="iteratoradapter_8hxx_source.html">iteratoradapter.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.10.0 (Thu Jan 8 2015)
</i>
</tr>
</table>
</BODY>
</HTML>
