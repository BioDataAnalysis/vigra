<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Vigranumpy Reference &mdash; vigranumpy 1.11.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.11.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/vigra-icon.ico"/>
    <link rel="top" title="vigranumpy 1.11.1 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">vigranumpy 1.11.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="vigranumpy-reference">
<h1><a class="toc-backref" href="#id71">Vigranumpy Reference</a><a class="headerlink" href="#vigranumpy-reference" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#vigranumpy-reference" id="id71">Vigranumpy Reference</a><ul>
<li><a class="reference internal" href="#introduction" id="id72">Introduction</a></li>
<li><a class="reference internal" href="#axistags-and-the-vigraarray-data-structure" id="id73">Axistags and the VigraArray Data Structure</a></li>
<li><a class="reference internal" href="#more-on-the-motivation-and-use-of-axistags" id="id74">More On the Motivation and Use of Axistags</a><ul>
<li><a class="reference internal" href="#history-of-the-problem" id="id75">History of the problem</a></li>
<li><a class="reference internal" href="#arrays-as-matrices" id="id76">Arrays as Matrices</a></li>
<li><a class="reference internal" href="#arrays-as-images" id="id77">Arrays as Images</a></li>
<li><a class="reference internal" href="#multi-dimensional-arrays" id="id78">Multi-Dimensional Arrays</a></li>
<li><a class="reference internal" href="#vigra-and-numpy" id="id79">VIGRA and numpy</a></li>
<li><a class="reference internal" href="#vigranumpy-axistags" id="id80">Vigranumpy Axistags</a></li>
<li><a class="reference internal" href="#vigranumpy-conventions" id="id81">Vigranumpy Conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#axistag-reference" id="id82">Axistag Reference</a></li>
<li><a class="reference internal" href="#vigraarray-reference" id="id83">VigraArray Reference</a></li>
<li><a class="reference internal" href="#chunked-arrays-and-data-bigger-than-ram" id="id84">Chunked Arrays and Data Bigger than RAM</a><ul>
<li><a class="reference internal" href="#classes" id="id85">Classes</a></li>
<li><a class="reference internal" href="#factory-functions" id="id86">Factory Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#import-and-export-functions" id="id87">Import and Export Functions</a></li>
<li><a class="reference internal" href="#mathematical-functions-and-type-coercion" id="id88">Mathematical Functions and Type Coercion</a></li>
<li><a class="reference internal" href="#color-and-intensity-manipulation" id="id89">Color and Intensity Manipulation</a></li>
<li><a class="reference internal" href="#filters" id="id90">Filters</a></li>
<li><a class="reference internal" href="#sampling-image-resizing-and-image-pyramids" id="id91">Sampling: Image Resizing and Image Pyramids</a></li>
<li><a class="reference internal" href="#fourier-transforms" id="id92">Fourier Transforms</a></li>
<li><a class="reference internal" href="#image-analysis" id="id93">Image Analysis</a></li>
<li><a class="reference internal" href="#geometry" id="id94">Geometry</a></li>
<li><a class="reference internal" href="#optimization" id="id95">Optimization</a></li>
<li><a class="reference internal" href="#machine-learning" id="id96">Machine Learning</a></li>
<li><a class="reference internal" href="#noise-estimation-and-normalization" id="id97">Noise Estimation and Normalization</a></li>
<li><a class="reference internal" href="#histogram-and-channel-representation" id="id98">Histogram and Channel Representation</a></li>
<li><a class="reference internal" href="#graphs-and-algorithms-on-graphs" id="id99">Graphs and Algorithms on Graphs</a></li>
<li><a class="reference internal" href="#utilities" id="id100">Utilities</a></li>
<li><a class="reference internal" href="#writing-your-own-c-modules" id="id101">Writing Your Own C++ Modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables" id="id102">Indices and tables</a></li>
</ul>
</div>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id72">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Vigranumpy exports the functionality of the C++ image processing library <a class="reference external" href="../vigra/index.html">VIGRA</a> to Python. It can be invoked by importing the vigra module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">vigra</span>
</pre></div>
</div>
<p>Vigranumpy is based on the popular <a class="reference external" href="http://numpy.scipy.org/">numpy</a> module and uses its ndarray data structure to represent image and volume data. It introduces the C++ wrapper class <a class="reference external" href="../../doc/vigra/classvigra_1_1NumpyArray.html">NumpyArray</a> to allow transparent execution of VIGRA C++ functions on numpy arrays. Thus, vigranumpy is fully interoperable with existing numpy functionality, including various tools for image display such as matplotlib. Since vigranumpy uses <a class="reference external" href="http://www.boost.org/doc/libs">boost_python</a>, it is able to support function overloading (which plain Python does not provide), so that calling syntax is largely uniform, regardless of the type and dimension of the input arguments.</p>
<p>Basic calling syntax is similar to C++, with one important difference: Arguments for output images are optional. If no output image is provided, vigranumpy will allocate it as appropriate. In either case, the output image will be returned by the function, for example:</p>
<div class="highlight-python"><div class="highlight"><pre># allocate new result image
&gt;&gt;&gt; smoothImage = vigra.gaussianSmoothing(inputImage, scale)

# reuse and overwrite existing result image
&gt;&gt;&gt; smoothImage = vigra.gaussianSmoothing(inputImage, scale, out=smoothImage)
</pre></div>
</div>
<p>Unless otherwise noted, all functions expect and create arrays with dtype=numpy.float32.</p>
<p>Another important concern is the interpretation and ordering of the array axes. Numpy does not provide any means to attach semantics to axes, but relies purely on the convention that the most important axis is last, as in <tt class="docutils literal"><span class="pre">array[y,</span> <span class="pre">x]</span></tt> or <tt class="docutils literal"><span class="pre">array[z,</span> <span class="pre">y,</span> <span class="pre">x]</span></tt> (&#8220;C-order&#8221;). However, there is no way to enforce this convention in a program, since arrays can be transposed outside of the user&#8217;s control (e.g. when saving data to a file). Moreover, many imaging libraries (e.g. <a class="reference external" href="http://www.imagemagick.org/">Image Magick</a>, <a class="reference external" href="http://opencv.willowgarage.com/">OpenCV</a>, <a class="reference external" href="http://qt-project.org/">Qt</a> and the C++ version of VIGRA) use the opposite convention where the x-axis comes first, as in <tt class="docutils literal"><span class="pre">array[x,</span> <span class="pre">y]</span></tt> or <tt class="docutils literal"><span class="pre">array[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></tt>. This makes it very difficult to convert solutions developed in Python into a fast C++ version, because one has to reverse all indices without making mistakes. Matters become even more complicated when multi-channel (e.g. color) images are considered &#8211; should the color index now be first or last?</p>
<p>To solve these ambiguities in a clean way, vigranumpy introduces the concept of <strong>axistags</strong> which is realized in class <a class="reference internal" href="#vigra.AxisTags" title="vigra.AxisTags"><tt class="xref py py-class docutils literal"><span class="pre">vigra.AxisTags</span></tt></a>. Every <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> (which is a subclass of numpy.ndarray) gets a new property <tt class="docutils literal"><span class="pre">array.axistags</span></tt> that describes axis semantics, and all vigranumpy functions account for and preserve axistag information. Unfortunately, this functionality cannot easily be retrofitted to numpy.ndarray itself. Therefore, we employ the following conversion rules between Python and C++ arrays:</p>
<ul>
<li><p class="first">When the Python array has <strong>no</strong> <tt class="docutils literal"><span class="pre">array.axistags</span></tt> property, it is mapped to the C++ NumpyArray
<strong>without</strong> any change in axis ordering. Since most VIGRA functions can work on arbitrarily
transposed arrays, you will get correct results, but execution may be slower because the
processor cache is poorly utilized in certain axis orders.</p>
<p>Moreover, this may lead to overload resolution ambiguities. For example, when the array has shape
<tt class="docutils literal"><span class="pre">(3,</span> <span class="pre">60,</span> <span class="pre">40)</span></tt>, vigranumpy has no way to decide if this is a 2-dimensional RGB image or
a 3-dimensional array that happens to have only 3 slices. Thus, vigranumpy may not always
execute the function you actually intended to call.</p>
</li>
<li><p class="first">When the Python array <strong>has</strong> the <tt class="docutils literal"><span class="pre">array.axistags</span></tt> property, it is transposed into a
<strong>canonical</strong> axis ordering before vigranumpy executes a function, and the results are
transposed back into the original ordering. Likewise, functions that change axis ordering
(such as <tt class="docutils literal"><span class="pre">array.swapaxes(0,1)</span></tt>) or reduce the number of axes (such as <tt class="docutils literal"><span class="pre">array.max(axis=1)</span></tt>)
as well as array arithmetic operations preserve axistags (see section <a class="reference internal" href="#sec-dtype-coercion"><em>Mathematical Functions and Type Coercion</em></a>).
Thus, you can work in any desired axis order without loosing control. Overload ambiguities
can no longer occur because a function cannot be called when the axistags are unsuitable.</p>
</li>
</ul>
<p>Detailed information about the use of axistags is given in section <a class="reference internal" href="#sec-vigraarray"><em>Axistags and the VigraArray Data Structure</em></a> below. Section <a class="reference internal" href="#sec-own-modules"><em>Writing Your Own C++ Modules</em></a> describes how you can take advantage of the axistags mechanism in your own C++ code.</p>
</div>
<div class="section" id="axistags-and-the-vigraarray-data-structure">
<span id="sec-vigraarray"></span><h2><a class="toc-backref" href="#id73">Axistags and the VigraArray Data Structure</a><a class="headerlink" href="#axistags-and-the-vigraarray-data-structure" title="Permalink to this headline">¶</a></h2>
<p>While vigranumpy can directly work on numpy.ndarrays, this would not give us the advantages of axistags as described above. Therefore, vigranumpy introduces its own array class <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> which is a subclass of numpy.ndarray, but re-implements many of its methods so that axistags are respected. Arrays with a conforming <tt class="docutils literal"><span class="pre">axistags</span></tt> property are most easily constructed by one of the predefined <a class="reference internal" href="#subsec-array-factories"><em>array factories</em></a>. A <strong>view with axistags</strong> can be created from an existing numpy.ndarray by means of the function <a class="reference internal" href="#vigra.taggedView" title="vigra.taggedView"><tt class="xref py py-func docutils literal"><span class="pre">taggedView()</span></tt></a> (in contrast, factory functions create copies of the given arrays, not views). We illustrate the ideas by some examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">3</span>

<span class="go"># create a 2-dimensional RGB image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(300, 200, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span>             <span class="c"># short output: only axis keys</span>
<span class="go">x y c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span><span class="p">)</span>      <span class="c"># long output</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space)</span>
<span class="go">AxisInfo: &#39;y&#39; (type: Space)</span>
<span class="go">AxisInfo: &#39;c&#39; (type: Channels) RGB</span>

<span class="go"># create a 3-dimensional scalar volume</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">ScalarVolume</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(300, 200, 3)        # same shape as before</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">x y z                # but different semantic interpretation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">axistags</span><span class="p">)</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space)</span>
<span class="go">AxisInfo: &#39;y&#39; (type: Space)</span>
<span class="go">AxisInfo: &#39;z&#39; (type: Space)</span>
</pre></div>
</div>
<p>It is also possible to attach additional information to the axistags, in particular the resolution of the axis, and a text comment. The resolution will be correctly adjusted when the image is resized:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mf">1.2</span>  <span class="c"># in some unit of length</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mf">1.4</span>  <span class="c"># in some unit of length</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="s">&#39;fluorescence microscopy, DAPI and GFP staining&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span><span class="p">)</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=1.2)</span>
<span class="go">AxisInfo: &#39;y&#39; (type: Space, resolution=1.4)</span>
<span class="go">AxisInfo: &#39;c&#39; (type: Channels) fluorescence microscopy, DAPI and GFP staining</span>

<span class="go"># interpolate the image to twice its original size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb2</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">height</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">rgb2</span><span class="o">.</span><span class="n">axistags</span><span class="p">)</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=0.6)</span>
<span class="go">AxisInfo: &#39;y&#39; (type: Space, resolution=0.7)</span>
<span class="go">AxisInfo: &#39;c&#39; (type: Channels) fluorescence microscopy, DAPI and GFP staining</span>
</pre></div>
</div>
<p>When the array is transposed, the axistags are transposed accordingly. When axes are dropped from the array, the corresponding entries are dropped from the axistags property:</p>
<div class="highlight-python"><div class="highlight"><pre># transpose the volume into reverse axis order
&gt;&gt;&gt; transposed_volume = volume.transpose()
&gt;&gt;&gt; transposed_volume.shape
(3, 200, 300)
&gt;&gt;&gt; transposed_volume.axistags
z y x

# get a view to the first slice (z == 0)
&gt;&gt;&gt; first_slice = volume[..., 0]
&gt;&gt;&gt; first_slice.shape
(300, 200)
&gt;&gt;&gt; first_slice.axistags
x y

# get the maximum of each slice
&gt;&gt;&gt; volume.max(axis=0).max(axis=0)
VigraArray(shape=(3,), axistags=z, dtype=float32, data=
[ 0.  0.  0.])

# likewise, but specify axes by their keys
&gt;&gt;&gt; volume.max(axis=&#39;x&#39;).max(axis=&#39;y&#39;)
VigraArray(shape=(3,), axistags=z, dtype=float32, data=
[ 0.  0.  0.])
</pre></div>
</div>
<p>The initial ordering of the axes is controlled by the argument <tt class="docutils literal"><span class="pre">order</span></tt> that can optionally be passed to the VigraArray constuctor or the factory functions. If <tt class="docutils literal"><span class="pre">order</span></tt> is not explicitly provided, it is determined by the static property <a class="reference internal" href="#VigraArray.defaultOrder" title="VigraArray.defaultOrder"><tt class="xref py py-attr docutils literal"><span class="pre">VigraArray.defaultOrder</span></tt></a> (which yields &#8216;V&#8217; order). The following orders are currently supported:</p>
<blockquote id="array-order-parameter">
<div><dl class="docutils">
<dt>&#8216;C&#8217; order:</dt>
<dd>Both strides and axes are arranged in descending order, as in a
plain numpy.ndarray. For example, axistags will be &#8216;y x c&#8217; or
&#8216;z y x c&#8217;. array.flags[&#8216;C_CONTIGUOUS&#8217;] will be true.</dd>
<dt>&#8216;F&#8217; order:</dt>
<dd>Both strides and axes are arranged in ascending order, i.e.
opposite to &#8216;C&#8217; order. For example, axistags will be &#8216;c x y&#8217;
or &#8216;c x y z&#8217;. array.flags[&#8216;F_CONTIGUOUS&#8217;] will be true.</dd>
<dt>&#8216;V&#8217; order:</dt>
<dd>VIGRA-order is an interleaved memory layout that simulates
vector-valued pixels or voxels: Channels will be the last axis
and have the smallest stride, whereas all other axes are arranged
in ascending order. For example, axistags will be &#8216;x y c&#8217; or
&#8216;x y z c&#8217;.</dd>
<dt>&#8216;A&#8217; order:</dt>
<dd>Defaults to &#8216;V&#8217; when a new array is created, and means
&#8216;preserve order&#8217; when an existing array is copied.</dd>
</dl>
</div></blockquote>
<p>The meaning of &#8216;ascending&#8217; or &#8216;descending&#8217; order is determined by two rules: the primary order is according to axis type (see <a class="reference internal" href="#vigra.AxisType" title="vigra.AxisType"><tt class="xref py py-class docutils literal"><span class="pre">vigra.AxisType</span></tt></a>), where <tt class="docutils literal"><span class="pre">Channels</span> <span class="pre">&lt;</span> <span class="pre">Space</span> <span class="pre">&lt;</span> <span class="pre">Angle</span> <span class="pre">&lt;</span> <span class="pre">Time</span> <span class="pre">&lt;</span> <span class="pre">Frequency</span> <span class="pre">&lt;</span> <span class="pre">Unknown</span></tt>. The secondary order (between axes of the same type) is lexicographic, such that &#8216;x&#8217; &lt; &#8216;y&#8217; &lt; &#8216;z&#8217;. Usage examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rgbv</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;V&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbv</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(300, 200, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbv</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">x y c</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbc</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbc</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(200, 300, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbc</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">y x c</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbf</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbf</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 300, 200)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgbf</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">c x y</span>
</pre></div>
</div>
<p>Functions that reduce the array to a one-dimensional shape (<tt class="docutils literal"><span class="pre">flatten()</span></tt>, <tt class="docutils literal"><span class="pre">flat</span></tt>, <tt class="docutils literal"><span class="pre">ravel()</span></tt>, <tt class="docutils literal"><span class="pre">take()</span></tt>) always transpose the array into &#8216;C&#8217; order before flattening.</p>
<p>Axistags are stored in a list-like class <a class="reference internal" href="#vigra.AxisTags" title="vigra.AxisTags"><tt class="xref py py-class docutils literal"><span class="pre">vigra.AxisTags</span></tt></a>, whose individual entries are of type <a class="reference internal" href="#vigra.AxisInfo" title="vigra.AxisInfo"><tt class="xref py py-class docutils literal"><span class="pre">vigra.AxisInfo</span></tt></a>. The simplest way to attach axistags to a plain numpy.ndarray (by creating a view of type VigraArray) is via the convenience function <a class="reference internal" href="#vigra.taggedView" title="vigra.taggedView"><tt class="xref py py-func docutils literal"><span class="pre">vigra.taggedView()</span></tt></a>.</p>
</div>
<div class="section" id="more-on-the-motivation-and-use-of-axistags">
<h2><a class="toc-backref" href="#id74">More On the Motivation and Use of Axistags</a><a class="headerlink" href="#more-on-the-motivation-and-use-of-axistags" title="Permalink to this headline">¶</a></h2>
<div class="section" id="history-of-the-problem">
<h3><a class="toc-backref" href="#id75">History of the problem</a><a class="headerlink" href="#history-of-the-problem" title="Permalink to this headline">¶</a></h3>
<p>A Fortran array declaration:</p>
<div class="highlight-python"><div class="highlight"><pre>real f(20,10)
</pre></div>
</div>
<p>is compiled such that the elements of the first index are consecutive in memory. In contrast, a C array declaration:</p>
<div class="highlight-python"><div class="highlight"><pre>float c[20][10];
</pre></div>
</div>
<p>places the elements of the last index consecutive in memory. The two possibilities are commonly referred to as &#8220;Fortran order&#8221; and &#8220;C order&#8221;, but we will see that these terms are actually ambiguous because their meaning depends on what the array is used for.</p>
</div>
<div class="section" id="arrays-as-matrices">
<h3><a class="toc-backref" href="#id76">Arrays as Matrices</a><a class="headerlink" href="#arrays-as-matrices" title="Permalink to this headline">¶</a></h3>
<p>When the array represents a matrix, users require the syntax to conform to the mathematical syntax conventions (in order to avoid bugs when typing formulas). In mathematics, m<sub>ij</sub> means that the first index i refers to rows, and the second index j refers to columns. Thus, Fortran&#8217;s <tt class="docutils literal"><span class="pre">f(i,</span> <span class="pre">j)</span></tt> and C&#8217;s <tt class="docutils literal"><span class="pre">c[i][j]</span></tt> have exactly the same meaning, but the memory layouts of the two matrices differ: Since in Fortran the first index changes quickest, this is referred to as the &#8220;column major&#8221; format (the elements of a column are consecutive in memory). In contrast, C uses the &#8220;row major&#8221; format (the elements of a row are consecutive in memory).</p>
<p>In short: When the array is a matrix, the syntax is the same, but the memory layouts differ.</p>
</div>
<div class="section" id="arrays-as-images">
<h3><a class="toc-backref" href="#id77">Arrays as Images</a><a class="headerlink" href="#arrays-as-images" title="Permalink to this headline">¶</a></h3>
<p>When the array represents an image, users require the memory layout to be the same as in the image files which store the data (in order to ensure fast I/O). All image formats (JPEG, TIFF, PNG, ...) follow the convention of analog television to scan an image left to right, then top to bottom. Consequently, the horizontal pixels are consecutive in memory, and therefore Fortran (where the first axis changes fastest) must use the syntax <tt class="docutils literal"><span class="pre">f(x,</span> <span class="pre">y)</span></tt>, whereas C (where the last axis changes fastest) must use <tt class="docutils literal"><span class="pre">c[y][x]</span></tt>.</p>
<p>In short: When the array is an image, the memory layout is the same, but the syntax differs.</p>
<p>Thus, we have four basic conventions: FM and CM for matrices, FI and CI for images. The meaning of the terms &#8220;Fortran order&#8221; and &#8220;C order&#8221; depends on whether we are talking about matrices (where they refer to FM and CM, i.e. a difference in memory layout) or images (where they refer to FI and CI, i.e. a difference in index order).</p>
</div>
<div class="section" id="multi-dimensional-arrays">
<h3><a class="toc-backref" href="#id78">Multi-Dimensional Arrays</a><a class="headerlink" href="#multi-dimensional-arrays" title="Permalink to this headline">¶</a></h3>
<p>When we add more dimensions, the confusion increases, because there are no universally accepted memory and indexing conventions. For example, an RGB image can be stored in &#8220;interleaved format&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre>RGB RGB RGB ...
RGB RGB RGB ...
:
:
</pre></div>
</div>
<p>where the color values of each pixel are consecutive in memory, or in &#8220;banded format&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre>R R R ...
R R R ...
:
G G G ...
G G G ...
:
B B B ...
B B B ...
:
</pre></div>
</div>
<p>where we have a separate scalar image for each color. In Fortran, interleaved and banded images must be indexed as <tt class="docutils literal"><span class="pre">f(color,</span> <span class="pre">x,</span> <span class="pre">y)</span></tt> and <tt class="docutils literal"><span class="pre">f(x,</span> <span class="pre">y,</span> <span class="pre">color)</span></tt> respectively, whereas in C we must use <tt class="docutils literal"><span class="pre">c[y][x][color]</span></tt> or <tt class="docutils literal"><span class="pre">c[color][y][x]</span></tt>.</p>
</div>
<div class="section" id="vigra-and-numpy">
<h3><a class="toc-backref" href="#id79">VIGRA and numpy</a><a class="headerlink" href="#vigra-and-numpy" title="Permalink to this headline">¶</a></h3>
<p>From the beginning, VIGRA adopted Fortran conventions, i.e. its default behavior is according to FM and FI (this is possible because VIGRA uses array classes, where the mapping from indices to memory is encapsulated in the appropriate way).</p>
<p>In contrast, numpy adopted C conventions, i.e. its default behavior is CM and CI.</p>
<p>In addition, both packages provide array views which keep the memory layout intact, but change the index order. Thus, VIGRA also supports the CI convention, and numpy also supports FI. Note that changing the index order is only allowed for images. Matrices always use the fixed index order dictated by mathematics where transpose(m) is a well-defined mathematical operation (which just happens to revert the index order). Therefore, the existence of array views does not imply that VIGRA supports CM or numpy supports FM.</p>
<p>However, numpy&#8217;s array constructor provides an argument &#8216;order&#8217; which can take the values &#8216;C&#8217; (default) and &#8216;F&#8217; to construct arrays with C or Fortran memory order. By this mechanism, numpy also supports the FM convention (and thus all four basic possibilities).</p>
<p>But here is the catch: When you get a numpy array view, you have no way to tell which convention it adheres to. It simply doesn&#8217;t contain this information.</p>
<p>The usual solution to this problem is to enforce a fixed axis order in the entire application, but this workaround breaks down when the application must simultaneously handle arrays with different meaning (e.g. sequences &#8216;xyt&#8217; vs. volumes &#8216;xyz&#8217; vs. multi-spectral images &#8216;xyc&#8217;) or when the application uses modules with conflicting requirements (e.g. numpy&#8217;s &#8216;yx&#8217; vs. PyQt&#8217;s &#8216;xy&#8217;).</p>
</div>
<div class="section" id="vigranumpy-axistags">
<h3><a class="toc-backref" href="#id80">Vigranumpy Axistags</a><a class="headerlink" href="#vigranumpy-axistags" title="Permalink to this headline">¶</a></h3>
<p>This is precisely where axistags enter: They attach information to array views that allows the user to figure out which convention applies to a given view. Thus, the primary purpose of axistags is entirely passive - they just keep track of how users manipulate the axis order when creating new array views. The main use case of axistags is therefore to re-adjust the axis order whenever an algorithm has specific order requirements. Using axistags, one can easily ensure that arrays conform to the desired order at the beginning of every algorithm. Consider the following example: Let &#8216;image&#8217; be a scalar 2D image with axistags. Then we can ask for the image&#8217;s width and height independently of the current axis order:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">width</span>  <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">width</span>    <span class="c"># this works for any axis order!</span>
<span class="n">height</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">height</span>
</pre></div>
</div>
<p>Now suppose we want to execute a numpy algorithm which expects the [y, x] ordering. We simply transpose the array before calling the algorithm like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># adjust the axis order</span>
<span class="n">numpy_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transposeToNumpyOrder</span><span class="p">()</span>

<span class="c"># execute the algorithm</span>
<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
        <span class="n">numpy_image</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>   <span class="c"># note the index order</span>
</pre></div>
</div>
<p>When we want to execute a VIGRA algorithm which expects the [x, y] ordering, we do:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># adjust the axis order</span>
<span class="n">vigra_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">transposeToVigraOrder</span><span class="p">()</span>

<span class="c"># execute the algorithm</span>
<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
        <span class="n">vigra_image</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>   <span class="c"># note the index order</span>
</pre></div>
</div>
<p>Notice that the order of the loops (the inner loop runs over x) is the same in both cases: To maximize cache locality and therefore speed, the inner loop should operate on consecutive memory cells. Since image memory order derives from file memory order (where the x-axis is consecutive), and array views can never change the memory order, this loop ordering is always preferable, regardless of the index order.</p>
</div>
<div class="section" id="vigranumpy-conventions">
<h3><a class="toc-backref" href="#id81">Vigranumpy Conventions</a><a class="headerlink" href="#vigranumpy-conventions" title="Permalink to this headline">¶</a></h3>
<p>To handle axis meaning in a well-defined way, vigranumpy adopts the following conventions, which are designed such that The Right Thing (TM) should happen automatically, at least most of the time:</p>
<ol class="arabic">
<li><p class="first">When the array represents a matrix, no axistags are allowed because the index order has a fixed semantic meaning and must not be messed around with. In vigranumpy, this requirement is enforced by an assertion:</p>
<div class="highlight-python"><div class="highlight"><pre>vigra_precondition( !matrix.axistags(), &quot;matrix must not have axistags&quot;);
</pre></div>
</div>
<p>in the C++ gluecode functions. This applies, for example, to the feature matrices passed to a random forest and to unsupervised learning algorithms. If desired, we can introduce additional axistags for features and samples in the future because this is a common use case.</p>
</li>
<li><p class="first">When arrays represent image data with up to five dimensions, axistags should be used. To sort indices according to the requirements of the next algorithm to be executed, the appropriate convenience function should be called (many more convenience functions are documented in <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">vigra.VigraArray</span></tt></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">numpy_array</span>   <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">transposeToNumpyOrder</span><span class="p">()</span>    <span class="c"># gives &#39;yx&#39;, &#39;zyx&#39; etc.</span>
<span class="n">vigra_array</span>   <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">transposeToVigraOrder</span><span class="p">()</span>    <span class="c"># gives &#39;xy&#39;, &#39;xyz&#39; etc.</span>
<span class="n">ilastik_array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">view5D</span><span class="p">()</span>                   <span class="c"># gives &#39;txyzc&#39; (inserts singleton axes if necessary)</span>
<span class="n">user_defined</span>  <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">withAxes</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;t&#39;</span><span class="p">)</span>    <span class="c"># specify order explicitly (inserts singleton axes if necessary)</span>
</pre></div>
</div>
<p>Algorithms with special order requirements can then check for the correct order in an assertion.</p>
</li>
<li><p class="first">The function <tt class="docutils literal"><span class="pre">vigra.taggedView()</span></tt> allows to attach axistags to an array very conveniently. For example, when you know from the context that the axes of a given array are to be interpreted as &#8216;xyzt&#8217; in that order, you can make this knowledge explicit by calling:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tagged_array</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">taggedView</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="s">&#39;xyzt&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">When you call a vigranumpy function that executes a C++ VIGRA function, <tt class="docutils literal"><span class="pre">image.transposeToVigraOrder()</span></tt> will be invoked automatically on the input arrays, and the original axis order will be restored in the output arrays.</p>
</li>
<li><p class="first">When you call a vigranumpy function that is forwarded to a numpy function (in particular, a ufunc like <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">sqrt</span></tt> etc.), <tt class="docutils literal"><span class="pre">image.transposeToNumpyOrder()</span></tt> will be invoked automatically on the input arrays, and the original axis order will be restored in the output arrays.</p>
</li>
<li><p class="first">When vigranumpy writes arrays to a file, it will always order the axes such that the memory order conforms to the established file conventions (e.g. values along the x-axis are consecutive). In particular, when you use <tt class="docutils literal"><span class="pre">vigra.impex.writeHDF5()</span></tt> to create HDF5 datasets, <tt class="docutils literal"><span class="pre">array.transposeToNumpyOrder()</span></tt> will be called before writing the data (this is a consequence of item 5, because <tt class="docutils literal"><span class="pre">writeHDF5()</span></tt> eventually forwards the actual work to h5py). In addition, the axistags (in numpy order) will be stored in a dataset attribute <tt class="docutils literal"><span class="pre">axistags</span></tt>.</p>
</li>
<li><p class="first">When vigranumpy reads data from a file, it preserves the file&#8217;s memory order and attaches the appropriate axistags. In case of images, the axis order follows from the usual file conventions. If you call <tt class="docutils literal"><span class="pre">vigra.impex.readHDF5()</span></tt> to read HDF5, the axistags will be read from the attribute <tt class="docutils literal"><span class="pre">axistags</span></tt> (if present). Upon return, the read functions automatically call <tt class="docutils literal"><span class="pre">array.transposeToVigraOrder()</span></tt>, but this only changes the index order, not the memory layout. This latter convention was adopted to ensure that the default index order is the same in the Python and C++ versions of VIGRA.</p>
</li>
<li><p class="first">When you display an image via <tt class="docutils literal"><span class="pre">image.imshow()</span></tt> or <tt class="docutils literal"><span class="pre">image.show()</span></tt>, the axes are re-ordered automatically such that the image is displayed upright (i.e. x goes to the right, y goes down). If you want to override this (i.e. want to enforce transposed display), you can remove the axistags by calling <tt class="docutils literal"><span class="pre">image.view(numpy.ndarray)</span></tt>.</p>
</li>
</ol>
<p>Item 4. has two important consequences one should be aware of:</p>
<ul class="simple">
<li>When a function needs parameters that depend on the axis order (such as the new shape in <tt class="docutils literal"><span class="pre">vigra.sampling.resize()</span></tt> or axis-dependent sigmas in <tt class="docutils literal"><span class="pre">vigra.filters.gaussianSmoothing()</span></tt>), these parameters must be re-ordered on the C++ side in the same way as the axes. This is achieved by a call to <tt class="docutils literal"><span class="pre">NumpyArray::permuteLikewise()</span></tt> in the C++ gluecode functions.</li>
<li>When a vigranumpy function computes a gradient image, the gradient vector elements will always be stored in the order (dx, dy, dz), regardless of the array&#8217;s original axis ordering. The same applies to any function producing vector-valued elements whose interpretation depends on the axis meaning (e.g. the Hessian matrix and the structure tensor). For example, the output of the Hessian is ordered as (dxx, dxy, dxz, dyy, dyz, dzz).</li>
</ul>
</div>
</div>
<div class="section" id="axistag-reference">
<h2><a class="toc-backref" href="#id82">Axistag Reference</a><a class="headerlink" href="#axistag-reference" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="vigra.AxisType">
<em class="property">class </em><tt class="descclassname">vigra.</tt><tt class="descname">AxisType</tt><a class="headerlink" href="#vigra.AxisType" title="Permalink to this definition">¶</a></dt>
<dd><p>Enum to encode the type of an axis described by an
<a class="reference internal" href="#vigra.AxisInfo" title="vigra.AxisInfo"><tt class="xref py py-class docutils literal"><span class="pre">AxisInfo</span></tt></a> object. Possible values:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">AxisType.Channels:</span></tt></dt>
<dd>a channel axis</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.Space:</span></tt></dt>
<dd>a spatial axis</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.Edge:</span></tt></dt>
<dd>an edge axis</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.Angle:</span></tt></dt>
<dd>an axis encoding angles (e.g. polar coordinates)</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.Time:</span></tt></dt>
<dd>a temporal axis</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.Frequency:</span></tt></dt>
<dd>an axis in the Fourier domain</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.UnknownAxisType:</span></tt></dt>
<dd>type not specified</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.NonChannel:</span></tt></dt>
<dd>any type except Channels</dd>
<dt><tt class="docutils literal"><span class="pre">AxisType.AllAxes:</span></tt></dt>
<dd>any type</dd>
</dl>
</div></blockquote>
<p>Types can be combined by the bitwise &#8216;or&#8217; operator. For example,
<tt class="docutils literal"><span class="pre">Space</span> <span class="pre">|</span> <span class="pre">Frequency</span></tt> denotes a spatial axis in the Fourier domain.</p>
</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="vigra.AxisInfo">
<em class="property">class </em><tt class="descclassname">vigra.</tt><tt class="descname">AxisInfo</tt><a class="headerlink" href="#vigra.AxisInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>An object describing a single axis.</p>
<p>Constructor:</p>
<dl class="method">
<dt id="AxisInfo.AxisInfo">
<tt class="descname">AxisInfo</tt><big>(</big><em>key='?'</em>, <em>typeFlags=AxisType.UnknownAxisType</em>, <em>resolution=0.0</em>, <em>description=''</em><big>)</big><a class="headerlink" href="#AxisInfo.AxisInfo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>string</em>) &#8211; the key of the axis,
e.g. &#8216;x&#8217; (x-axis), &#8216;c&#8217; (channel axis), &#8216;?&#8217; (unknown)</li>
<li><strong>typeFlags</strong> (<a class="reference internal" href="#vigra.AxisType" title="vigra.AxisType"><tt class="xref py py-class docutils literal"><span class="pre">AxisType</span></tt></a>) &#8211; the type of the axis,
e.g. AxisType.Space or AxisType.Time</li>
<li><strong>resolution</strong> &#8211; the resolution (step size) of the axis
(e.g. 0.0 means &#8216;unknown&#8217;)</li>
<li><strong>description</strong> &#8211; an arbitrary string giving additional information 
about the axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>In addition, AxisInfo defines the following factories for the most common
cases:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">AxisInfo.c</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.c(description='a</span> <span class="pre">description')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;c&#8217; (channel) axis.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.x</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.x(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;x&#8217; (spatial) axis.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.y</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.y(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;y&#8217; (spatial) axis.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.z</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.z(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;z&#8217; (spatial) axis.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.z</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.n(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;n&#8217; (spatial) axis.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.e</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.e(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;e&#8217; (edge) axis.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.t</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.t(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;t&#8217; (time) axis.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.fx</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.fx(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;x&#8217; axis
in the Fourier domain.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.fy</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.fy(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;y&#8217; axis
in the Fourier domain.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.fz</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.fz(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;z&#8217; axis
in the Fourier domain.</dd>
<dt><tt class="docutils literal"><span class="pre">AxisInfo.ft</span></tt> or <tt class="docutils literal"><span class="pre">AxisInfo.ft(resolution=0.0,</span> <span class="pre">description='')</span></tt>:</dt>
<dd>Factory for an axisinfo object describing the &#8216;t&#8217; axis
in the Fourier domain.</dd>
</dl>
</div></blockquote>
<dl class="method">
<dt id="vigra.AxisInfo.compatible">
<tt class="descname">compatible</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.compatible" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo1.compatible(axisinfo2) yields True when the two axisinfo objects have the same keys and types, or either of the two is &#8216;unknown&#8217;.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.AxisInfo.description">
<tt class="descname">description</tt><a class="headerlink" href="#vigra.AxisInfo.description" title="Permalink to this definition">¶</a></dt>
<dd><p>(read/write property, type &#8216;string&#8217;) the string description of the axis.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.isAngular">
<tt class="descname">isAngular</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.isAngular" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo.isAngular() yields True when <a class="reference internal" href="#vigra.AxisInfo.typeFlags" title="vigra.AxisInfo.typeFlags"><tt class="xref py py-attr docutils literal"><span class="pre">typeFlags</span></tt></a> contains AxisType.Angle</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.isChannel">
<tt class="descname">isChannel</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.isChannel" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo.isChannel() yields True when <a class="reference internal" href="#vigra.AxisInfo.typeFlags" title="vigra.AxisInfo.typeFlags"><tt class="xref py py-attr docutils literal"><span class="pre">typeFlags</span></tt></a> contains AxisType.Channels</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.isFrequency">
<tt class="descname">isFrequency</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.isFrequency" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo.isFrequency() yields True when <a class="reference internal" href="#vigra.AxisInfo.typeFlags" title="vigra.AxisInfo.typeFlags"><tt class="xref py py-attr docutils literal"><span class="pre">typeFlags</span></tt></a> contains AxisType.Frequency</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.isSpatial">
<tt class="descname">isSpatial</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.isSpatial" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo.isSpactial() yields True when <a class="reference internal" href="#vigra.AxisInfo.typeFlags" title="vigra.AxisInfo.typeFlags"><tt class="xref py py-attr docutils literal"><span class="pre">typeFlags</span></tt></a> contains AxisType.Space</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.isTemporal">
<tt class="descname">isTemporal</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.isTemporal" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo.isTemporal() yields True when <a class="reference internal" href="#vigra.AxisInfo.typeFlags" title="vigra.AxisInfo.typeFlags"><tt class="xref py py-attr docutils literal"><span class="pre">typeFlags</span></tt></a> contains AxisType.Time</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisInfo.isType">
<tt class="descname">isType</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisInfo.isType" title="Permalink to this definition">¶</a></dt>
<dd><p>axisinfo.isType(axistype) yields True when <a class="reference internal" href="#vigra.AxisInfo.typeFlags" title="vigra.AxisInfo.typeFlags"><tt class="xref py py-attr docutils literal"><span class="pre">typeFlags</span></tt></a> contains the given axistype.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.AxisInfo.key">
<tt class="descname">key</tt><a class="headerlink" href="#vigra.AxisInfo.key" title="Permalink to this definition">¶</a></dt>
<dd><p>(read-only property, type &#8216;string&#8217;) the key of the axis.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.AxisInfo.resolution">
<tt class="descname">resolution</tt><a class="headerlink" href="#vigra.AxisInfo.resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>(read/write property, type &#8216;float&#8217;) the resolution of the axis. The resolution
will be automatically adjusted whenever the image size changes, e.g. due to a call
to <a class="reference internal" href="#vigra.sampling.resize" title="vigra.sampling.resize"><tt class="xref py py-func docutils literal"><span class="pre">resize()</span></tt></a> or slicing with non-unit step size:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mf">1.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">axistags</span><span class="p">)</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=1)</span>
<span class="go">AxisInfo: &#39;y&#39; (type: Space, resolution=1.2)</span>
<span class="go">AxisInfo: &#39;c&#39; (type: Channels) RGB</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">axistags</span><span class="p">)</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=2)</span>
<span class="go">AxisInfo: &#39;y&#39; (type: Space, resolution=4.8)</span>
<span class="go">AxisInfo: &#39;c&#39; (type: Channels) RGB</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="vigra.AxisInfo.typeFlags">
<tt class="descname">typeFlags</tt><a class="headerlink" href="#vigra.AxisInfo.typeFlags" title="Permalink to this definition">¶</a></dt>
<dd><p>(read-only property, type <a class="reference internal" href="#vigra.AxisType" title="vigra.AxisType"><tt class="xref py py-class docutils literal"><span class="pre">AxisType</span></tt></a>) the type of the axis .</p>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="vigra.AxisTags">
<em class="property">class </em><tt class="descclassname">vigra.</tt><tt class="descname">AxisTags</tt><a class="headerlink" href="#vigra.AxisTags" title="Permalink to this definition">¶</a></dt>
<dd><p>Object to describe axis properties and axis ordering in a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a>.</p>
<p>Constructor:</p>
<dl class="method">
<dt id="AxisTags.AxisTags">
<tt class="descname">AxisTags</tt><big>(</big><em>i1=None</em>, <em>i2=None</em>, <em>i3=None</em>, <em>i4=None</em>, <em>i5=None</em><big>)</big><a class="headerlink" href="#AxisTags.AxisTags" title="Permalink to this definition">¶</a></dt>
<dd><p>The parameters &#8216;i1&#8217;...&#8217;i5&#8217; are the <a class="reference internal" href="#vigra.AxisInfo" title="vigra.AxisInfo"><tt class="xref py py-class docutils literal"><span class="pre">AxisInfo</span></tt></a> objects
describing the axes. If all are None, an empty AxisTags object is
created. Alternatively, &#8216;i1&#8217; can also be a Python sequence of
<a class="reference internal" href="#vigra.AxisInfo" title="vigra.AxisInfo"><tt class="xref py py-class docutils literal"><span class="pre">AxisInfo</span></tt></a> objects, or an integer (in which case an
AxisTags object with that many &#8216;?&#8217; entries is created).</p>
</dd></dl>

<p>Most AxisTags methods should not be called directly, but via the
corresponding array methods, because this ensures that arrays and
their axistags are always kept in sync (rule of thumb: if an axistags
function is not documented, you call it on your own risk).</p>
<p>The entries of an axistags object (i.e. the individual axisinfo objects)
can be accessed via the index operator, where the argument can either be
the axis index or the axis key:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=1.2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">])</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=1.2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">])</span>
<span class="go">AxisInfo: &#39;x&#39; (type: Space, resolution=2)</span>
</pre></div>
</div>
<dl class="method">
<dt id="vigra.AxisTags.axisTypeCount">
<tt class="descname">axisTypeCount</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisTags.axisTypeCount" title="Permalink to this definition">¶</a></dt>
<dd><p>How many axes of the given type(s) are in this axistags object?:</p>
<div class="highlight-python"><div class="highlight"><pre>axistags.axisTypeCount(types) -&gt; int
</pre></div>
</div>
<p>The &#8216;types&#8217; of the query must be single <a class="reference internal" href="#vigra.AxisType" title="vigra.AxisType"><tt class="xref py py-class docutils literal"><span class="pre">AxisType</span></tt></a> instances
or a combination of them. Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="s">&#39;txyc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axisTypeCount</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">AxisType</span><span class="o">.</span><span class="n">Space</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axisTypeCount</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">AxisType</span><span class="o">.</span><span class="n">Time</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axisTypeCount</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">AxisType</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">AxisType</span><span class="o">.</span><span class="n">Space</span> <span class="o">|</span> <span class="n">vigra</span><span class="o">.</span><span class="n">AxisType</span><span class="o">.</span><span class="n">Time</span><span class="p">))</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">axisTypeCount</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">AxisType</span><span class="o">.</span><span class="n">NonChannel</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="vigra.AxisTags.channelIndex">
<tt class="descname">channelIndex</tt><a class="headerlink" href="#vigra.AxisTags.channelIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>(read-only property, type &#8216;int&#8217;) the index of the channel axis, or <tt class="docutils literal"><span class="pre">len(axistags)</span></tt>
when no channel axis exists (i.e. <tt class="docutils literal"><span class="pre">axistags.channelIndex</span></tt> is similar to
<tt class="docutils literal"><span class="pre">axistags.index('c')</span></tt>, but doesn&#8217;t throw an exception when there
is no &#8216;c&#8217; axis.)</p>
</dd></dl>

<dl class="staticmethod">
<dt id="vigra.AxisTags.fromJSON">
<em class="property">static </em><tt class="descname">fromJSON</tt><big>(</big><em>json_rep</em><big>)</big><a class="headerlink" href="#vigra.AxisTags.fromJSON" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a new AxisTags object from the given JSON representation.
This is mainly used to reconstruct arrays from HDF5 datasets with
a suitable axistags attribute (see <a class="reference internal" href="#vigra.impex.readHDF5" title="vigra.impex.readHDF5"><tt class="xref py py-func docutils literal"><span class="pre">readHDF5()</span></tt></a>).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisTags.index">
<tt class="descname">index</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisTags.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the axis index of a given axis key:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">axistags</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>In this example, the &#8216;x&#8217;-axis corresponds to index 0 (i.e. the first index).</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.AxisTags.innerNonchannelIndex">
<tt class="descname">innerNonchannelIndex</tt><a class="headerlink" href="#vigra.AxisTags.innerNonchannelIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>(read-only property, type &#8216;int&#8217;) the index of the innermost non-channel axis.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisTags.setChannelDescription">
<tt class="descname">setChannelDescription</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisTags.setChannelDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a description for the channel axis, if one exists:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">axistags</span><span class="o">.</span><span class="n">setChannelDescription</span><span class="p">(</span><span class="s">&#39;colors are in Lab color space&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>It is similar to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">axistags</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="s">&#39;colors are in Lab color space&#39;</span>
</pre></div>
</div>
<p>except when the axistags contain no channel axis, in which case
setChannelDescription() is simply ignored, whereas axistags[&#8216;c&#8217;]
would cause an exception.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.AxisTags.toJSON">
<tt class="descname">toJSON</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.AxisTags.toJSON" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a string representation of this axistags in JSON format.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="vigraarray-reference">
<h2><a class="toc-backref" href="#id83">VigraArray Reference</a><a class="headerlink" href="#vigraarray-reference" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="vigra.VigraArray">
<em class="property">class </em><tt class="descclassname">vigra.</tt><tt class="descname">VigraArray</tt><a class="headerlink" href="#vigra.VigraArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt></p>
<p>This class extends numpy.ndarray with the concept of <strong>axistags</strong>
which encode the semantics of the array&#8217;s axes. VigraArray overrides all
numpy.ndarray methods in order to handle axistags in a sensible way.
In particular, operations acting on two arrays simultaneously (e.g.
addition) will first transpose the arguments such that their axis
ordering matches.</p>
<p>Constructor:</p>
<dl class="method">
<dt id="VigraArray.VigraArray">
<tt class="descname">VigraArray</tt><big>(</big><em>obj</em>, <em>dtype=numpy.float32</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#VigraArray.VigraArray" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>obj</strong> &#8211; an array or shape object (see below)</li>
<li><strong>dtype</strong> &#8211; desired element type</li>
<li><strong>order</strong> &#8211; desired memory layout (see below)</li>
<li><strong>init</strong> (<em>boolean</em>) &#8211; True: initialize the image with zeros; False: do not
initialize the image</li>
<li><strong>value</strong> (<em>convertible to dtype</em>) &#8211; initialize the image with this value (overrides init)</li>
<li><strong>axistags</strong> &#8211; the AxisTags object of the new array. The length of
axistags must match the array&#8217;s shape. It axistags=None,
obj.axistags is used if it exists. Otherwise, a new
axistags object is created by a call to
<a class="reference internal" href="#vigra.VigraArray.defaultAxistags" title="vigra.VigraArray.defaultAxistags"><tt class="xref py py-meth docutils literal"><span class="pre">defaultAxistags()</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><strong>obj</strong> may be one of the following</p>
<ul class="simple">
<li>If obj is a numpy.ndarray or a subtype, a copy of obj with the given
dtype, order and resulting class VigraArray is created. If obj.axistags
exists, the new array will have these axistags as well, unless new
axistags are explicitly passed to the constructor.</li>
<li>If obj is a sequence, it is interpreted as a shape.</li>
<li>Otherwise, or if shape and axistags are incompatible, an exception
is raised.</li>
</ul>
<p><strong>order</strong> can be &#8216;C&#8217; (C order), &#8216;F&#8217; (Fortran order), &#8216;V&#8217; (VIGRA
order), &#8216;A&#8217; (any), or None. This parameter controls the order of strides
and axistags (unless axistags are explicit passed into the constructor).
See the <a class="reference internal" href="#array-order-parameter"><em>order definitions</em></a> for details. If
&#8216;order=None&#8217;, the order is determined by <a class="reference internal" href="#VigraArray.defaultOrder" title="VigraArray.defaultOrder"><tt class="xref py py-attr docutils literal"><span class="pre">VigraArray.defaultOrder</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="VigraArray.axistags">
<tt class="descname">axistags</tt><a class="headerlink" href="#VigraArray.axistags" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#vigra.AxisTags" title="vigra.AxisTags"><tt class="xref py py-class docutils literal"><span class="pre">AxisTags</span></tt></a> object of this array.</p>
</dd></dl>

<dl class="attribute">
<dt id="VigraArray.defaultOrder">
<tt class="descname">defaultOrder</tt><a class="headerlink" href="#VigraArray.defaultOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the default axis ordering, currently &#8216;V&#8217; (<a class="reference internal" href="#array-order-parameter"><em>VIGRA order</em></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.T">
<tt class="descname">T</tt><a class="headerlink" href="#vigra.VigraArray.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to self.transpose()</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">array.__getitem__(index)</span></tt> implements the indexing operator <tt class="docutils literal"><span class="pre">array[index]</span></tt>.
In addition to the usual numpy.ndarray indexing functionality, this function
also updates the axistags of the result array. There are three cases:</p>
<blockquote>
<div><ul class="simple">
<li>getitem creates a scalar value =&gt; no axistags are required</li>
<li>getitem creates an array view =&gt; axistags are transferred from the
corresponding axes of the base array</li>
<li>getitem creates a copy of an array (fancy indexing) =&gt; all axistags are &#8216;?&#8217;</li>
</ul>
</div></blockquote>
<p>If the index contains &#8216;numpy.newaxis&#8217;, a new singleton axis is inserted at the
appropriate position, whose axisinfo is set to &#8216;?&#8217; (unknown). If the index contains
&#8216;vigra.newaxis(axisinfo)&#8217;, the singleton axis will get the given axisinfo.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.asRGB">
<tt class="descname">asRGB</tt><big>(</big><em>normalize=True</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.asRGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand a scalar array (i.e. an array with a single channel) into an RGB array with
three identical color channels. This is useful when you want to paste color
annotations (e.g. user labels) into the array.</p>
<p>The parameter <cite>normalize</cite> can be used to normalize the array&#8217;s
value range to 0..255:</p>
<dl class="docutils">
<dt><cite>normalize</cite> = (nmin, nmax):</dt>
<dd>scale &amp; clip array values from nmin..nmax to 0..255</dd>
<dt><cite>normalize</cite> = True: (default)</dt>
<dd>scale the array&#8217;s actual range min()..max() to 0..255</dd>
<dt><cite>normalize</cite> = False:</dt>
<dd>don&#8217;t scale the array&#8217;s values</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.bindAxis">
<tt class="descname">bindAxis</tt><big>(</big><em>which</em>, <em>index=0</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.bindAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind the axis identified by &#8216;which&#8217; to the given &#8216;index&#8217;.
This is similar to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">array</span><span class="p">[:,</span> <span class="n">index</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>but you do not need to know the position of the axis when you use the
axis key (according to axistags). For example, to get the green channel
of an RGBImage, you write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">green</span> <span class="o">=</span> <span class="n">rgb</span><span class="o">.</span><span class="n">bindAxis</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This gives the correct result irrespective of the axis ordering.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.channelIndex">
<tt class="descname">channelIndex</tt><a class="headerlink" href="#vigra.VigraArray.channelIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the channel axis according to the axistags.
For example, when axistags are &#8216;x y c&#8217;, the channel index is 2.
If the axistags contain no channel axis, self.ndim is returned.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.channelIter">
<tt class="descname">channelIter</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.channelIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an iterator over the channels of the array.
In each iteration, you get the array corresponding to a single channel.
If the axistags contain no channel axis, there is only one iteration
which yields the entire array. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">RGBImage</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rgb</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">x y c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="o">=</span> <span class="n">rgb</span><span class="o">.</span><span class="n">channelIter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">x y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">red</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(200, 100)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.channels">
<tt class="descname">channels</tt><a class="headerlink" href="#vigra.VigraArray.channels" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of channels in this array (shape of the &#8216;c&#8217; axis).
If the axistags contain no channel axis, the number of channels is implicitly 1.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.copyValues">
<tt class="descname">copyValues</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.copyValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the values of an array to another one. This is similar to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span>
</pre></div>
</div>
<p>but will first transpose both arrays so that axistags are aligned. If
there is no valid alignment, RuntimeError will be raised.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="vigra.VigraArray.defaultAxistags">
<em class="property">static </em><tt class="descname">defaultAxistags</tt><big>(</big><em>tagSpec</em>, <em>order=None</em>, <em>noChannels=False</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.defaultAxistags" title="Permalink to this definition">¶</a></dt>
<dd><p>Get default axistags for the given specification &#8216;tagSpec&#8217;. TagSpec can be the
number of dimensions of the array (<tt class="docutils literal"><span class="pre">array.ndim</span></tt>, must be &lt;= 5) or a string
containing a sequence of axis keys (only the default keys &#8216;x&#8217;, &#8216;y&#8217;, &#8216;z&#8217;, &#8216;t&#8217;,
and &#8216;c&#8217; are currently supported). The &#8216;order&#8217; parameter determines the axis
ordering, see the <a class="reference internal" href="#array-order-parameter"><em>order definitions</em></a> for details.
If &#8216;noChannels&#8217; is True, there will be no channel axis. Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x y c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">x y z c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">x y z t c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">)</span>
<span class="go">y x c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">noChannels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">x y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">noChannels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">x y z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">noChannels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">x y z t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="s">&#39;xty&#39;</span><span class="p">)</span>
<span class="go">x t y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vigra</span><span class="o">.</span><span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="s">&#39;xty&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;V&#39;</span><span class="p">)</span>
<span class="go">x y t</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.depth">
<tt class="descname">depth</tt><a class="headerlink" href="#vigra.VigraArray.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>The depth of the array (shape of the &#8216;z&#8217; axis).
If the axistags contain no &#8216;z&#8217; axis, RuntimeError will be raised.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.dropChannelAxis">
<tt class="descname">dropChannelAxis</tt><big>(</big><em>ignoreMultiChannel=False</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.dropChannelAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop the channel axis when it is a singleton.
This function is for easy transformation of an array shaped
(width, height, 1) into (width, height). A RuntimeError
is raised when there is more than one channel, unless ignoreMultiChannel=True,
in which case &#8216;self&#8217; is returned.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.duration">
<tt class="descname">duration</tt><a class="headerlink" href="#vigra.VigraArray.duration" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of time steps in the array (shape of the &#8216;t&#8217; axis).
If the axistags contain no &#8216;t&#8217; axis, RuntimeError will be raised.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.height">
<tt class="descname">height</tt><a class="headerlink" href="#vigra.VigraArray.height" title="Permalink to this definition">¶</a></dt>
<dd><p>The height of the array (shape of the &#8216;y&#8217; axis).
If the axistags contain no &#8216;y&#8217; axis, RuntimeError will be raised.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.innerNonchannelIndex">
<tt class="descname">innerNonchannelIndex</tt><a class="headerlink" href="#vigra.VigraArray.innerNonchannelIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the innermost non-channel axis according to the axistags.
The innermost axis is determined by the AxisInfo sorting rules (see
the <a class="reference internal" href="#array-order-parameter"><em>order definitions</em></a> for details).
For example, when axistags are &#8216;x y c&#8217;, the innerNonchannelIndex is 0.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.insertChannelAxis">
<tt class="descname">insertChannelAxis</tt><big>(</big><em>order=None</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.insertChannelAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a singleton channel axis.
This function is for easy transformation of an array shaped
(width, height) into (width, height, 1). The &#8216;order&#8217; parameter
determines the position of the new axis: when order is &#8216;F&#8217;, it
will become the first axis, otherwise it will become the last
one. A RuntimeError is raised when the array already contains a
channel axis.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationFromNormalOrder">
<tt class="descname">permutationFromNormalOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationFromNormalOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose an array that is
in normal (ascending) order into the axis order of this array.
(e.g. &#8216;c x y&#8217; into &#8216;x y c&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationFromNumpyOrder">
<tt class="descname">permutationFromNumpyOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationFromNumpyOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose an array that is
in numpy (descending) order into the axis order of this array.
(e.g.  &#8216;y x c&#8217; into &#8216;x y c&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationFromVigraOrder">
<tt class="descname">permutationFromVigraOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationFromVigraOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose an array that is
in VIGRA order (ascending spatial order, but with the channel
axis at the last position) into the axis order of this array.
(e.g.  &#8216;x y c&#8217; into &#8216;c x y&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationToNormalOrder">
<tt class="descname">permutationToNormalOrder</tt><big>(</big><em>types=vigra.vigranumpycore.AxisType.AllAxes</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationToNormalOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose this array to
normal order (that is, from the current axis order into
ascending order, e.g. &#8216;x y c&#8217; into &#8216;c x y&#8217;).
If &#8216;types&#8217; is not &#8216;AxisType.AllAxes&#8217;, only the axes with the
desired types are considered.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationToNumpyOrder">
<tt class="descname">permutationToNumpyOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationToNumpyOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose this array to
numpy order (that is, from the current axis order into
descending order, e.g. &#8216;x y c&#8217; into &#8216;y x c&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationToOrder">
<tt class="descname">permutationToOrder</tt><big>(</big><em>order</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationToOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose this array into
an array view with the given order (where order can be &#8216;A&#8217;,
&#8216;C&#8217;, &#8216;F&#8217;, &#8216;V&#8217; with the usual meaning).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.permutationToVigraOrder">
<tt class="descname">permutationToVigraOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.permutationToVigraOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the permutation that would transpose this array to
VIGRA order (that is, from the current axis order into
ascending spatial order, but with the channel axis at the
last position, e.g. &#8216;c x y&#8217; into &#8216;x y c&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.qimage">
<tt class="descname">qimage</tt><big>(</big><em>normalize=True</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.qimage" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert this image to a Qt QImage (mainly for display purposes).
The present image must have 1, 2, 3, or 4 channels, and the resulting
QImage will have QImage.Format_Indexed8 iff there was only one
channel and QImage.Format_[A]RGB32 otherwise (with the last of
2/4 channels being used as alpha channel).</p>
<p>The parameter <cite>normalize</cite> can be used to normalize an image&#8217;s
value range to 0..255:</p>
<dl class="docutils">
<dt><cite>normalize</cite> = (nmin, nmax):</dt>
<dd>scale &amp; clip image values from nmin..nmax to 0..255</dd>
<dt><cite>normalize</cite> = nmax:</dt>
<dd>lets nmin default to zero, i.e. scale &amp; clip the range 0..nmax
to 0..255</dd>
<dt><cite>normalize</cite> = True: (default)</dt>
<dd>scale the image&#8217;s actual range min()..max() to 0..255</dd>
<dt><cite>normalize</cite> = False:</dt>
<dd>don&#8217;t scale the image&#8217;s values</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="vigra.VigraArray.receiveSocket">
<em class="property">static </em><tt class="descname">receiveSocket</tt><big>(</big><em>socket</em>, <em>flags=0</em>, <em>copy=True</em>, <em>track=False</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.receiveSocket" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstruct an array that has been transferred via a ZMQ socket by a call to
VigraArray.sendSocket(). This only works when the &#8216;zmq&#8217; module is available.
The meaning of the arguments is described in zmq.Socket.recv().</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.sendSocket">
<tt class="descname">sendSocket</tt><big>(</big><em>socket</em>, <em>flags=0</em>, <em>copy=True</em>, <em>track=False</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.sendSocket" title="Permalink to this definition">¶</a></dt>
<dd><p>Send array and metadata over a ZMQ socket. Only works if the &#8216;zmq&#8217; module is available.
The meaning of the arguments is described in zmq.Socket.send().</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.show">
<tt class="descname">show</tt><big>(</big><em>normalize=True</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Display this image in a vigra.pyqt.ImageWindow.</p>
<p>The channels are intepreted as follows: 1 channel = gray image,
2 channels = gray + alpha, 3 channels = RGB, 4 channels = RGB + alpha.</p>
<p>The parameter <cite>normalize</cite> can be used to normalize an image&#8217;s
value range to 0..255:</p>
<dl class="docutils">
<dt><cite>normalize</cite> = (nmin, nmax):</dt>
<dd>scale &amp; clip image values from nmin..nmax to 0..255</dd>
<dt><cite>normalize</cite> = nmax:</dt>
<dd>lets nmin default to zero, i.e. scale &amp; clip the range 0..nmax
to 0..255</dd>
<dt><cite>normalize</cite> = True: (default)</dt>
<dd>scale the image&#8217;s actual range min()..max() to 0..255</dd>
<dt><cite>normalize</cite> = False:</dt>
<dd>don&#8217;t scale the image&#8217;s values</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.sliceIter">
<tt class="descname">sliceIter</tt><big>(</big><em>key='z'</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.sliceIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an iterator over a single spatial axis of the array.
In each iteration, you get the array corresponding to one coordinate
along the axis given by &#8216;key&#8217;. For example, to iterate along the z-axis
to get all x-y-slices in turn, you write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">volume</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">Volume</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="nb">slice</span> <span class="ow">in</span> <span class="n">volume</span><span class="o">.</span><span class="n">sliceIter</span><span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">processSlice</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.spaceIter">
<tt class="descname">spaceIter</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.spaceIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an iterator over all the spatial coordinates in the array.
In each iteration, you get the value corresponding to a single
coordinate location. If the axistags contain no spatial axes,
there is only one iteration which yields the entire array. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">ScalarImage</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">spaceIter</span><span class="p">():</span>
<span class="go">....    print(p)</span>
<span class="go">0.0</span>
<span class="go">1.0</span>
<span class="go">2.0</span>
<span class="go">3.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.spatialDimensions">
<tt class="descname">spatialDimensions</tt><a class="headerlink" href="#vigra.VigraArray.spatialDimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of spatial axes in the array.
That is, the number of entries in the axistags where the flag &#8216;AxisType.Space&#8217;
is set.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.subarray">
<tt class="descname">subarray</tt><big>(</big><em>p1</em>, <em>p2=None</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.subarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a subarray view from a pair of points. The first point denotes the start
of the subarray (inclusive), the second its end (exclusive). For example,</p>
<blockquote>
<div>a.subarray((1,2,3), (4,5,6))  # equivalent to a[1:4, 2:5, 3:6]</div></blockquote>
<p>The given points must have the same dimension, otherwise an IndexError is raised.
If only one point is given, it refers to the subarray&#8217;s end, and the start is set
to the point (0, 0, ...) with appropriate dimension, for example</p>
<blockquote>
<div>a.subarray((4,5,6))           # equivalent to a[:4, :5, :6]</div></blockquote>
<p>The function transforms the given point pair into a tuple of slices and calls
self.__getitem__() in it. If the points have lower dimension than the array, an
Ellipsis (&#8216;...&#8217;) is implicitly appended to the slicing, so that missing axes
are left unaltered.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.swapaxes">
<tt class="descname">swapaxes</tt><big>(</big><em>axis1</em>, <em>axis2</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a view of the array with <cite>axis1</cite> and <cite>axis2</cite> interchanged.</p>
<p>Refer to <cite>numpy.swapaxes</cite> for full documentation.</p>
<p>numpy.swapaxes : equivalent function</p>
<blockquote>
<div><p>Parameters &#8216;i&#8217; and &#8216;j&#8217; can also be ints (axis positions) or strings (axis keys).</p>
<p>If &#8216;keepsTags&#8217; is False, axistags are swapped like the axes, otherwise they remain
unchanged such that the swapped axes aquire a new meaning.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.timeIter">
<tt class="descname">timeIter</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.timeIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an iterator over the time points of the array.
In each iteration, you get the array corresponding to a single time point.
If the axistags contain no time axis, there is only one iteration
which yields the entire array. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">vigra</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">axistags</span> <span class="o">=</span> <span class="n">AxisTags</span><span class="p">(</span><span class="n">AxisInfo</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">AxisInfo</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">AxisInfo</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timesteps</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_sequence</span> <span class="o">=</span> <span class="n">Image</span><span class="p">((</span><span class="n">timesteps</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">axistags</span><span class="o">=</span><span class="n">axistags</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">step1</span><span class="p">,</span> <span class="n">step2</span> <span class="o">=</span> <span class="n">image_sequence</span><span class="o">.</span><span class="n">timeIter</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.transpose">
<tt class="descname">transpose</tt><big>(</big><em>*axes</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a view of the array with axes transposed.</p>
<p>For a 1-D array, this has no effect. (To change between column and
row vectors, first cast the 1-D array into a matrix object.)
For a 2-D array, this is the usual matrix transpose.
For an n-D array, if axes are given, their order indicates how the
axes are permuted (see Examples). If axes are not provided and
<tt class="docutils literal"><span class="pre">a.shape</span> <span class="pre">=</span> <span class="pre">(i[0],</span> <span class="pre">i[1],</span> <span class="pre">...</span> <span class="pre">i[n-2],</span> <span class="pre">i[n-1])</span></tt>, then
<tt class="docutils literal"><span class="pre">a.transpose().shape</span> <span class="pre">=</span> <span class="pre">(i[n-1],</span> <span class="pre">i[n-2],</span> <span class="pre">...</span> <span class="pre">i[1],</span> <span class="pre">i[0])</span></tt>.</p>
<p>axes : None, tuple of ints, or <cite>n</cite> ints</p>
<blockquote>
<div><ul class="simple">
<li>None or no argument: reverses the order of the axes.</li>
<li>tuple of ints: <cite>i</cite> in the <cite>j</cite>-th place in the tuple means <cite>a</cite>&#8216;s
<cite>i</cite>-th axis becomes <cite>a.transpose()</cite>&#8216;s <cite>j</cite>-th axis.</li>
<li><cite>n</cite> ints: same as an n-tuple of the same ints (this form is
intended simply as a &#8220;convenience&#8221; alternative to the tuple form)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>out <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd>View of <cite>a</cite>, with axes suitably permuted.</dd>
</dl>
<p>ndarray.T : Array property returning the array transposed.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [2, 4]])</span>
</pre></div>
</div>
<blockquote>
<div>An additional keyword parameter &#8216;keepTags&#8217; can be provided (it has to be passed as an explicit
keyword parameter). If it is True, the axistags will remain unchanged such that the transposed
axes aquire a new meaning.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.transposeToDefaultOrder">
<tt class="descname">transposeToDefaultOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.transposeToDefaultOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to self.transposeToOrder(VigraArray.defaultOrder).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.transposeToNormalOrder">
<tt class="descname">transposeToNormalOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.transposeToNormalOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to self.transposeToOrder(&#8216;F&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.transposeToNumpyOrder">
<tt class="descname">transposeToNumpyOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.transposeToNumpyOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to self.transposeToOrder(&#8216;C&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.transposeToOrder">
<tt class="descname">transposeToOrder</tt><big>(</big><em>order</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.transposeToOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a transposed view onto this array according to the given &#8216;order&#8217;.
Possible orders are:</p>
<dl class="docutils">
<dt>&#8216;A&#8217; or &#8216;&#8217; or None:</dt>
<dd>return the array unchanged</dd>
<dt>&#8216;C&#8217;:</dt>
<dd>transpose to descending axis order (e.g. &#8216;z y x c&#8217;)</dd>
<dt>&#8216;F&#8217;:</dt>
<dd>transpose to ascending axis order (e.g. &#8216;c x y z&#8217;)</dd>
<dt>&#8216;V&#8217;:</dt>
<dd>transpose to VIGRA order, i.e. ascending spatial axes, but
the channel axis is last (e.g. &#8216;x y z c&#8217;)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.transposeToVigraOrder">
<tt class="descname">transposeToVigraOrder</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.VigraArray.transposeToVigraOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to self.transposeToOrder(&#8216;V&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.view5D">
<tt class="descname">view5D</tt><big>(</big><em>order='C'</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.view5D" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a 5-dimensional view containing the standard tags
&#8216;x&#8217;, &#8216;y&#8217;, &#8216;z&#8217;, &#8216;t&#8217;, &#8216;c&#8217; in the desired &#8216;order&#8217; (which can be
&#8216;C&#8217;, &#8216;F&#8217;, and &#8216;V&#8217; with the usual meaning). If &#8216;self&#8217; has an
axis key that is not among the five admissible keys, an
exception is raised. Axes missing in &#8216;self&#8217; are added as
singleton axes with the appropriate tags.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.VigraArray.width">
<tt class="descname">width</tt><a class="headerlink" href="#vigra.VigraArray.width" title="Permalink to this definition">¶</a></dt>
<dd><p>The width of the array (shape of the &#8216;x&#8217; axis).
If the axistags contain no &#8216;x&#8217; axis, RuntimeError will be raised.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.withAxes">
<tt class="descname">withAxes</tt><big>(</big><em>*axistags</em>, <em>**kw</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.withAxes" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates a view whose axistags are standardized in a
desired way. The standardization can be specified in two forms:</p>
<ol class="arabic">
<li><p class="first">Provide <tt class="docutils literal"><span class="pre">axistags</span></tt> explicitly in any format understood by
<tt class="xref py py-func docutils literal"><span class="pre">vigra.makeAxistags()</span></tt>. The original axistags are then
transposed into the given order. When the original array contains
axes not listed in the new specification, these axes are dropped
if they are singletons (otherwise, an exception is raised).
If requested axes is not present in the original array,
singleton axes are inserted at the appropriate positions, provided
the axis keys are among the predefined standard keys (&#8216;x&#8217;, &#8216;y&#8217;, &#8216;z&#8217;,
&#8216;t&#8217;, &#8216;c&#8217;, &#8216;n&#8217;, &#8216;e&#8217;, &#8216;fx&#8217;, &#8216;fy&#8217;, &#8216;fz&#8217;, &#8216;ft&#8217;). The function fails if
the original array contains axes of unknown type (key &#8216;?&#8217;):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">array</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">x y c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 50, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">withAxes</span><span class="p">(</span><span class="s">&#39;tzyx&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">t z y x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 1, 50, 100)</span>
</pre></div>
</div>
</li>
<li><p class="first">Provide keyword arguments <tt class="docutils literal"><span class="pre">order</span></tt> and (optionally) <tt class="docutils literal"><span class="pre">noChannels</span></tt>.
The array is then transposed into the desired order (&#8216;C&#8217;, &#8216;F&#8217;, or &#8216;V&#8217;).
If <tt class="docutils literal"><span class="pre">noChannels=True</span></tt>, the channel axis is dropped if it is a
singleton, otherwise an exception is raised:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">array</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">x y c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 50, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">withAxes</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">c x y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 100, 50)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">withAxes</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">noChannels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span><span class="o">.</span><span class="n">axistags</span>
<span class="go">y x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(50, 100)</span>
</pre></div>
</div>
</li>
</ol>
<p>The parameters <tt class="docutils literal"><span class="pre">axistags</span></tt> and <tt class="docutils literal"><span class="pre">order</span></tt> cannot be specified simultaneously.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.writeHDF5">
<tt class="descname">writeHDF5</tt><big>(</big><em>filenameOurGroup</em>, <em>pathInFile</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.writeHDF5" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the array to a HDF5 file.
This is just a shortcut for <a class="reference internal" href="#vigra.impex.writeHDF5" title="vigra.impex.writeHDF5"><tt class="xref py py-func docutils literal"><span class="pre">vigra.impex.writeHDF5()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.writeImage">
<tt class="descname">writeImage</tt><big>(</big><em>filename</em>, <em>dtype=''</em>, <em>compression=''</em>, <em>mode='w'</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.writeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an image to a file.
Consult <a class="reference internal" href="#vigra.impex.writeImage" title="vigra.impex.writeImage"><tt class="xref py py-func docutils literal"><span class="pre">vigra.impex.writeImage()</span></tt></a> for detailed documentation</p>
</dd></dl>

<dl class="method">
<dt id="vigra.VigraArray.writeSlices">
<tt class="descname">writeSlices</tt><big>(</big><em>filename_base</em>, <em>filename_ext</em>, <em>dtype=''</em>, <em>compression=''</em><big>)</big><a class="headerlink" href="#vigra.VigraArray.writeSlices" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a volume to a sequence of files.
Consult <a class="reference internal" href="#vigra.impex.writeVolume" title="vigra.impex.writeVolume"><tt class="xref py py-func docutils literal"><span class="pre">vigra.impex.writeVolume()</span></tt></a> for detailed documentation.</p>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="vigra.newaxis">
<tt class="descclassname">vigra.</tt><tt class="descname">newaxis</tt><big>(</big><em>axisinfo=vigra.AxisInfo()</em><big>)</big><a class="headerlink" href="#vigra.newaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new singleton axis via the indexing operator. This works similar to
<cite>numpy.newaxis</cite>, but allows to provide an AxisInfo object for the new axis.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">ScalarImage</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">axistags</span>  <span class="c"># no channel axis</span>
<span class="go">x y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">axistags</span>  <span class="c"># with unknown axis type</span>
<span class="go">x y ?</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">vigra</span><span class="o">.</span><span class="n">newaxis</span><span class="p">(</span><span class="n">vigra</span><span class="o">.</span><span class="n">AxisInfo</span><span class="o">.</span><span class="n">c</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">axistags</span>  <span class="c"># with channel axis</span>
<span class="go">x y c</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="vigra.taggedView">
<tt class="descclassname">vigra.</tt><tt class="descname">taggedView</tt><big>(</big><em>array</em>, <em>axistags=''</em>, <em>force=False</em>, <em>order=None</em>, <em>noChannels=False</em><big>)</big><a class="headerlink" href="#vigra.taggedView" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a view to the given array with type <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> and
desired axistags.</p>
<p>You can either explicitly provide axistags to be imposed on the array
(parameter <tt class="docutils literal"><span class="pre">axistags</span></tt>), or a general description for the desired axis
ordering (parameters <tt class="docutils literal"><span class="pre">order</span></tt> and <tt class="docutils literal"><span class="pre">noChannels</span></tt>). It is an error to
specify axistags and order simultaneously. In addition, the effect of
<tt class="docutils literal"><span class="pre">taggedView()</span></tt> depends on whether <tt class="docutils literal"><span class="pre">array</span></tt> already has axistags or not.</p>
<ol class="arabic">
<li><p class="first">If <tt class="docutils literal"><span class="pre">array</span></tt> has no axistags or <tt class="docutils literal"><span class="pre">force=True</span></tt> (i.e. existing axistags
shall be ignored) and neither the <tt class="docutils literal"><span class="pre">axistags</span></tt> nor the <tt class="docutils literal"><span class="pre">order</span></tt> parameters
are given, the function acts as if <tt class="docutils literal"><span class="pre">order=&quot;C&quot;</span></tt> was specified (case 2 below).</p>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">array</span></tt> has no axistags or <tt class="docutils literal"><span class="pre">force=True</span></tt> (i.e. existing axistags
shall be ignored) and the <tt class="docutils literal"><span class="pre">order</span></tt> parameter is given, the function
constructs appropriate axistags via <a class="reference internal" href="#vigra.VigraArray.defaultAxistags" title="vigra.VigraArray.defaultAxistags"><tt class="xref py py-meth docutils literal"><span class="pre">defaultAxistags()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">view</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">VigraArray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span><span class="o">.</span><span class="n">axistags</span> <span class="o">=</span> <span class="n">VigraArray</span><span class="o">.</span><span class="n">defaultAxistags</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">noChannels</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">array</span></tt> has no axistags (or <tt class="docutils literal"><span class="pre">force=True</span></tt>) and the <tt class="docutils literal"><span class="pre">axistags</span></tt> parameter
is given, the function transforms this specification into an object of type
<a class="reference internal" href="#vigra.AxisTags" title="vigra.AxisTags"><tt class="xref py py-class docutils literal"><span class="pre">AxisTags</span></tt></a> and attaches the result to the view:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">view</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">VigraArray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">view</span><span class="o">.</span><span class="n">axistags</span> <span class="o">=</span> <span class="n">makeAxistags</span><span class="p">(</span><span class="n">axistags</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">array</span></tt> has axistags (and <tt class="docutils literal"><span class="pre">force=False</span></tt>) and the <tt class="docutils literal"><span class="pre">order</span></tt> parameter is
given, the function transposes the array into the desired order:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">view</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">transposeToOrder</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">noChannels</span><span class="p">:</span>
</pre></div>
</div>
<p>...     view = view.dropChannelAxis()</p>
</li>
<li><p class="first">If <tt class="docutils literal"><span class="pre">array</span></tt> has axistags (and <tt class="docutils literal"><span class="pre">force=False</span></tt>) and the <tt class="docutils literal"><span class="pre">axistags</span></tt> parameter
is given, the function calls <a class="reference internal" href="#vigra.VigraArray.withAxes" title="vigra.VigraArray.withAxes"><tt class="xref py py-meth docutils literal"><span class="pre">withAxes()</span></tt></a> to transforms
the present axistags into the desired ones:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">view</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">withAxes</span><span class="p">(</span><span class="n">axistags</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
<p>The function raises a RuntimeError when the axistag specification is incompatible
with the array.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.dropChannelAxis">
<tt class="descclassname">vigra.</tt><tt class="descname">dropChannelAxis</tt><big>(</big><em>array</em><big>)</big><a class="headerlink" href="#vigra.dropChannelAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the view created by <tt class="docutils literal"><span class="pre">array.</span></tt><a class="reference internal" href="#vigra.VigraArray.dropChannelAxis" title="vigra.VigraArray.dropChannelAxis"><tt class="xref py py-meth docutils literal"><span class="pre">dropChannelAxis()</span></tt></a> if
the given array supports that function, or return <tt class="docutils literal"><span class="pre">array</span></tt> unchanged otherwise.</p>
</dd></dl>

<hr class="docutils" />
<span class="target" id="subsec-array-factories"></span><dl class="function">
<dt id="vigra.Image">
<tt class="descclassname">vigra.</tt><tt class="descname">Image</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing an image (i.e. an array with
two spatial axes &#8216;x&#8217; and &#8216;y&#8217; and optionally a channel axis &#8216;c&#8217;).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are not image-like.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.ScalarImage">
<tt class="descclassname">vigra.</tt><tt class="descname">ScalarImage</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.ScalarImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a single-band image (i.e. an
array with two spatial axes &#8216;x&#8217; and &#8216;y&#8217; and no channel axis).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a single-band image.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector2Image">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector2Image</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector2Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 2-band image (i.e. an
array with two spatial axes &#8216;x&#8217; and &#8216;y&#8217; and channel axis &#8216;c&#8217; with 2 channels).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 2-band image.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector3Image">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector3Image</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector3Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 3-band image (i.e. an
array with two spatial axes &#8216;x&#8217; and &#8216;y&#8217; and channel axis &#8216;c&#8217; with 3 channels).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 3-band image.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector4Image">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector4Image</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector4Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 4-band image (i.e. an
array with two spatial axes &#8216;x&#8217; and &#8216;y&#8217; and channel axis &#8216;c&#8217; with 4 channels).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 4-band image.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.RGBImage">
<tt class="descclassname">vigra.</tt><tt class="descname">RGBImage</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.RGBImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a RGB image (i.e. an
array with two spatial axes &#8216;x&#8217; and &#8216;y&#8217; and channel axis &#8216;c&#8217; with 3 channels).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for an RGB image.</p>
</dd></dl>

<hr class="docutils" />
<dl class="function">
<dt id="vigra.Volume">
<tt class="descclassname">vigra.</tt><tt class="descname">Volume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a volume (i.e. an array with
three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and optionally a channel axis &#8216;c&#8217;).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are not volume-like.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.ScalarVolume">
<tt class="descclassname">vigra.</tt><tt class="descname">ScalarVolume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.ScalarVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a single-band volume (i.e. an
array with three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and no channel axis).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a single-band volume.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector2Volume">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector2Volume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector2Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 2-band volume (i.e. an
array with three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and channel axis &#8216;c&#8217; with 2 channels).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 2-band volume.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector3Volume">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector3Volume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector3Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 3-band volume (i.e. an
array with three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and channel axis &#8216;c&#8217; with 3 channels).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 3-band volume.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector4Volume">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector4Volume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector4Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 4-band volume (i.e. an
array with three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and channel axis &#8216;c&#8217; with 4 channels).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 4-band volume.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.Vector6Volume">
<tt class="descclassname">vigra.</tt><tt class="descname">Vector6Volume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.Vector6Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing a 6-band volume (i.e. an
array with three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and channel axis &#8216;c&#8217; with 6 channels).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for a 6-band volume.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.RGBVolume">
<tt class="descclassname">vigra.</tt><tt class="descname">RGBVolume</tt><big>(</big><em>obj</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>order=None</em>, <em>init=True</em>, <em>value=None</em>, <em>axistags=None</em><big>)</big><a class="headerlink" href="#vigra.RGBVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory function for a <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> representing an RGB volume (i.e. an
array with three spatial axes &#8216;x&#8217;, &#8216;y&#8217; and &#8216;z&#8217; and channel axis &#8216;c&#8217; with 3 channels).
Paramters are interpreted as in the VigraArray constructor, but an exception
will be raised if the shape or axistags are unsuitable for an RGB volume.</p>
</dd></dl>

</div>
<div class="section" id="chunked-arrays-and-data-bigger-than-ram">
<h2><a class="toc-backref" href="#id84">Chunked Arrays and Data Bigger than RAM</a><a class="headerlink" href="#chunked-arrays-and-data-bigger-than-ram" title="Permalink to this headline">¶</a></h2>
<p>Chunked arrays allow to allocate big data lazily, i.e. one chunk (rectangular block)
at a time. Chunks which are currently not needed can be compressed or written
to disk in order to free memory. This effectively allows VIGRA to work on data bigger
than RAM.</p>
<div class="section" id="classes">
<h3><a class="toc-backref" href="#id85">Classes</a><a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="vigra.vigranumpycore.ChunkedArrayBase">
<em class="property">class </em><tt class="descclassname">vigra.vigranumpycore.</tt><tt class="descname">ChunkedArrayBase</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for chunked arrays, can only be created via factory functions
like <a class="reference internal" href="#vigra.ChunkedArrayCompressed" title="vigra.ChunkedArrayCompressed"><tt class="xref py py-func docutils literal"><span class="pre">ChunkedArrayCompressed()</span></tt></a> or <a class="reference internal" href="#vigra.ChunkedArrayHDF5" title="vigra.ChunkedArrayHDF5"><tt class="xref py py-func docutils literal"><span class="pre">ChunkedArrayHDF5()</span></tt></a>.</p>
<p>Raises an exception
This class cannot be instantiated from Python</p>
<dl class="method">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Read data from a chunked array with the usual index or slicing syntax:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">value</span> <span class="o">=</span> <span class="n">chunked_array</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
<span class="n">roi</span>   <span class="o">=</span> <span class="n">chunked_array</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">19</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that the roi is not a slice view of the original array
(as in numpy.ndarray), but a copy of the data.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises an exception
This class cannot be instantiated from Python</p>
</dd></dl>

<dl class="method">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.__setitem__">
<tt class="descname">__setitem__</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data to a chunked array with the usual index or slicing syntax:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">chunked_array</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="n">chunked_array</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="n">roi</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.backend">
<tt class="descname">backend</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.backend" title="Permalink to this definition">¶</a></dt>
<dd><p>the backend driver of this array.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.cache_max_size">
<tt class="descname">cache_max_size</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.cache_max_size" title="Permalink to this definition">¶</a></dt>
<dd><p>get/set the size of the chunk cache.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.checkoutSubarray">
<tt class="descname">checkoutSubarray</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.checkoutSubarray" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>checkoutSubarray(start, stop, res=None) =&gt; array</div></blockquote>
<p>Obtain a copy of the subarray in the ROI &#8216;[start, stop)&#8217;.
If &#8216;res&#8217; is given, it must have matching shape and will be used
to store the data instead of allocating new storage for &#8216;array&#8217;.</p>
<p>The index operator provides a shorthand for this function, e.g.
for a 2-dimensional array you can equivalently write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">roi</span> <span class="o">=</span> <span class="n">chunked_array</span><span class="o">.</span><span class="n">checkoutSubarray</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">19</span><span class="p">))</span>
<span class="n">roi</span> <span class="o">=</span> <span class="n">chunked_array</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">19</span><span class="p">]</span>
</pre></div>
</div>
<p>to read the ROI from &#8216;start=(5,10)&#8217; to &#8216;stop=(12,19)&#8217; (exclusive).
Note that &#8216;roi&#8217; is a copy, so overwriting it has no effect on the
chunked array. Use &#8216;commitSubarray()&#8217; to overwrite data.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.chunk_array_shape">
<tt class="descname">chunk_array_shape</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.chunk_array_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>shape of internal array of chunks.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.chunk_shape">
<tt class="descname">chunk_shape</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.chunk_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>shape of (interior) chunks.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.commitSubarray">
<tt class="descname">commitSubarray</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.commitSubarray" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>commitSubarray(start, array)</div></blockquote>
<p>Write the given &#8216;array&#8217; at offset &#8216;start&#8217;.
The index operator provides a shorthand for this function, e.g.
for a 2-dimensional array you can equivalently write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">chunked_array</span><span class="o">.</span><span class="n">commitSubarray</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">roi</span><span class="p">)</span>
<span class="n">chunked_array</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="n">roi</span>
</pre></div>
</div>
<p>to write an ROI with shape (5,7) starting at &#8216;start=(5,10)&#8217;.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.data_bytes">
<tt class="descname">data_bytes</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.data_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>size of the currently allocated part of the data.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.data_bytes_per_chunk">
<tt class="descname">data_bytes_per_chunk</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.data_bytes_per_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>size of the data of a single chunk.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>the array&#8217;s value type</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.ndim">
<tt class="descname">ndim</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>the array&#8217;s dimension</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.overhead_bytes">
<tt class="descname">overhead_bytes</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.overhead_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>size of the overhead caused by chunked storage.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.overhead_bytes_per_chunk">
<tt class="descname">overhead_bytes_per_chunk</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.overhead_bytes_per_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>size of the overhead caused by chunked storage for a single chunk.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.read_only">
<tt class="descname">read_only</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.read_only" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;True&#8217; if array values cannot be changed.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.releaseChunks">
<tt class="descname">releaseChunks</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.releaseChunks" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>releaseChunks(start, stop, destroy=False)</div></blockquote>
<p>release or destroy all chunks that are completely contained in [start, stop).</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>shape of the array.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayBase.size">
<tt class="descname">size</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayBase.size" title="Permalink to this definition">¶</a></dt>
<dd><p>number of elements of the array.</p>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="vigra.vigranumpycore.ChunkedArrayHDF5Base">
<em class="property">class </em><tt class="descclassname">vigra.vigranumpycore.</tt><tt class="descname">ChunkedArrayHDF5Base</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayHDF5Base" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#vigra.vigranumpycore.ChunkedArrayBase" title="vigra.vigranumpycore.ChunkedArrayBase"><tt class="xref py py-class docutils literal"><span class="pre">vigra.vigranumpycore.ChunkedArrayBase</span></tt></a></p>
<p>Base class for HDF5-based chunked arrays, can only be created via
the factory function <a class="reference internal" href="#vigra.ChunkedArrayHDF5" title="vigra.ChunkedArrayHDF5"><tt class="xref py py-func docutils literal"><span class="pre">ChunkedArrayHDF5()</span></tt></a>.</p>
<p>Raises an exception
This class cannot be instantiated from Python</p>
<dl class="method">
<dt id="vigra.vigranumpycore.ChunkedArrayHDF5Base.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayHDF5Base.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush data to disk and close the underlying HDF5 file.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayHDF5Base.dataset_name">
<tt class="descname">dataset_name</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayHDF5Base.dataset_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the dataset backend of this array.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayHDF5Base.filename">
<tt class="descname">filename</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayHDF5Base.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the file backend of this array.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.vigranumpycore.ChunkedArrayHDF5Base.flush">
<tt class="descname">flush</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayHDF5Base.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush data to disk.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.vigranumpycore.ChunkedArrayHDF5Base.readonly">
<tt class="descname">readonly</tt><a class="headerlink" href="#vigra.vigranumpycore.ChunkedArrayHDF5Base.readonly" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this array is read-only.</p>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="vigra.Compression">
<em class="property">class </em><tt class="descclassname">vigra.</tt><tt class="descname">Compression</tt><a class="headerlink" href="#vigra.Compression" title="Permalink to this definition">¶</a></dt>
<dd><p>Enum to encode the type of compression for
<a class="reference internal" href="#vigra.ChunkedArrayCompressed" title="vigra.ChunkedArrayCompressed"><tt class="xref py py-func docutils literal"><span class="pre">ChunkedArrayCompressed()</span></tt></a> and <a class="reference internal" href="#vigra.ChunkedArrayHDF5" title="vigra.ChunkedArrayHDF5"><tt class="xref py py-func docutils literal"><span class="pre">ChunkedArrayHDF5()</span></tt></a>:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Compression.ZLIB:</span></tt></dt>
<dd>ZLIB default compression</dd>
<dt><tt class="docutils literal"><span class="pre">Compression.ZLIB_NONE:</span></tt></dt>
<dd>ZLIB no compression (level = 0)</dd>
<dt><tt class="docutils literal"><span class="pre">Compression.ZLIB_FAST:</span></tt></dt>
<dd>ZLIB fast compression (level = 1)</dd>
<dt><tt class="docutils literal"><span class="pre">Compression.ZLIB_BEST:</span></tt></dt>
<dd>ZLIB best compression (level = 9)</dd>
<dt><tt class="docutils literal"><span class="pre">Compression.LZ4:</span></tt></dt>
<dd>LZ4 compression (very fast)</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="vigra.HDF5Mode">
<em class="property">class </em><tt class="descclassname">vigra.</tt><tt class="descname">HDF5Mode</tt><a class="headerlink" href="#vigra.HDF5Mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Enum to encode open mode for <a class="reference internal" href="#vigra.ChunkedArrayHDF5" title="vigra.ChunkedArrayHDF5"><tt class="xref py py-func docutils literal"><span class="pre">ChunkedArrayHDF5()</span></tt></a>:</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">HDF5Mode.Default:</span></tt></dt>
<dd>Use the default strategy (ReadOnly when file and dataset exist, New otherwise)</dd>
<dt><tt class="docutils literal"><span class="pre">HDF5Mode.New:</span></tt></dt>
<dd>Create new file (existing file will be deleted)</dd>
<dt><tt class="docutils literal"><span class="pre">HDF5Mode.ReadWrite:</span></tt></dt>
<dd><dl class="first last docutils">
<dt>Open file (create when not existing) and allow creation of new datasets.</dt>
<dd>Contents of existing datasets may be changed, but not their shape.</dd>
</dl>
</dd>
<dt><tt class="docutils literal"><span class="pre">HDF5Mode.ReadOnly:</span></tt></dt>
<dd>Open files and datasets read-only, fail when not existing.</dd>
<dt><tt class="docutils literal"><span class="pre">HDF5Mode.Replace:</span></tt></dt>
<dd>Like ReadWrite, but always replace exising datasets.</dd>
</dl>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="factory-functions">
<h3><a class="toc-backref" href="#id86">Factory Functions</a><a class="headerlink" href="#factory-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="vigra.ChunkedArrayHDF5">
<tt class="descclassname">vigra.</tt><tt class="descname">ChunkedArrayHDF5</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.ChunkedArrayHDF5" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a chunked array (type <a class="reference internal" href="#vigra.vigranumpycore.ChunkedArrayHDF5Base" title="vigra.vigranumpycore.ChunkedArrayHDF5Base"><tt class="xref py py-class docutils literal"><span class="pre">ChunkedArrayHDF5Base</span></tt></a>)
backed by a HDF5 file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ChunkedArrayHDF5</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">dataset_name</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">mode</span><span class="o">=</span><span class="n">HDF5Mode</span><span class="o">.</span><span class="n">Default</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">Compression</span><span class="o">.</span><span class="n">ZLIB_FAST</span><span class="p">,</span> 
                 <span class="n">chunk_shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cache_max</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axistags</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameters &#8216;shape&#8217;, &#8216;dtype&#8217;, &#8216;compression&#8217;, &#8216;chunk_shape&#8217;, &#8216;fill_value&#8217;, and
&#8216;axistags&#8217; may only be provided when a new dataset is created.</p>
<p>&#8216;file&#8217; can be either a file name or a file ID as returned by <tt class="docutils literal"><span class="pre">h5py.File.id.id</span></tt>.</p>
<p>&#8216;shape&#8217; can be up to 5-dimensional.</p>
<p>&#8216;chunk_shape&#8217; must have the same dimension as &#8216;shape&#8217;, and its elements must
be powers of 2.</p>
<p>&#8216;dtype&#8217; can currently be <tt class="docutils literal"><span class="pre">uint8</span></tt>, <tt class="docutils literal"><span class="pre">uint32</span></tt>, and <tt class="docutils literal"><span class="pre">float32</span></tt>.</p>
<p>&#8216;fill_value&#8217; is returned for all array elements that have never been written.</p>
<p>&#8216;compression&#8217; can be any of the flags defined in the <a class="reference internal" href="#vigra.Compression" title="vigra.Compression"><tt class="xref py py-class docutils literal"><span class="pre">Compression</span></tt></a> enum
except for <cite>LZ4</cite>.</p>
<p>&#8216;cache_max&#8217; specifies how many chunks may reside in memory at the same time.
If it is &#8216;-1&#8217;, vigra will choose a sensible default, but other values may
better fit your data access patterns. This is a soft limit, i.e. may be exceeded
temporarily if more chunks are needed simultaneously in a single operation.</p>
<p>&#8216;mode&#8217; defines the access rights to the file and may be any of the flags defined
in the <a class="reference internal" href="#vigra.HDF5Mode" title="vigra.HDF5Mode"><tt class="xref py py-class docutils literal"><span class="pre">HDF5Mode</span></tt></a> enum. By default, you get read permission for an existing
dataset and read/write permission for a new dataset.</p>
<p>For more details see <a class="reference external" href="../../doc/vigra/classvigra_1_1ChunkedArray.html">ChunkedArray</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.ChunkedArrayLazy">
<tt class="descclassname">vigra.</tt><tt class="descname">ChunkedArrayLazy</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.ChunkedArrayLazy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a chunked array (type <a class="reference internal" href="#vigra.vigranumpycore.ChunkedArrayBase" title="vigra.vigranumpycore.ChunkedArrayBase"><tt class="xref py py-class docutils literal"><span class="pre">ChunkedArrayBase</span></tt></a>)
backed by one plain array for each chunk (rectangular data block):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ChunkedArrayLazy</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">,</span> <span class="n">chunk_shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axistags</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>The individual chunks are allocated lazily upon first write. Reads before the
first write will simply return the &#8216;fill_value&#8217; without allocating memory.
All allocated chunks reside in memory.</p>
<p>&#8216;shape&#8217; can be up to 5-dimensional.</p>
<p>&#8216;chunk_shape&#8217; must have the same dimension as &#8216;shape&#8217;, and its elements must
be powers of 2.</p>
<p>&#8216;dtype&#8217; can currently be <tt class="docutils literal"><span class="pre">uint8</span></tt>, <tt class="docutils literal"><span class="pre">uint32</span></tt>, and <tt class="docutils literal"><span class="pre">float32</span></tt>.</p>
<p>&#8216;fill_value&#8217; is returned for all array elements that have never been written.</p>
<p>For more details see <a class="reference external" href="../../doc/vigra/classvigra_1_1ChunkedArray.html">ChunkedArray</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.ChunkedArrayCompressed">
<tt class="descclassname">vigra.</tt><tt class="descname">ChunkedArrayCompressed</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.ChunkedArrayCompressed" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a chunked array (type <a class="reference internal" href="#vigra.vigranumpycore.ChunkedArrayBase" title="vigra.vigranumpycore.ChunkedArrayBase"><tt class="xref py py-class docutils literal"><span class="pre">ChunkedArrayBase</span></tt></a>)
backed by one plain array for each chunk (rectangular data block):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ChunkedArrayCompressed</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">LZ4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">,</span> <span class="n">chunk_shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                       <span class="n">cache_max</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axistags</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>The individual chunks are allocated lazily upon first write. Reads before the
first write will simply return the &#8216;fill_value&#8217; without allocating memory.
All allocated chunks reside in memory, but may be compressed when not in use.
This is especially beneficial for highly compressible data like label images.</p>
<p>&#8216;shape&#8217; can be up to 5-dimensional.</p>
<p>&#8216;chunk_shape&#8217; must have the same dimension as &#8216;shape&#8217;, and its elements must
be powers of 2.</p>
<p>&#8216;dtype&#8217; can currently be <tt class="docutils literal"><span class="pre">uint8</span></tt>, <tt class="docutils literal"><span class="pre">uint32</span></tt>, and <tt class="docutils literal"><span class="pre">float32</span></tt>.</p>
<p>&#8216;fill_value&#8217; is returned for all array elements that have never been written.</p>
<p>&#8216;compression&#8217; can be any of the flags defined in the <a class="reference internal" href="#vigra.Compression" title="vigra.Compression"><tt class="xref py py-class docutils literal"><span class="pre">Compression</span></tt></a> enum.</p>
<p>&#8216;cache_max&#8217; specifies how many uncompressed chunks may reside in memory at the
same time. If it is &#8216;-1&#8217;, vigra will choose a sensible default, but other values
may better fit your data access patterns. This is a soft limit, i.e. may be
exceeded temporarily if more chunks are needed simultaneously in a single
operation.</p>
<p>For more details see <a class="reference external" href="../../doc/vigra/classvigra_1_1ChunkedArray.html">ChunkedArray</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.ChunkedArrayTmpFile">
<tt class="descclassname">vigra.</tt><tt class="descname">ChunkedArrayTmpFile</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.ChunkedArrayTmpFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a chunked array (type <a class="reference internal" href="#vigra.vigranumpycore.ChunkedArrayBase" title="vigra.vigranumpycore.ChunkedArrayBase"><tt class="xref py py-class docutils literal"><span class="pre">ChunkedArrayBase</span></tt></a>)
backed by a temporary file:</p>
<div class="highlight-python"><div class="highlight"><pre>ChunkedArrayTmpFile(shape, dtype=float32, chunk_shape=None, cache_max=-1,
                    path=, fill_value=0, axistags=None)
</pre></div>
</div>
<p>The individual chunks are allocated lazily upon first write. Reads before the
first write will simply return the &#8216;fill_value&#8217; without allocating memory.
Unused chunks will be moved to the file to free their memory. The file is
automatically deleted when the object is deleted. Use <a class="reference internal" href="#vigra.ChunkedArrayHDF5" title="vigra.ChunkedArrayHDF5"><tt class="xref py py-func docutils literal"><span class="pre">ChunkedArrayHDF5()</span></tt></a> if
you need persistent storage.</p>
<p>&#8216;shape&#8217; can be up to 5-dimensional.</p>
<p>&#8216;chunk_shape&#8217; must have the same dimension as &#8216;shape&#8217;, and its elements must
be powers of 2.</p>
<p>&#8216;dtype&#8217; can currently be <tt class="docutils literal"><span class="pre">uint8</span></tt>, <tt class="docutils literal"><span class="pre">uint32</span></tt>, and <tt class="docutils literal"><span class="pre">float32</span></tt>.</p>
<p>&#8216;cache_max&#8217; specifies how many uncompressed chunks may reside in memory at the
same time. If it is &#8216;-1&#8217;, vigra will choose a sensible default, but other values
may better fit your data access patterns. This is a soft limit, i.e. may be
exceeded temporarily if more chunks are needed simultaneously in a single
operation.</p>
<p>&#8216;fill_value&#8217; is returned for all array elements that have never been written.</p>
<p>&#8216;path&#8217; is the directory where the file is located (default: the system&#8217;s TMP
directory).</p>
<p>For more details see <a class="reference external" href="../../doc/vigra/classvigra_1_1ChunkedArray.html">ChunkedArray</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.ChunkedArrayFull">
<tt class="descclassname">vigra.</tt><tt class="descname">ChunkedArrayFull</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.ChunkedArrayFull" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a chunked array (type <a class="reference internal" href="#vigra.vigranumpycore.ChunkedArrayBase" title="vigra.vigranumpycore.ChunkedArrayBase"><tt class="xref py py-class docutils literal"><span class="pre">ChunkedArrayBase</span></tt></a>)
backed by a plain (consecutive) array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ChunkedArrayFull</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axistags</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>&#8216;shape&#8217; can be up to 5-dimensional.</p>
<p>&#8216;dtype&#8217; can currently be <tt class="docutils literal"><span class="pre">uint8</span></tt>, <tt class="docutils literal"><span class="pre">uint32</span></tt>, and <tt class="docutils literal"><span class="pre">float32</span></tt>.</p>
<p>&#8216;fill_value&#8217; is returned for all array elements that have never been written.</p>
<p>For more details see <a class="reference external" href="../../doc/vigra/classvigra_1_1ChunkedArray.html">ChunkedArray</a> in the vigra C++ documentation.</p>
</dd></dl>

</div>
</div>
<div class="section" id="import-and-export-functions">
<h2><a class="toc-backref" href="#id87">Import and Export Functions</a><a class="headerlink" href="#import-and-export-functions" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.impex defines read and write functions for image and volume data. Note
that the contents of this module are automatically imported into the vigra module, so
you may call &#8216;vigra.readImage(...)&#8217; instead of &#8216;vigra.impex.readImage(...)&#8217; etc.</p>
<span class="target" id="module-vigra.impex"></span><dl class="function">
<dt id="vigra.impex.isImage">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">isImage</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.isImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the given file name contains image data:</p>
<div class="highlight-python"><div class="highlight"><pre>isImage(filename) -&gt; bool
</pre></div>
</div>
<p>This function tests whether a file has a supported image format. It checks the first few bytes of the file and compares them with the &#8220;magic strings&#8221; of each recognized image format. If the image format is supported it returns True otherwise False.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.listExtensions">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">listExtensions</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.listExtensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Ask for the image file extensions that vigra.impex understands:</p>
<div class="highlight-python"><div class="highlight"><pre>listExtensions() -&gt; string
</pre></div>
</div>
<p>This function returns a string containing the supported image file extensions for reading and writing with the functions <a class="reference internal" href="#vigra.impex.readImage" title="vigra.impex.readImage"><tt class="xref py py-func docutils literal"><span class="pre">readImage()</span></tt></a> and <a class="reference internal" href="#vigra.impex.writeImage" title="vigra.impex.writeImage"><tt class="xref py py-func docutils literal"><span class="pre">writeImage()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.listFormats">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">listFormats</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.listFormats" title="Permalink to this definition">¶</a></dt>
<dd><p>Ask for the image file formats that vigra.impex understands:</p>
<div class="highlight-python"><div class="highlight"><pre>listFormats() -&gt; string
</pre></div>
</div>
<p>This function returns a string containing the supported image file formats for reading and writing with the functions <a class="reference internal" href="#vigra.impex.readImage" title="vigra.impex.readImage"><tt class="xref py py-func docutils literal"><span class="pre">readImage()</span></tt></a> and <a class="reference internal" href="#vigra.impex.writeImage" title="vigra.impex.writeImage"><tt class="xref py py-func docutils literal"><span class="pre">writeImage()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.numberImages">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">numberImages</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.numberImages" title="Permalink to this definition">¶</a></dt>
<dd><p>Check how many images the given file contains:</p>
<div class="highlight-python"><div class="highlight"><pre>numberImages(filename) -&gt; int
</pre></div>
</div>
<p>This function tests how many images an image file contains(Values &gt; 1 are only expected for the TIFF format to support multi-image TIFF).</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.readHDF5">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">readHDF5</tt><big>(</big><em>filenameOrGroup</em>, <em>pathInFile</em>, <em>order=None</em><big>)</big><a class="headerlink" href="#vigra.impex.readHDF5" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an array from an HDF5 file.</p>
<p>&#8216;filenameOrGroup&#8217; can contain a filename or a group object
referring to an already open HDF5 file. &#8216;pathInFile&#8217; is the name
of the dataset to be read, including intermediate groups. If the
first argument is a group object, the path is relative to this
group, otherwise it is relative to the file&#8217;s root group.</p>
<p>If the dataset has an attribute &#8216;axistags&#8217;, the returned array
will have type <a class="reference internal" href="#vigra.VigraArray" title="vigra.VigraArray"><tt class="xref py py-class docutils literal"><span class="pre">VigraArray</span></tt></a> and will be transposed
into the given &#8216;order&#8217; (&#8216;vigra.VigraArray.defaultOrder&#8217;
will be used if no order is given).  Otherwise, the returned
array is a plain &#8216;numpy.ndarray&#8217;. In this case, order=&#8217;F&#8217; will
return the array transposed into Fortran order.</p>
<p>Requirements: the &#8216;h5py&#8217; module must be installed.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.readImage">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">readImage</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.readImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an image from a file:</p>
<div class="highlight-python"><div class="highlight"><pre>readImage(filename, dtype=&#39;FLOAT&#39;, index=0, order=&#39;&#39;) -&gt; Image
</pre></div>
</div>
<p>When &#8216;dtype&#8217; is &#8216;UINT8&#8217;, &#8216;INT16&#8217;, &#8216;UINT16&#8217;, &#8216;INT32&#8217;, &#8216;UINT32&#8217;,
&#8216;FLOAT&#8217;, &#8216;DOUBLE&#8217;, or one of the corresponding numpy dtypes (numpy.uint8
etc.), the returned image will have the requested pixel type. If
dtype is &#8216;NATIVE&#8217; or &#8216;&#8217; (empty string), the image is imported with
the original type of the data in the file. By default, image data are
returned as &#8216;FLOAT&#8217; (i.e. numpy.float32). Caution: If the requested 
dtype is smaller than the original type in the file, values will be
clipped at the bounds of the representable range, which may not be the
desired behavior.</p>
<p>Individual images of sequential formats such as multi-image TIFF can be 
accessed via &#8216;index&#8217;. The number of images in a file can be checked with the 
function <a class="reference internal" href="#vigra.impex.numberImages" title="vigra.impex.numberImages"><tt class="xref py py-func docutils literal"><span class="pre">numberImages()</span></tt></a>. Alternatively, <a class="reference internal" href="#vigra.impex.readVolume" title="vigra.impex.readVolume"><tt class="xref py py-func docutils literal"><span class="pre">readVolume()</span></tt></a> can read 
an entire multi-page TIFF in one go.</p>
<p>The &#8216;order&#8217; parameter determines the axis ordering of the resulting array
(allowed values: &#8216;C&#8217;, &#8216;F&#8217;, &#8216;V&#8217;). When order == &#8216;&#8217; (the default), 
&#8216;vigra.VigraArray.defaultOrder&#8217; is used.</p>
<p>Supported file formats are listed by the function <a class="reference internal" href="#vigra.impex.listFormats" title="vigra.impex.listFormats"><tt class="xref py py-func docutils literal"><span class="pre">listFormats()</span></tt></a>.
When &#8216;filename&#8217; does not refer to a recognized image file format, an
exception is raised. The file can be checked beforehand with the function
<a class="reference internal" href="#vigra.impex.isImage" title="vigra.impex.isImage"><tt class="xref py py-func docutils literal"><span class="pre">isImage()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.readVolume">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">readVolume</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.impex.readVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a 3D volume from a directory:</p>
<div class="highlight-python"><div class="highlight"><pre>readVolume(filename, dtype=&#39;FLOAT&#39;, order=&#39;&#39;) -&gt; Volume
</pre></div>
</div>
<p>If the filename refers to a multi-page TIFF file, the images in the file are
interpreted as the z-slices of the volume.</p>
<p>If the volume is stored in a by-slice manner (e.g. one file per
z-slice), the &#8216;filename&#8217; can refer to an arbitrary image from the set.
readVolume() then assumes that the slices are enumerated like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">name_base</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span><span class="n">name_ext</span>
</pre></div>
</div>
<p>where name_base, the index, and name_ext
are determined automatically. All slice files with the same name base
and extension are considered part of the same volume. Slice numbers
must be non-negative, but can otherwise start anywhere and need not
be successive. Slices will be read in ascending numerical (not
lexicographic) order. All slices must have the same size.</p>
<p>Otherwise, readVolume() will try to read &#8216;filename&#8217; as an info text
file with the following key-value pairs:</p>
<div class="highlight-python"><div class="highlight"><pre>name = [short descriptive name of the volume] (optional)
filename = [absolute or relative path to raw voxel data file] (required)
gradfile =  [abs. or rel. path to gradient data file] (currently ignored)
description =  [arbitrary description of the data set] (optional)
width = [positive integer] (required)
height = [positive integer] (required)
depth = [positive integer] (required)
datatype = [UNSIGNED_CHAR | UNSIGNED_BYTE] (default: UNSIGNED_CHAR)
</pre></div>
</div>
<p>Lines starting with # are ignored.
When import_type is &#8216;UINT8&#8217;, &#8216;INT16&#8217;, &#8216;UINT16&#8217;, &#8216;INT32&#8217;, &#8216;UINT32&#8217;,
&#8216;FLOAT&#8217;, &#8216;DOUBLE&#8217;, or one of the corresponding numpy dtypes (numpy.uint8
etc.), the returned volume will have the requested pixel type.</p>
<p>The order parameter determines the axis ordering of the resulting array
(allowed values: &#8216;C&#8217;, &#8216;F&#8217;, &#8216;V&#8217;). When order == &#8216;&#8217; (the default), vigra.VigraArray.defaultOrder is used.</p>
<p>For details see the help for <a class="reference internal" href="#vigra.impex.readImage" title="vigra.impex.readImage"><tt class="xref py py-func docutils literal"><span class="pre">readImage()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.writeHDF5">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">writeHDF5</tt><big>(</big><em>data</em>, <em>filenameOrGroup</em>, <em>pathInFile</em>, <em>compression=None</em>, <em>chunks=None</em><big>)</big><a class="headerlink" href="#vigra.impex.writeHDF5" title="Permalink to this definition">¶</a></dt>
<dd><p>Write an array to an HDF5 file.</p>
<p>&#8216;filenameOrGroup&#8217; can contain a filename or a group object
referring to an already open HDF5 file. &#8216;pathInFile&#8217; is the name of the
dataset to be written, including intermediate groups. If the first
argument is a group object, the path is relative to this group,
otherwise it is relative to the file&#8217;s root group. If the dataset already
exists, it will be replaced without warning.</p>
<p>If &#8216;data&#8217; has an attribute &#8216;axistags&#8217;, the array is transposed to
numpy order before writing. Moreover, the axistags will be
stored along with the data in an attribute &#8216;axistags&#8217;.</p>
<p>&#8216;compression&#8217; can be set to &#8216;gzip&#8217;, &#8216;szip&#8217; or &#8216;lzf&#8217;
gzip (standard compression),
szip (available if HDF5 is compiled with szip. Faster compression, limited types),
lzf (very fast compression, all types).
The &#8216;lzf&#8217; compression filter is many times faster than &#8216;gzip&#8217;
at the cost of a lower compresion ratio.</p>
<p>Chunking is disabled by default. When &#8216;chunks&#8217; is set to True
chunking is enabled and a chunk shape is determined automatically.
Alternatively a chunk shape can be specified explicitly by passing
a tuple of the desired shape.</p>
<p>Requirements: the &#8216;h5py&#8217; module must be installed.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.writeImage">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">writeImage</tt><big>(</big><em>(object)image</em>, <em>(str)filename</em><span class="optional">[</span>, <em>(object)dtype=''</em><span class="optional">[</span>, <em>(str)compression=''</em><span class="optional">[</span>, <em>(str)mode='w'</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.impex.writeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Save an image to a file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">writeImage</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameters:</p>
<blockquote>
<div><dl class="docutils">
<dt>image:</dt>
<dd>the image to be saved</dd>
<dt>filename:</dt>
<dd>the file name to save to. The file type will be deduced
from the file name extension (see vigra.impexListExtensions()
for a list of supported extensions).</dd>
<dt>dtype:</dt>
<dd><p class="first">the pixel type written to the file. Possible values:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>&#8216;&#8217; or &#8216;NATIVE&#8217;:</dt>
<dd>save with original pixel type, or convert automatically
when this type is unsupported by the target file format</dd>
<dt>&#8216;UINT8&#8217;, &#8216;INT16&#8217;, &#8216;UINT16&#8217;, &#8216;INT32&#8217;, &#8216;UINT32&#8217;, &#8216;FLOAT&#8217;, &#8216;DOUBLE&#8217;:</dt>
<dd>save as specified, or raise exception when this type is not 
supported by the target file format (see list below)</dd>
<dt>&#8216;NBYTE&#8217;:</dt>
<dd>normalize to range 0...255 and then save as &#8216;UINT8&#8217;</dd>
<dt>numpy.uint8, numpy.int16 etc.:</dt>
<dd>behaves like the corresponding string argument</dd>
</dl>
</div></blockquote>
</dd>
<dt>compression:</dt>
<dd><p class="first">how to compress the data (ignored when compression type is unsupported 
by the file format). Possible values:</p>
<dl class="last docutils">
<dt>&#8216;&#8217; or not given:</dt>
<dd>save with the native compression of the target file format</dd>
<dt>&#8216;RLE&#8217;, &#8216;RunLength&#8217;:</dt>
<dd>use run length encoding (native in BMP, supported by TIFF)</dd>
<dt>&#8216;DEFLATE&#8217;:</dt>
<dd>use deflate encoding (only supported by TIFF)</dd>
<dt>&#8216;LZW&#8217;:</dt>
<dd>use LZW algorithm (only supported by TIFF with LZW enabled)</dd>
<dt>&#8216;ASCII&#8217;:</dt>
<dd>write as ASCII rather than binary file (only supported by PNM)</dd>
<dt>&#8216;1&#8217; ... &#8216;100&#8217;:</dt>
<dd>use this JPEG compression level (only supported by JPEG and TIFF)</dd>
</dl>
</dd>
<dt>mode:</dt>
<dd><p class="first">support for sequential file formats such as multi-image TIFF. 
Possible values:</p>
<dl class="last docutils">
<dt>&#8216;w&#8217;:</dt>
<dd>create a new file (default)</dd>
<dt>&#8216;a&#8217;:</dt>
<dd>append an image to a file or create a new one if the file does 
not exist (only supported by TIFF to create multi-page TIFF files)</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Supported file formats are listed by the function vigra.impexListFormats().
The different file formats support the following pixel types:</p>
<blockquote>
<div><dl class="docutils">
<dt>BMP:</dt>
<dd>Microsoft Windows bitmap image file (pixel type: UINT8 as gray and RGB).</dd>
<dt>GIF:</dt>
<dd>CompuServe graphics interchange format; 8-bit color
(pixel type: UINT8 as gray and RGB).</dd>
<dt>JPEG:</dt>
<dd>Joint Photographic Experts Group JFIF format; compressed 24-bit color
(pixel types: UINT8 as gray and RGB). Only available if libjpeg is
installed.</dd>
<dt>PNG:</dt>
<dd>Portable Network Graphic (pixel types: UINT8 and UINT16 with
up to 4 channels). (only available if libpng is installed)</dd>
<dt>PBM:</dt>
<dd>Portable bitmap format (black and white).</dd>
<dt>PGM:</dt>
<dd>Portable graymap format (pixel types: UINT8, INT16, INT32 as gray scale).</dd>
<dt>PNM:</dt>
<dd>Portable anymap (pixel types: UINT8, INT16, INT32, gray and RGB)</dd>
<dt>PPM:</dt>
<dd>Portable pixmap format (pixel types: UINT8, INT16, INT32 as RGB)</dd>
<dt>SUN:</dt>
<dd>SUN Rasterfile (pixel types: UINT8 as gray and RGB).</dd>
<dt>TIFF:</dt>
<dd>Tagged Image File Format (pixel types: INT8, UINT8, INT16, UINT16,
INT32, UINT32, FLOAT, DOUBLE with up to 4 channels). Only available
if libtiff is installed.</dd>
<dt>VIFF:</dt>
<dd>Khoros Visualization image file (pixel types: UINT8, INT16
INT32, FLOAT, DOUBLE with arbitrary many channels).</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.impex.writeVolume">
<tt class="descclassname">vigra.impex.</tt><tt class="descname">writeVolume</tt><big>(</big><em>(object)volume</em>, <em>(str)filename_base</em>, <em>(str)filename_ext</em><span class="optional">[</span>, <em>(object)dtype=''</em><span class="optional">[</span>, <em>(str)compression=''</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.impex.writeVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a volume as a sequence of images:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">writeVolume</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">filename_base</span><span class="p">,</span> <span class="n">filename_ext</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting image sequence will be enumerated in the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">filename_base</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span><span class="n">filename_ext</span>
</pre></div>
</div>
<p>Write a volume as a multi-page tiff (filename_ext must be an empty string):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">writeVolume</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameters &#8216;dtype&#8217; and &#8216;compression&#8217; will be handled as in <a class="reference internal" href="#vigra.impex.writeImage" title="vigra.impex.writeImage"><tt class="xref py py-func docutils literal"><span class="pre">writeImage()</span></tt></a>.</p>
</dd></dl>

</div>
<div class="section" id="mathematical-functions-and-type-coercion">
<span id="sec-dtype-coercion"></span><h2><a class="toc-backref" href="#id88">Mathematical Functions and Type Coercion</a><a class="headerlink" href="#mathematical-functions-and-type-coercion" title="Permalink to this headline">¶</a></h2>
<p>vigranumpy supports all arithmetic and algebraic functions defined in
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs">numpy.ufunc</a>, but re-implements them in module <cite>vigra.ufunc</cite> to take full advantage of axistags.</p>
<span class="target" id="module-vigra.ufunc"></span><p>The following mathematical functions are available in this module
(refer to numpy for detailed documentation):</p>
<div class="highlight-python"><div class="highlight"><pre>absolute   absolute   add   arccos   arccosh   arcsin   arcsinh   arctan
arctan2   arctanh   bitwise_and   bitwise_or   bitwise_xor   ceil
conjugate   conjugate   copysign   cos   cosh   deg2rad   degrees   divide
equal   exp   exp2   expm1   fabs   floor   floor_divide   fmax
fmin   fmod   frexp   greater   greater_equal   hypot   invert   invert
isfinite   isinf   isnan   ldexp   left_shift   less   less_equal   log
log10   log1p   log2   logaddexp   logaddexp2   logical_and   logical_not
logical_or   logical_xor   maximum   minimum   modf   multiply   negative
nextafter   not_equal   power   rad2deg   radians   reciprocal   remainder
remainder   right_shift   rint   sign   signbit   sin   sinh   spacing
sqrt   square   subtract   tan   tanh   true_divide   trunc
</pre></div>
</div>
<p>Some of these functions are also provided as member functions of
VigraArray:</p>
<div class="highlight-python"><div class="highlight"><pre>__abs__   __add__   __and__   __div__   __divmod__   __eq__
__floordiv__   __ge__   __gt__   __invert__   __le__   __lshift__
__lt__   __mod__   __mul__   __ne__   __neg__   __or__   __pos__
__pow__   __radd__   __radd__   __rand__   __rdiv__   __rdivmod__
__rfloordiv__   __rlshift__   __rmod__   __rmul__   __ror__   __rpow__
__rrshift__   __rshift__   __rsub__   __rtruediv__   __rxor__   __sub__
__truediv__   __xor__
</pre></div>
</div>
<p>As usual, these functions are applied independently at each pixel.</p>
<p>Vigranumpy overloads the numpy-versions of these functions in order to make their
behavior more suitable for image analysis. In particular, we changed two aspects:</p>
<ul class="simple">
<li>Axistag consistency is checked, and the order of axes and strides is
preserved in the result array. (In contrast, plain numpy functions
always create C-order arrays, disregarding the stride order of the
inputs.)</li>
<li>Typecasting rules are changed such that (i) data are represented with
at most 32 bits, when possible, (ii) the number of types that occur as
results of mixed expressions is reduced, and (iii) the chance of bad
surprises is minimized.</li>
</ul>
<p>Default output types are thus determined according to the following rules:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">The output type does not depend on the order of the arguments:</p>
<div class="highlight-python"><div class="highlight"><pre>a + b results in the same type as b + a
</pre></div>
</div>
</li>
</ol>
<dl class="docutils">
<dt>2.a With exception of logical functions and abs(), the output type</dt>
<dd>does not depend on the function to be executed.</dd>
</dl>
<p>2.b The output type of logical functions is bool.</p>
<dl class="docutils">
<dt>2.c The output type of abs() follows general rules unless the</dt>
<dd><p class="first">input contains complex numbers, in which case the output type
is the corresponding float number type:</p>
<div class="last highlight-python"><div class="highlight"><pre>a + b results in the same type as a / b
a == b =&gt; bool
abs(complex128) =&gt; float64
</pre></div>
</div>
</dd>
</dl>
<ol class="arabic" start="3">
<li><p class="first">If the inputs have the same type, the type is preserved:</p>
<div class="highlight-python"><div class="highlight"><pre>uint8 + uint8 =&gt; uint8
</pre></div>
</div>
</li>
<li><p class="first">If (and only if) one of the inputs has at least 64 bits, the output
will also have at least 64 bits:</p>
<div class="highlight-python"><div class="highlight"><pre>int64 + uint32 =&gt; int64
int64 + 1.0    =&gt; float64
</pre></div>
</div>
</li>
<li><p class="first">If an array is combined with a scalar of the same kind (integer,
float, or complex), the array type is preserved. If an integer
array with at most 32 bits is combined with a float scalar, the
result is float32 (and rule 4 kicks in if the array has 64 bits):</p>
<div class="highlight-python"><div class="highlight"><pre>uint8   + 1   =&gt; uint8
uint8   + 1.0 =&gt; float32
float32 + 1.0 =&gt; float32
float64 + 1.0 =&gt; float64
</pre></div>
</div>
</li>
<li><p class="first">Integer expressions with mixed types always produce signed results.
If the arguments have at most 32 bits, the result will be int32,
otherwise it will be int64 (cf. rule 4):</p>
<div class="highlight-python"><div class="highlight"><pre>int8  + uint8  =&gt; int32
int32 + uint8  =&gt; int32
int32 + uint32 =&gt; int32
int32 + int64  =&gt; int64
int64 + uint64 =&gt; int64
</pre></div>
</div>
</li>
<li><p class="first">In all other cases, the output type is equal to the highest input
type:</p>
<div class="highlight-python"><div class="highlight"><pre>int32   + float32    =&gt; float32
float32 + complex128 =&gt; complex128
</pre></div>
</div>
</li>
<li><p class="first">All defaults can be overridden by providing an explicit output array:</p>
<div class="highlight-python"><div class="highlight"><pre>ufunc.add(uint8, uint8, uint16) =&gt; uint16
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
<p>In order to prevent overflow, necessary upcasting is performed before
the function is executed.</p>
</div>
<div class="section" id="color-and-intensity-manipulation">
<h2><a class="toc-backref" href="#id89">Color and Intensity Manipulation</a><a class="headerlink" href="#color-and-intensity-manipulation" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.colors provides functions to adjust image brightness and contrast,
and to transform between different color spaces.
See <a class="reference external" href="../vigra/group__ColorConversions.html">Color Conversions</a> in the C++ documentation
for more information.</p>
<span class="target" id="module-vigra.colors"></span><dl class="function">
<dt id="vigra.colors.alphamodulated2qimage_ARGB32Premultiplied">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">alphamodulated2qimage_ARGB32Premultiplied</tt><big>(</big><em>(object)image</em>, <em>(object)qimage</em>, <em>(object)tintColor</em>, <em>(object)normalize</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.colors.alphamodulated2qimage_ARGB32Premultiplied" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the image (single-band) into a QImage of format Format_ARGB32_Premultiplied.</p>
<p>import qimage2ndarray
qimg = QImage(a.shape[0], a.shape[1], QImage.Format_ARGB32_Premultiplied)
normalize = numpy.asarray([10, 217], dtype=image.dtype)
tintColor = numpy.asarray([1.0, 0.0, 0.0], dtype=numpy.float32) #RGB
vigra.colors.alphamodulated2qimage_ARGB32Premultiplied(a, qimage2ndarray.byte_view(qimg), tintColor, normalize)</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.applyColortable">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">applyColortable</tt><big>(</big><em>(object)valueImage</em>, <em>(object)colortable</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.applyColortable" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a colortable to the given 2D valueImage.</p>
<p>Colortable must have 4 columns, each row represents a color (for example, RGBA). 
Values in valueImage are first taken modulo the length of the colortable. 
In the special case where the first color in the table is transparent, that value is NOT repeated for values outside the colortable length.</p>
<p>Returns: uint8 image with 4 channels</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.brightness">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">brightness</tt><big>(</big><em>(object)image</em>, <em>(float)factor</em><span class="optional">[</span>, <em>(object)range=(0.0</em>, <em>255.0)</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.brightness" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Adjust the brightness of a 2D scalar or multiband image. The function applies the formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span> <span class="o">=</span> <span class="n">image</span> <span class="o">+</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>to each element of the array. &#8216;factor&#8217; and &#8216;range[1] - range[0]&#8217; must be positive. Elements outside the given range are clipped at the range borders. If &#8216;range&#8217; is None or &#8220;&#8221; or &#8220;auto&#8221;, the range is set to the actual range of &#8216;image&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">range</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<dl class="docutils">
<dt>brightness( (object)volume, (float)factor [, (object)range=(0.0, 255.0) [, (object)out=None]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar or multiband volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.contrast">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">contrast</tt><big>(</big><em>(object)image</em>, <em>(float)factor</em><span class="optional">[</span>, <em>(object)range=(0.0</em>, <em>255.0)</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.contrast" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Adjust the contrast of an image or volume. The function applies the formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">image</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">factor</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>
</pre></div>
</div>
<p>to each element of the array. &#8216;factor&#8217; and &#8216;range[1] - range[0]&#8217; must be positive. Elements outside the given range are clipped at the range borders. If &#8216;range&#8217; is None or &#8220;&#8221; or &#8220;auto&#8221;, the range is set to the actual range of &#8216;image&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">range</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<dl class="docutils">
<dt>contrast( (object)volume, (float)factor [, (object)range=(0.0, 255.0) [, (object)out=None]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar or multiband volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.gammaCorrection">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">gammaCorrection</tt><big>(</big><em>(object)image</em>, <em>(float)gamma</em><span class="optional">[</span>, <em>(object)range=(0.0</em>, <em>255.0)</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.gammaCorrection" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Adjust gamma correction to an image or volume. The function applies the formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">diff</span> <span class="o">=</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">out</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">((</span><span class="n">image</span> <span class="o">-</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">diff</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">+</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>to each element of the array. &#8216;gamma&#8217; and &#8216;range[1] - range[0]&#8217; must be positive. Elements outside the given range are clipped at the range borders. If &#8216;range&#8217; is None or &#8220;&#8221; or &#8220;auto&#8221;, the range is set to the actual range of &#8216;image&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">range</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<dl class="docutils">
<dt>gammaCorrection( (object)volume, (float)gamma [, (object)range=(0.0, 255.0) [, (object)out=None]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar or multiband volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.gray2qimage_ARGB32Premultiplied">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">gray2qimage_ARGB32Premultiplied</tt><big>(</big><em>(object)image</em>, <em>(object)qimage</em><span class="optional">[</span>, <em>(object)normalize=None</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.colors.gray2qimage_ARGB32Premultiplied" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the image (single-band) into a QImage of format Format_ARGB32_Premultiplied.</p>
<p>import qimage2ndarray
qimg = QImage(a.shape[0], a.shape[1], QImage.Format_ARGB32_Premultiplied)
normalize = numpy.asarray([10, 217], dtype=image.dtype)
vigra.colors.gray2qimage_ARGB32Premultiplied(a, qimage2ndarray.byte_view(qimg), normalize)</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.linearRangeMapping">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">linearRangeMapping</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)oldRange='auto'</em><span class="optional">[</span>, <em>(object)newRange=(0.0</em>, <em>255.0)</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.linearRangeMapping" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Convert the intensity range of a 2D scalar or multiband image. The function applies a linear transformation to the intensities such that the value oldRange[0] is mapped onto newRange[0], and oldRange[1] is mapped onto newRange[1]. That is, the algorithm applies the formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">oldDiff</span> <span class="o">=</span> <span class="n">oldRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">oldRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">newDiff</span> <span class="o">=</span> <span class="n">newRange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">newRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span> <span class="o">-</span> <span class="n">oldRange</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">oldDiff</span> <span class="o">*</span> <span class="n">newDiff</span> <span class="o">+</span> <span class="n">newRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>to each element of the array. &#8216;oldDiff&#8217; and &#8216;newDiff&#8217; must be positive. If &#8216;oldRange&#8217; is None or &#8220;&#8221; or &#8220;auto&#8221; (the default), the range is set to the actual range of &#8216;image&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">range</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
<p>If &#8216;newRange&#8217; is None or &#8220;&#8221; or &#8220;auto&#8221;, it is set to (0, 255.0). If &#8216;out&#8217; is explicitly passed, it must be a uint8 image.</p>
</div></blockquote>
<dl class="docutils">
<dt>linearRangeMapping( (object)image [, (object)oldRange=&#8217;auto&#8217; [, (object)newRange=(0.0, 255.0) [, (object)out=None]]]) -&gt; object :</dt>
<dd>Likewise, but #in&#8217; and &#8216;out&#8217; are float32 images.</dd>
<dt>linearRangeMapping( (object)volume [, (object)oldRange=&#8217;auto&#8217; [, (object)newRange=(0.0, 255.0) [, (object)out=None]]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar or multiband volume, when &#8216;in&#8217; is a float32 and &#8216;out&#8217; a unit8 volume.</dd>
<dt>linearRangeMapping( (object)volume [, (object)oldRange=&#8217;auto&#8217; [, (object)newRange=(0.0, 255.0) [, (object)out=None]]]) -&gt; object :</dt>
<dd>Likewise, but &#8216;in&#8217; and &#8216;out&#8217; are float32 volumes.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_Lab2RGB">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_Lab2RGB</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_Lab2RGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using Lab2RGBFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1Lab2RGBFunctor.html">Lab2RGBFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_Lab2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_Lab2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_Lab2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using Lab2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1Lab2RGBPrimeFunctor.html">Lab2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_Lab2XYZ">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_Lab2XYZ</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_Lab2XYZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using Lab2XYZFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1Lab2XYZFunctor.html">Lab2XYZFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_Luv2RGB">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_Luv2RGB</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_Luv2RGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using Luv2RGBFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1Luv2RGBFunctor.html">Luv2RGBFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_Luv2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_Luv2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_Luv2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using Luv2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1Luv2RGBPrimeFunctor.html">Luv2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_Luv2XYZ">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_Luv2XYZ</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_Luv2XYZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using Luv2XYZFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1Luv2XYZFunctor.html">Luv2XYZFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGB2Lab">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGB2Lab</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGB2Lab" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGB2LabFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGB2LabFunctor.html">RGB2LabFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGB2Luv">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGB2Luv</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGB2Luv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGB2LuvFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGB2LuvFunctor.html">RGB2LuvFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGB2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGB2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGB2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGB2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGB2RGBPrimeFunctor.html">RGB2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGB2XYZ">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGB2XYZ</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGB2XYZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGB2XYZFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGB2XYZFunctor.html">RGB2XYZFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGB2sRGB">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGB2sRGB</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGB2sRGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGB2sRGBFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGB2sRGBFunctor.html">RGB2sRGBFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2Lab">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2Lab</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2Lab" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2LabFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2LabFunctor.html">RGBPrime2LabFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2Luv">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2Luv</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2Luv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2LuvFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2LuvFunctor.html">RGBPrime2LuvFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2RGB">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2RGB</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2RGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2RGBFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2RGBFunctor.html">RGBPrime2RGBFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2XYZ">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2XYZ</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2XYZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2XYZFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2XYZFunctor.html">RGBPrime2XYZFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2YPrimeCbCr">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2YPrimeCbCr</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2YPrimeCbCr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2YPrimeCbCrFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2YPrimeCbCrFunctor.html">RGBPrime2YPrimeCbCrFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2YPrimeIQ">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2YPrimeIQ</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2YPrimeIQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2YPrimeIQFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2YPrimeIQFunctor.html">RGBPrime2YPrimeIQFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2YPrimePbPr">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2YPrimePbPr</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2YPrimePbPr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2YPrimePbPrFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2YPrimePbPrFunctor.html">RGBPrime2YPrimePbPrFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_RGBPrime2YPrimeUV">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_RGBPrime2YPrimeUV</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_RGBPrime2YPrimeUV" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using RGBPrime2YPrimeUVFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1RGBPrime2YPrimeUVFunctor.html">RGBPrime2YPrimeUVFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_XYZ2Lab">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_XYZ2Lab</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_XYZ2Lab" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using XYZ2LabFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1XYZ2LabFunctor.html">XYZ2LabFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_XYZ2Luv">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_XYZ2Luv</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_XYZ2Luv" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using XYZ2LuvFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1XYZ2LuvFunctor.html">XYZ2LuvFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_XYZ2RGB">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_XYZ2RGB</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_XYZ2RGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using XYZ2RGBFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1XYZ2RGBFunctor.html">XYZ2RGBFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_XYZ2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_XYZ2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_XYZ2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using XYZ2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1XYZ2RGBPrimeFunctor.html">XYZ2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_YPrimeCbCr2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_YPrimeCbCr2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_YPrimeCbCr2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using YPrimeCbCr2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1YPrimeCbCr2RGBPrimeFunctor.html">YPrimeCbCr2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_YPrimeIQ2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_YPrimeIQ2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_YPrimeIQ2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using YPrimeIQ2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1YPrimeIQ2RGBPrimeFunctor.html">YPrimeIQ2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_YPrimePbPr2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_YPrimePbPr2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_YPrimePbPr2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using YPrimePbPr2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1YPrimePbPr2RGBPrimeFunctor.html">YPrimePbPr2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_YPrimeUV2RGBPrime">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_YPrimeUV2RGBPrime</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_YPrimeUV2RGBPrime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using YPrimeUV2RGBPrimeFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1YPrimeUV2RGBPrimeFunctor.html">YPrimeUV2RGBPrimeFunctor</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.colors.transform_sRGB2RGB">
<tt class="descclassname">vigra.colors.</tt><tt class="descname">transform_sRGB2RGB</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.colors.transform_sRGB2RGB" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the colors of the given &#8216;image&#8217; using sRGB2RGBFunctor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/classvigra_1_1sRGB2RGBFunctor.html">sRGB2RGBFunctor</a> in the C++ documentation.</p>
</dd></dl>

</div>
<div class="section" id="filters">
<h2><a class="toc-backref" href="#id90">Filters</a><a class="headerlink" href="#filters" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.filters provides operators that consider a window around each pixel, compute
one or several numbers from the values in the window, and store the results in the
corresponding pixel of the output image. This includes convolution, non-linear diffusion,
morphological operators, feature detectors (such as the structure tensor) etc.</p>
<span class="target" id="module-vigra.filters"></span><dl class="class">
<dt id="vigra.filters.Kernel1D">
<em class="property">class </em><tt class="descclassname">vigra.filters.</tt><tt class="descname">Kernel1D</tt><big>(</big><em>(object)arg1</em><big>)</big><a class="headerlink" href="#vigra.filters.Kernel1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic 1 dimensional convolution kernel.</p>
<p>This kernel may be used for convolution of 1 dimensional signals or for separable convolution of multidimensional signals. The kernel&#8217;s size is given by its left() and right() methods. The desired border treatment mode is returned by getBorderTreatment(). The different init functions create a kernel with the specified properties. For more details, see <a class="reference external" href="../../doc/vigra/classvigra_1_1Kernel1D.html">Kernel1D</a> in the C++ documentation.</p>
<p>Standard constructor:</p>
<div class="highlight-python"><div class="highlight"><pre>   Kernel1D()

Creates an identity kernel.
</pre></div>
</div>
<dl class="docutils">
<dt>__init__( (object)arg1, (Kernel1D)kernel) -&gt; None :</dt>
<dd><p class="first">Copy constructor:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">Kernel1D</span><span class="p">(</span><span class="n">other_kernel</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="vigra.filters.Kernel1D.borderTreatment">
<tt class="descname">borderTreatment</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; BorderTreatmentMode :<a class="headerlink" href="#vigra.filters.Kernel1D.borderTreatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current border treatment mode.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initAveraging">
<tt class="descname">initAveraging</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initAveraging" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as an averaging filter with given radius (i.e. window size 2*radius+1). &#8216;norm&#8217; denotes the sum of all bins of the kernel.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;averagingKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initBinomial">
<tt class="descname">initBinomial</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initBinomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a binomial filter with given radius (i.e. window size 2*radius+1). &#8216;norm&#8217; denotes the sum of all bins of the kernel.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;binomialKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initBurtFilter">
<tt class="descname">initBurtFilter</tt><big>(</big><em>(Kernel1D)arg1</em><span class="optional">[</span>, <em>(float)a=0.04785</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initBurtFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a 5-tap smoothing filter of the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span> <span class="n">a</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;burtFilterKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initDiscreteGaussian">
<tt class="descname">initDiscreteGaussian</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initDiscreteGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as Lindeberg&#8217;s discrete analog of the Gaussian function. The radius of the kernel is always 3*std_dev. &#8216;norm&#8217; denotes the desired sum of all bins of the kernel.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;discreteGaussianKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initExplicitly">
<tt class="descname">initExplicitly</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(int)left</em>, <em>(int)right</em>, <em>(object)contents</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initExplicitly" title="Permalink to this definition">¶</a></dt>
<dd><p>Init the kernel with explicit values from &#8216;contents&#8217;, which must be a 1D numpy.ndarray. &#8216;left&#8217; and &#8216;right&#8217; are the boundaries of the kernel (inclusive). If &#8216;contents&#8217; contains the wrong number of values, a run-time error results. It is, however, possible to give just one initializer. This creates an averaging filter with the given constant. The norm is set to the sum of the initializer values.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;explicitlyKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initGaussian">
<tt class="descname">initGaussian</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a sampled Gaussian function. The radius of the kernel is always 3*std_dev. &#8216;norm&#8217; denotes the desired sum of all bins of the kernel (i.e. the kernel is corrected for the normalization error introduced by windowing the Gaussian to a finite interval). However, if norm is 0.0, the kernel is normalized to 1 by the analytic expression for the Gaussian, and no correction for the windowing error is performed.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;gaussianKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initGaussianDerivative">
<tt class="descname">initGaussianDerivative</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(float)scale</em>, <em>(int)order</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initGaussianDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a Gaussian derivative of order &#8216;order&#8217;. The radius of the kernel is always 3*std_dev + 0.5*order. &#8216;norm&#8217; denotes the norm of the kernel. Thus, the kernel will be corrected for the error introduced by windowing the Gaussian to a finite interval. However, if norm is 0.0, the kernel is normalized to 1 by the analytic expression for the Gaussian derivative, and no correction for the windowing error is performed.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;gaussianDerivativeKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalFirstDerivative5">
<tt class="descname">initOptimalFirstDerivative5</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalFirstDerivative5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalFirstDerivativeSmoothing3">
<tt class="descname">initOptimalFirstDerivativeSmoothing3</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalFirstDerivativeSmoothing3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalFirstDerivativeSmoothing5">
<tt class="descname">initOptimalFirstDerivativeSmoothing5</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalFirstDerivativeSmoothing5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalSecondDerivative5">
<tt class="descname">initOptimalSecondDerivative5</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalSecondDerivative5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalSecondDerivativeSmoothing3">
<tt class="descname">initOptimalSecondDerivativeSmoothing3</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalSecondDerivativeSmoothing3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalSecondDerivativeSmoothing5">
<tt class="descname">initOptimalSecondDerivativeSmoothing5</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalSecondDerivativeSmoothing5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalSmoothing3">
<tt class="descname">initOptimalSmoothing3</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalSmoothing3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initOptimalSmoothing5">
<tt class="descname">initOptimalSmoothing5</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.filters.Kernel1D.initOptimalSmoothing5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initSecondDifference3">
<tt class="descname">initSecondDifference3</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initSecondDifference3" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a 3-tap second difference filter of the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;secondDifference3Kernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.initSymmetricDifference">
<tt class="descname">initSymmetricDifference</tt><big>(</big><em>(Kernel1D)arg1</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.initSymmetricDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a symmetric difference filter of the form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">norm</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">norm</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">norm</span><span class="p">]</span>
</pre></div>
</div>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;symmetricDifferenceKernel()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.left">
<tt class="descname">left</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.filters.Kernel1D.left" title="Permalink to this definition">¶</a></dt>
<dd><p>Left border of kernel (inclusive).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.norm">
<tt class="descname">norm</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.filters.Kernel1D.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the norm of kernel.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.normalize">
<tt class="descname">normalize</tt><big>(</big><em>(Kernel1D)arg1</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">[</span>, <em>(int)derivativeOrder=0</em><span class="optional">[</span>, <em>(float)offset=0.0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a new norm and normalize kernel, use the normalization formula for the given derivativeOrder.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.right">
<tt class="descname">right</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.filters.Kernel1D.right" title="Permalink to this definition">¶</a></dt>
<dd><p>Right border of kernel (inclusive).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.setBorderTreatment">
<tt class="descname">setBorderTreatment</tt><big>(</big><em>(Kernel1D)arg1</em>, <em>(BorderTreatmentMode)borderTreatment</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel1D.setBorderTreatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Set border treatment mode.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel1D.size">
<tt class="descname">size</tt><big>(</big><em>(Kernel1D)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.filters.Kernel1D.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of kernel elements (right() - left() + 1).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vigra.filters.Kernel2D">
<em class="property">class </em><tt class="descclassname">vigra.filters.</tt><tt class="descname">Kernel2D</tt><big>(</big><em>(object)arg1</em><big>)</big><a class="headerlink" href="#vigra.filters.Kernel2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic 2 dimensional convolution kernel.</p>
<p>This kernel may be used for convolution of 2 dimensional signals. The desired border treatment mode is returned by borderTreatment().(Note that the 2D convolution functions don&#8217;t currently support all modes.) The different init functions create a kernel with the specified properties. For more details, see <a class="reference external" href="../../doc/vigra/classvigra_1_1Kernel2D.html">Kernel2D</a> in the C++ documentation.</p>
<p>Standard constructor:</p>
<div class="highlight-python"><div class="highlight"><pre>   Kernel2D()

Creates an identity kernel.
</pre></div>
</div>
<dl class="docutils">
<dt>__init__( (object)arg1, (Kernel2D)kernel) -&gt; None :</dt>
<dd><p class="first">Copy constructor:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">Kernel2D</span><span class="p">(</span><span class="n">other_kernel</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="vigra.filters.Kernel2D.borderTreatment">
<tt class="descname">borderTreatment</tt><big>(</big><em>(Kernel2D)arg1</em><big>)</big> &rarr; BorderTreatmentMode :<a class="headerlink" href="#vigra.filters.Kernel2D.borderTreatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Return current border treatment mode.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.height">
<tt class="descname">height</tt><big>(</big><em>(Kernel2D)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.filters.Kernel2D.height" title="Permalink to this definition">¶</a></dt>
<dd><p>Vertical kernel size (lowerRight()[1] - upperLeft()[1] + 1).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.initDisk">
<tt class="descname">initDisk</tt><big>(</big><em>(Kernel2D)arg1</em>, <em>(int)radius</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel2D.initDisk" title="Permalink to this definition">¶</a></dt>
<dd><p>Init the 2D kernel as a circular averaging filter. The norm will be calculated as 1 / (number of non-zero kernel values).</p>
<p>Precondition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;diskKernel2D()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.initExplicitly">
<tt class="descname">initExplicitly</tt><big>(</big><em>(Kernel2D)arg1</em>, <em>(object)upperLeft</em>, <em>(object)lowerRight</em>, <em>(object)contents</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel2D.initExplicitly" title="Permalink to this definition">¶</a></dt>
<dd><p>Init the kernel with explicit values from &#8216;contents&#8217;, which must be a 2D numpy.ndarray. &#8216;upperLeft&#8217; and &#8216;lowerRight&#8217; are the boundaries of the kernel (inclusive), and  must be 2D tuples. If &#8216;contents&#8217; contains the wrong number of values, a run-time error results. It is, however, possible to give just one initializer. This creates an averaging filter with the given constant. The norm is set to the sum of the initializer values.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;explicitlyKernel2D()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.initGaussian">
<tt class="descname">initGaussian</tt><big>(</big><em>(Kernel2D)arg1</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel2D.initGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Init kernel as a sampled 2D Gaussian function. The radius of the kernel is always 3*std_dev. &#8216;norm&#8217; denotes the desired sum of all bins of the kernel (i.e. the kernel is corrected for the normalization error introduced by windowing the Gaussian to a finite interval). However, if norm is 0.0, the kernel is normalized to 1 by the analytic expression for the Gaussian, and no correction for the windowing error is performed.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;gaussianKernel2D()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.initSeparable">
<tt class="descname">initSeparable</tt><big>(</big><em>(Kernel2D)arg1</em>, <em>(Kernel1D)kernelX</em>, <em>(Kernel1D)kernelY</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel2D.initSeparable" title="Permalink to this definition">¶</a></dt>
<dd><p>Init the 2D kernel as the cartesian product of two 1D kernels of type Kernel1D. The norm becomes the product of the two original norms.</p>
<p>Kernel construction and initialization can be performed in one step by calling the factory function &#8216;separableKernel2D()&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.lowerRight">
<tt class="descname">lowerRight</tt><big>(</big><em>(Kernel2D)arg1</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.Kernel2D.lowerRight" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower right border of kernel (inclusive).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.norm">
<tt class="descname">norm</tt><big>(</big><em>(Kernel2D)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.filters.Kernel2D.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the norm of the kernel.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.normalize">
<tt class="descname">normalize</tt><big>(</big><em>(Kernel2D)arg1</em><span class="optional">[</span>, <em>(float)norm=1.0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel2D.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the kernel&#8217;s norm and renormalize the values.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.setBorderTreatment">
<tt class="descname">setBorderTreatment</tt><big>(</big><em>(Kernel2D)arg1</em>, <em>(BorderTreatmentMode)borderTreatment</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.filters.Kernel2D.setBorderTreatment" title="Permalink to this definition">¶</a></dt>
<dd><p>Set border treatment mode.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.upperLeft">
<tt class="descname">upperLeft</tt><big>(</big><em>(Kernel2D)arg1</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.Kernel2D.upperLeft" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper left border of kernel (inclusive).</p>
</dd></dl>

<dl class="method">
<dt id="vigra.filters.Kernel2D.width">
<tt class="descname">width</tt><big>(</big><em>(Kernel2D)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.filters.Kernel2D.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Horizontal kernel size (lowerRight()[0] - upperLeft()[0] + 1).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="vigra.filters.boundaryDistanceTransform">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">boundaryDistanceTransform</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(bool)array_border_is_active=False</em><span class="optional">[</span>, <em>(str)boundary='InterpixelBoundary'</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.boundaryDistanceTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Euclidean distance transform of all regions in a 2D or 3D label
array with respect to the region boundaries. The &#8216;boundary&#8217; parameter must be
one of the following strings:</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;OuterBoundary&#8217;:  compute distance relative to outer regin boundaries</li>
<li>&#8216;InterpixelBoundary&#8217;:  compute distance relative to interpixel boundaries (default)</li>
<li>&#8216;InnerBoundary&#8217;:  compute distance relative to inner region boundaries</li>
</ul>
</div></blockquote>
<p>where the outer boundary consists of the pixels touching a given region from the
outside and the inner boundary are the pixels adjacent to the region&#8217;s complement.
If &#8216;array_border_is_active=True&#8217;, the external border of the array (i.e. the border
between the image and the infinite region) is also used. Otherwise (default), regions
touching the array border are treated as if they extended to infinity.</p>
<p>For more details see <a class="reference external" href="../../doc/vigra/group__DistanceTransform.html#gab0634e492b477c15190a9f2207e8adb8">boundaryMultiDistance</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.boundaryTensor2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">boundaryTensor2D</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.boundaryTensor2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the boundary tensor for a scalar valued 2D image.For details see <a class="reference external" href="../../doc/vigra/group__TensorImaging.html#gab4ee0f19130a109119cc9cbc594ed1b7">boundaryTensor</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.boundaryVectorDistanceTransform">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">boundaryVectorDistanceTransform</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(bool)array_border_is_active=False</em><span class="optional">[</span>, <em>(str)boundary='InterpixelBoundary'</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.boundaryVectorDistanceTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Euclidean distance transform of all regions in a 2D or 3D label
array with respect to the region boundaries and return, in each pixel,
the difference vector to the nearest boundary point.
The &#8216;boundary&#8217; parameter must be one of the following strings:</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;OuterBoundary&#8217;:  compute distance relative to outer regin boundaries</li>
<li>&#8216;InterpixelBoundary&#8217;:  compute distance relative to interpixel boundaries (default)</li>
<li>&#8216;InnerBoundary&#8217;:  compute distance relative to inner region boundaries</li>
</ul>
</div></blockquote>
<p>where the outer boundary consists of the pixels touching a given region from the
outside and the inner boundary are the pixels adjacent to the region&#8217;s complement.
If &#8216;array_border_is_active=True&#8217;, the external border of the array (i.e. the border
between the image and the infinite region) is also used. Otherwise (default), regions
touching the array border are treated as if they extended to infinity.</p>
<p>For more details see <a class="reference internal" href="#vigra.filters.boundaryDistanceTransform" title="vigra.filters.boundaryDistanceTransform"><tt class="xref py py-func docutils literal"><span class="pre">boundaryDistanceTransform()</span></tt></a> and <a class="reference external" href="../../doc/vigra/group__DistanceTransform.html#ga62f0423aa51555c5cb0b5492084c1d4f">boundaryVectorDistance</a> in
the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.convolve">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">convolve</tt><big>(</big><em>(ndarray)array</em>, <em>kernel</em><span class="optional">[</span>, <em>(ndarray)out=None</em><span class="optional">]</span><big>)</big> &rarr; ndarray<a class="headerlink" href="#vigra.filters.convolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolve an array (up to 5D) with the given &#8216;kernel&#8217; (or kernels).
If the input has multiple channels, the filter is applied to each channel
independently. The function can be used in 3 different ways:</p>
<ul class="simple">
<li>When &#8216;kernel&#8217; is a single object of type <a class="reference internal" href="#vigra.filters.Kernel1D" title="vigra.filters.Kernel1D"><tt class="xref py py-class docutils literal"><span class="pre">Kernel1D</span></tt></a>, this kernel
is applied along all spatial dimensions of the data (separable filtering).</li>
<li>When &#8216;kernel&#8217; is a tuple of <a class="reference internal" href="#vigra.filters.Kernel1D" title="vigra.filters.Kernel1D"><tt class="xref py py-class docutils literal"><span class="pre">Kernel1D</span></tt></a> objects, a different kernel
is used for each spatial dimension (separable filtering). The number of
kernels must equal the number of dimensions.</li>
<li>When &#8216;kernel&#8217; is an instance of <a class="reference internal" href="#vigra.filters.Kernel2D" title="vigra.filters.Kernel2D"><tt class="xref py py-class docutils literal"><span class="pre">Kernel2D</span></tt></a>, a 2-dimensional convolution
is performed (non-separable filtering). This is only applicable to 2D arrays.</li>
</ul>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a> and <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.convolveOneDimension">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">convolveOneDimension</tt><big>(</big><em>(object)array</em>, <em>(int)dim</em>, <em>(Kernel1D)kernel</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.convolveOneDimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolve a single dimension of a scalar or multiband array with up to five dimensions.
&#8216;dim&#8217; denotes the dimension to be convolved.
&#8216;kernel&#8217; must be an instance of Kernel1D.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discClosing">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discClosing</tt><big>(</big><em>(object)image</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discClosing" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a closing filter with disc of given radius to image.</p>
<p>This is an abbreviation for applying a dilation and an erosion  filter in sequence. This function also works for multiband images, it is then executed on every band.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Morphology.html#gac7b008c2289213251fe917f8855f9667">discRankOrderFilter</a> in the C++ documentation for more information.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discDilation">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discDilation</tt><big>(</big><em>(object)image</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discDilation" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply dilation (maximum) filter with disc of given radius to image.</p>
<p>This is an abbreviation for the rank order filter with rank = 1.0. This function also works for multiband images, it is then executed on every band.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Morphology.html#gaa6b2b4e1d0fab80e25aa7bb349ac3da3">discDilation</a> in the C++ documentation for more information.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discErosion">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discErosion</tt><big>(</big><em>(object)image</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discErosion" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply erosion (minimum) filter with disc of given radius to image.</p>
<p>This is an abbreviation for the rank order filter with rank = 0.0. This function also works for multiband images, it is then executed on every band.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Morphology.html#gaeaa85e48818f2026b07cbac969cc2390">discErosion</a> in the C++ documentation for more information.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discMedian">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discMedian</tt><big>(</big><em>(object)image</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discMedian" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply median filter with disc of given radius to image.</p>
<p>This is an abbreviation for the rank order filter with rank = 0.5. This function also works for multiband images, it is then executed on every band.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Morphology.html#ga6f7f27916f6f43016aa268e8730be59b">discMedian</a> in the C++ documentation for more information.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discOpening">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discOpening</tt><big>(</big><em>(object)image</em>, <em>(int)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discOpening" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a opening filter with disc of given radius to image.</p>
<p>This is an abbreviation for applying an erosion and a dilation filter in sequence. This function also works for multiband images, it is then executed on every band.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Morphology.html#gac7b008c2289213251fe917f8855f9667">discRankOrderFilter</a> in the C++ documentation for more information.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discRankOrderFilter">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discRankOrderFilter</tt><big>(</big><em>(object)image</em>, <em>(int)radius</em>, <em>(float)rank</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discRankOrderFilter" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Apply rank order filter with disc structuring function to a float image.</p>
<p>The pixel values of the source image  must be in the range 0...255. Radius must be &gt;= 0. Rank must be in the range 0.0 &lt;= rank &lt;= 1.0. The filter acts as a minimum filter if rank = 0.0, as a median if rank = 0.5, and as a maximum filter if rank = 1.0. This function also works for multiband images, it is then executed on every band.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Morphology.html#gac7b008c2289213251fe917f8855f9667">discRankOrderFilter</a> in the C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>discRankOrderFilter( (object)image, (int)radius, (float)rank [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a uint8 image.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.discRankOrderFilterWithMask">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">discRankOrderFilterWithMask</tt><big>(</big><em>(object)image</em>, <em>(object)mask</em>, <em>(int)radius</em>, <em>(float)rank</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.discRankOrderFilterWithMask" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Apply rank order filter with disc structuring function to a float image using a mask.</p>
<p>The pixel values of the source image must be in the range 0...255. Radius must be &gt;= 0.Rank must be in the range 0.0 &lt;= rank &lt;= 1.0. The filter acts as a minimum filter if rank = 0.0,as a median if rank = 0.5, and as a maximum filter if rank = 1.0.</p>
<p>The mask is only applied to the input image, i.e. the function generates an output wherever the current disc contains at least one pixel with non-zero mask value. Source pixels with mask value zero are ignored during the calculation of the rank order.</p>
<p>This function also works for multiband images, it is then executed on every band. If the mask has only one band, it is used for every image band. If the mask has the same number of bands, as the image the bands are used for the corresponding image bands.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Morphology.html#gad40782f8126b8b9b4a009fe8d8ddaaa3">discRankOrderFilterWithMask</a> in the C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>discRankOrderFilterWithMask( (object)image, (object)mask, (int)radius, (float)rank [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a uint8 image.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.distanceTransform">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">distanceTransform</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(bool)background=True</em><span class="optional">[</span>, <em>(object)pixel_pitch=()</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.distanceTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Euclidean distance transform of a scalar array (up to 3D).</p>
<p>All pixels with a value of 0.0 are considered background,
while all pixels with a nonzero value are considered foreground.
The parameter &#8216;background&#8217; is a Boolean scalar that specifies whether to
compute the distance of all background pixels to the nearest foreground pixel
(if it is &#8216;True&#8217;, default) or vice versa (if it is &#8216;False&#8217;).
Hence in the destination array, for background==True all background elements
will be assigned their distance value, while all foreground elements will be assigned 0.
For background==False, it is exactly the other way around.</p>
<p>If &#8216;pixel_pitch&#8217; is given, it must contain the pixel distance along the three axes.
They are then used to compute the distance anisotropically. If no &#8216;pixel_pitch&#8217; is
given, the data is treated isotropically with unit distance between pixels.</p>
<p>For more details see <a class="reference external" href="../../doc/vigra/group__DistanceTransform.html#gac5b055757926655498f70c6253761e27">separableMultiDistance</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.distanceTransform2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">distanceTransform2D</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(bool)background=True</em><span class="optional">[</span>, <em>(int)norm=2</em><span class="optional">[</span>, <em>(object)pixel_pitch=()</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.distanceTransform2D" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Compute the distance transform of a 2D scalar float image.
All pixels with a value of 0.0 are considered to be background pixels,
while all pixels with a nonzero value are considered to be foreground pixels.
The parameter &#8216;background&#8217; is a Boolean scalar that specifies whether to
compute the distance of all background pixels to the nearest foreground pixels
(if it is &#8216;True&#8217;, default) or vice versa (if it is &#8216;False&#8217;).
Hence in the destination image, for background==True all background pixels
will be assigned their distance value, while all foreground pixels will be assigned 0.
For background==False, it is exactly the other way around.</p>
<p>The &#8216;norm&#8217; parameter gives the distance norm to use
(0: infinity norm, 1: L1 norm, 2: Euclidean norm).</p>
<p>If &#8216;pixel_pitch&#8217; is given, it must contain the pixel distance along the two axes.
They are then used to compute the distance anisotropically. If no &#8216;pixel_pitch&#8217; is
given, the data is treated isotropically with unit distance between pixels.
The anisotropic distance transform is only supported for norm =2 (Euclidean).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__DistanceTransform.html#gad481d272471bfa808196959dffca524b">distanceTransform</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>distanceTransform2D( (object)image [, (bool)background=True [, (int)norm=2 [, (object)pixel_pitch=() [, (object)out=None]]]]) -&gt; object :</dt>
<dd>Likewise for a 2D uint8 input array.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.eccentricityCenters">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">eccentricityCenters</tt><big>(</big><em>(object)array</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.filters.eccentricityCenters" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a list holding the eccentricity center of each region in
a label array (2D or 3D).</p>
<p>For more details see <a class="reference external" href="../../doc/vigra/group__DistanceTransform.html#ga6b5271edf6c5b6ed1be8eeea39fe5509">eccentricityCenters</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.eccentricityTransform">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">eccentricityTransform</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.eccentricityTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the eccentricity transform of a label array (2D or 3D).</p>
<p>For more details see <a class="reference external" href="../../doc/vigra/group__DistanceTransform.html#ga2306412b94a0f57e35c9f38bc99a70b0">eccentricityTransformOnLabels</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.eccentricityTransformWithCenters">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">eccentricityTransformWithCenters</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; tuple :<a class="headerlink" href="#vigra.filters.eccentricityTransformWithCenters" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the eccentricity transform and eccentricity centers of a label array (2D and 3D).</p>
<p>Returns the tuple (ecc_image, centers). See <a class="reference internal" href="#vigra.filters.eccentricityTransform" title="vigra.filters.eccentricityTransform"><tt class="xref py py-func docutils literal"><span class="pre">eccentricityTransform()</span></tt></a> and
<a class="reference internal" href="#vigra.filters.eccentricityCenters" title="vigra.filters.eccentricityCenters"><tt class="xref py py-func docutils literal"><span class="pre">eccentricityCenters()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.gaussianDerivative">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">gaussianDerivative</tt><big>(</big><em>array</em>, <em>sigma</em>, <em>orders</em>, <em>out=None</em>, <em>window_size=0.0</em><big>)</big><a class="headerlink" href="#vigra.filters.gaussianDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolve &#8216;array&#8217; with a Gaussian derivate kernel of the given &#8216;orders&#8217;.
&#8216;orders&#8217; must contain a list of integers &gt;= 0 for each non-channel axis.
Each channel of the array is treated independently. If &#8216;sigma&#8217; is a single
value, the kernel size is equal in each dimension. If &#8216;sigma&#8217; is a tuple
or list of values of appropriate length, a different size is used for each axis.</p>
<p>&#8216;window_size&#8217; specifies the ratio between the filter scale and the size of
the filter window. Use values around 2.0 to speed-up the computation for the
price of increased cut-off error, and values &gt;= 4.0 for very accurate results.
The window size is automatically determined for the default value 0.0.</p>
<p>For the first and second derivatives, you can also use <a class="reference internal" href="#vigra.filters.gaussianGradient" title="vigra.filters.gaussianGradient"><tt class="xref py py-func docutils literal"><span class="pre">gaussianGradient()</span></tt></a>
and <a class="reference internal" href="#vigra.filters.hessianOfGaussian" title="vigra.filters.hessianOfGaussian"><tt class="xref py py-func docutils literal"><span class="pre">hessianOfGaussian()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.gaussianDivergence">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">gaussianDivergence</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(object)scale=1.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.gaussianDivergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the divergence of a 2D or 3D vector field with a first
derivative of Gaussian at the given scale. The array must have
as many channels as spatial dimensions.</p>
<p>If &#8216;sigma&#8217; is a single value, an isotropic filter at this scale is
applied (i.e., each dimension is filtered in the same way).
If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing
will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the PSF
standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple,
or list) the distance between two adjacent pixels for each dimension.
The length of the tuples or lists must be equal to the number of spatial
dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.gaussianGradient">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">gaussianGradient</tt><big>(</big><em>(object)array</em>, <em>(object)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.gaussianGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the gradient vector by means of a 1st derivative of
Gaussian filter at the given scale for a scalar array (up to 4D).</p>
<p>If &#8216;sigma&#8217; is a single value, an isotropic filter at this scale is
applied (i.e., each dimension is filtered in the same way).
If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing
will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the PSF
standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple,
or list) the distance between two adjacent pixels for each dimension.
The length of the tuples or lists must be equal to the number of spatial
dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.gaussianGradientMagnitude">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">gaussianGradientMagnitude</tt><big>(</big><em>(object)array</em>, <em>(object)sigma</em><span class="optional">[</span>, <em>(bool)accumulate=True</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.gaussianGradientMagnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the gradient magnitude by means of a 1st derivative of
Gaussian filter at the given scale for a scalar or multiband array
with up to 5 dimensions.</p>
<p>If &#8216;accumulate&#8217; is True (the default), the gradients are accumulated
(in the L2-norm sense) over all channels of a multi-channel array.
Otherwise, a separate gradient magnitude is computed for each channel.</p>
<p>If &#8216;sigma&#8217; is a single value, an isotropic filter at this scale is
applied (i.e., each dimension is filtered in the same way).
If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing
will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the PSF
standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple,
or list) the distance between two adjacent pixels for each dimension.
The length of the tuples or lists must be equal to the number of spatial
dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.gaussianSharpening2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">gaussianSharpening2D</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)sharpeningFactor=1.0</em><span class="optional">[</span>, <em>(float)scale=1.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.gaussianSharpening2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sharpening function with gaussian filter.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#gaca082340d8a747dd9784e2b896db9a30">gaussianSharpening</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.gaussianSmoothing">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">gaussianSmoothing</tt><big>(</big><em>(object)array</em>, <em>(object)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.gaussianSmoothing" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Gaussian smoothing of an array with up to five dimensions.</p>
<p>If the array has multiple channels, each channel is smoothed independently.</p>
<p>If &#8216;sigma&#8217; is a single value, an isotropic filter at this scale is
applied (i.e., each dimension is filtered in the same way).
If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing
will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the PSF
standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple,
or list) the distance between two adjacent pixels for each dimension.
The length of the tuples or lists must be equal to the number of spatial
dimensions.</p>
<p>&#8216;window_size&#8217; specifies the ratio between the effective filter scale and
the size of the filter window. Use a value around 2.0 to speed-up
the computation by increasing the error resulting from cutting off the Gaussian.
For the default 0.0, the window size is automatically determined.</p>
<p>If &#8216;roi&#8217; is not None, it must specify the desired region-of-interest as
a pair &#8216;(first_point, beyond_last_point)&#8217; (e.g. &#8216;roi=((10,20), (200,250))&#8217;).
As usual, the second point is the first point outside the ROI, and the ROI
must not be outside the input array dimensions.
The coordinates refer only to non-channel axes - if your array has an explicit
channel axis, the ROI dimension must be one less than the array dimension.
If you pass in an explicit &#8216;out&#8217; array and specify an ROI, the &#8216;out&#8217; array
must have the shape of the ROI.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113">gaussianSmoothing</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.hessianOfGaussian">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">hessianOfGaussian</tt><big>(</big><em>(object)array</em>, <em>(object)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.hessianOfGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Hessian matrix by means of 2nd derivative of Gaussian
filters at the given scale for scalar arrays up to 4D.
The result has N*(N+1)/2 channels representing the flattened upper
triangular part of the Hessian (N is the dimension of the input).</p>
<p>If &#8216;sigma&#8217; is a single value, an isotropic filter at this scale is
applied (i.e., each dimension is filtered in the same way).
If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing
will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the PSF
standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple,
or list) the distance between two adjacent pixels for each dimension.
The length of the tuples or lists must be equal to the number of spatial
dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.hessianOfGaussianEigenvalues">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">hessianOfGaussianEigenvalues</tt><big>(</big><em>image</em>, <em>scale</em>, <em>out=None</em>, <em>sigma_d=0.0</em>, <em>step_size=1.0</em>, <em>window_size=0.0</em>, <em>roi=None</em><big>)</big><a class="headerlink" href="#vigra.filters.hessianOfGaussianEigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the eigenvalues of the Hessian of Gaussian at the given scale
for a scalar image or volume.</p>
<p>Calls <a class="reference internal" href="#vigra.filters.hessianOfGaussian" title="vigra.filters.hessianOfGaussian"><tt class="xref py py-func docutils literal"><span class="pre">hessianOfGaussian()</span></tt></a> and <a class="reference internal" href="#vigra.filters.tensorEigenvalues" title="vigra.filters.tensorEigenvalues"><tt class="xref py py-func docutils literal"><span class="pre">tensorEigenvalues()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.hourGlassFilter2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">hourGlassFilter2D</tt><big>(</big><em>(object)image</em>, <em>(float)sigma</em>, <em>(float)rho</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.hourGlassFilter2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Anisotropic tensor smoothing with the hourglass filter.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__TensorImaging.html#gae34b2f441aa2b256574ae43dc2991294">hourGlassFilter</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.laplacianOfGaussian">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">laplacianOfGaussian</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(object)scale=1.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.laplacianOfGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter a 2D or 3D scalar array with the Laplacian of Gaussian operator
at the given scale. Multiple channels are filtered independently.</p>
<p>If &#8216;sigma&#8217; is a single value, an isotropic filter at this scale is
applied (i.e., each dimension is filtered in the same way).
If &#8216;sigma&#8217; is a tuple or list of values, the amount of smoothing
will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the PSF
standard deviation per axis, the optional &#8216;step_size&#8217; (single, tuple,
or list) the distance between two adjacent pixels for each dimension.
The length of the tuples or lists must be equal to the number of spatial
dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiBinaryClosing">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiBinaryClosing</tt><big>(</big><em>(object)array</em>, <em>(float)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiBinaryClosing" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary closing on a scalar or multiband array (up to 3D, uint8 or bool).
Multiple channels are treated independently.</p>
<p>This function applies a flat circular closing operator (sequential dilation
and erosion) with a given radius. The operation is isotropic. The input is a
uint8 or boolean multi-dimensional array where non-zero elements represent
foreground and zero elements represent background.</p>
<p>For details see vigra C++ documentation (<a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#ga601e8a57c988253d39576c2a95e38ee5">multiBinaryDilation</a> and <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#gab108c6fbf1d13b3f37a43527529c196b">multiBinaryErosion</a>).</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiBinaryDilation">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiBinaryDilation</tt><big>(</big><em>(object)array</em>, <em>(float)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiBinaryDilation" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary dilation on a scalar or multiband array (up to 3D, uint8 or bool).
Multiple channels are treated independently.</p>
<p>This function applies a flat circular dilation operator with a given radius.
The operation is isotropic. The input is a uint8 or boolean multi-dimensional
array where non-zero elements represent foreground and zero elements represent
background.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#ga601e8a57c988253d39576c2a95e38ee5">multiBinaryDilation</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiBinaryErosion">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiBinaryErosion</tt><big>(</big><em>(object)array</em>, <em>(float)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiBinaryErosion" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary erosion on a scalar or multiband array (up to 3D, uint8 or bool).
Multiple channels are treated independently.</p>
<p>This function applies a flat circular erosion operator with a given radius.
The operation is isotropic. The input is a uint8 or boolean multi-dimensional
array where non-zero elements represent foreground and zero elements represent
background.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#gab108c6fbf1d13b3f37a43527529c196b">multiBinaryErosion</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiBinaryOpening">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiBinaryOpening</tt><big>(</big><em>(object)array</em>, <em>(float)radius</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiBinaryOpening" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary opening on a scalar or multiband array (up to 3D, uint8 or bool).
Multiple channels are treated independently.</p>
<p>This function applies a flat circular opening operator (sequential erosion
and dilation) with a given radius. The operation is isotropic. The input is a
uint8 or boolean multi-dimensional array where non-zero elements represent
foreground and zero elements represent background.</p>
<p>For details see vigra C++ documentation (<a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#ga601e8a57c988253d39576c2a95e38ee5">multiBinaryDilation</a> and <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#gab108c6fbf1d13b3f37a43527529c196b">multiBinaryErosion</a>).</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiGrayscaleClosing">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiGrayscaleClosing</tt><big>(</big><em>(object)array</em>, <em>(float)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiGrayscaleClosing" title="Permalink to this definition">¶</a></dt>
<dd><p>Parabolic grayscale closing on a scalar or multiband array (up to 3D).
Multiple channels are treated independently.</p>
<p>This function applies a parabolic closing (sequential dilation and erosion)
operator with a given spread &#8216;sigma&#8217; on a grayscale array. The operation is
isotropic.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#ga1075198bb23aafabb017b2eae2ed5670">multiGrayscaleDilation</a> and <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#gae4c9408742bbc670b23817d716279ab3">multiGrayscaleErosion</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiGrayscaleDilation">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiGrayscaleDilation</tt><big>(</big><em>(object)array</em>, <em>(float)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiGrayscaleDilation" title="Permalink to this definition">¶</a></dt>
<dd><p>Parabolic grayscale dilation on a scalar or multiband array (up to 3D).
Multiple channels are treated independently.</p>
<p>This function applies a parabolic dilation operator with a given spread &#8216;sigma&#8217;
on a grayscale array. The operation is isotropic.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#ga1075198bb23aafabb017b2eae2ed5670">multiGrayscaleDilation</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiGrayscaleErosion">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiGrayscaleErosion</tt><big>(</big><em>(object)array</em>, <em>(float)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiGrayscaleErosion" title="Permalink to this definition">¶</a></dt>
<dd><p>Parabolic grayscale erosion on a scalar or multiband array (up to 3D).
Multiple channels are treated independently.</p>
<p>This function applies a parabolic erosion operator with a given spread &#8216;sigma&#8217;
on a grayscale array. The operation is isotropic.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#gae4c9408742bbc670b23817d716279ab3">multiGrayscaleErosion</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.multiGrayscaleOpening">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">multiGrayscaleOpening</tt><big>(</big><em>(object)array</em>, <em>(float)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.multiGrayscaleOpening" title="Permalink to this definition">¶</a></dt>
<dd><p>Parabolic grayscale opening on a scalar or multiband array (up to 3D).
Multiple channels are treated independently.</p>
<p>This function applies a parabolic opening (sequential erosion and dilation)
operator with a given spread &#8216;sigma&#8217; on a grayscale array. The operation is
isotropic.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#ga1075198bb23aafabb017b2eae2ed5670">multiGrayscaleDilation</a> and <a class="reference external" href="../../doc/vigra/group__MultiArrayMorphology.html#gae4c9408742bbc670b23817d716279ab3">multiGrayscaleErosion</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.nonLocalMean2d">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">nonLocalMean2d</tt><big>(</big><em>(object)image</em>, <em>(RatioPolicy)policy</em><span class="optional">[</span>, <em>(float)sigmaSpatial=2.0</em><span class="optional">[</span>, <em>(int)searchRadius=3</em><span class="optional">[</span>, <em>(int)patchRadius=1</em><span class="optional">[</span>, <em>(float)sigmaMean=1.0</em><span class="optional">[</span>, <em>(int)stepSize=2</em><span class="optional">[</span>, <em>(int)iterations=1</em><span class="optional">[</span>, <em>(int)nThreads=8</em><span class="optional">[</span>, <em>(bool)verbose=True</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.nonLocalMean2d" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>loop over an image and do something with each pixels</p>
<p>Args:</p>
<blockquote>
<div>image : input image</div></blockquote>
<p>returns an an image with the same shape as the input image</p>
</div></blockquote>
<dl class="docutils">
<dt>nonLocalMean2d( (object)image, (RatioPolicy)policy [, (float)sigmaSpatial=2.0 [, (int)searchRadius=3 [, (int)patchRadius=1 [, (float)sigmaMean=1.0 [, (int)stepSize=2 [, (int)iterations=1 [, (int)nThreads=8 [, (bool)verbose=True [, (object)out=None]]]]]]]]]) -&gt; object :</dt>
<dd><p class="first">loop over an image and do something with each pixels</p>
<p>Args:</p>
<blockquote>
<div>image : input image</div></blockquote>
<p class="last">returns an an image with the same shape as the input image</p>
</dd>
<dt>nonLocalMean2d( (object)image, (NormPolicy)policy [, (float)sigmaSpatial=2.0 [, (int)searchRadius=3 [, (int)patchRadius=1 [, (float)sigmaMean=1.0 [, (int)stepSize=2 [, (int)iterations=1 [, (int)nThreads=8 [, (bool)verbose=True [, (object)out=None]]]]]]]]]) -&gt; object :</dt>
<dd><p class="first">loop over an image and do something with each pixels</p>
<p>Args:</p>
<blockquote>
<div>image : input image</div></blockquote>
<p class="last">returns an an image with the same shape as the input image</p>
</dd>
<dt>nonLocalMean2d( (object)image, (NormPolicy)policy [, (float)sigmaSpatial=2.0 [, (int)searchRadius=3 [, (int)patchRadius=1 [, (float)sigmaMean=1.0 [, (int)stepSize=2 [, (int)iterations=1 [, (int)nThreads=8 [, (bool)verbose=True [, (object)out=None]]]]]]]]]) -&gt; object :</dt>
<dd><p class="first">loop over an image and do something with each pixels</p>
<p>Args:</p>
<blockquote>
<div>image : input image</div></blockquote>
<p class="last">returns an an image with the same shape as the input image</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.nonLocalMean3d">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">nonLocalMean3d</tt><big>(</big><em>(object)image</em>, <em>(RatioPolicy)policy</em><span class="optional">[</span>, <em>(float)sigmaSpatial=2.0</em><span class="optional">[</span>, <em>(int)searchRadius=3</em><span class="optional">[</span>, <em>(int)patchRadius=1</em><span class="optional">[</span>, <em>(float)sigmaMean=1.0</em><span class="optional">[</span>, <em>(int)stepSize=2</em><span class="optional">[</span>, <em>(int)iterations=1</em><span class="optional">[</span>, <em>(int)nThreads=8</em><span class="optional">[</span>, <em>(bool)verbose=True</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.nonLocalMean3d" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>loop over an image and do something with each pixels</p>
<p>Args:</p>
<blockquote>
<div>image : input image</div></blockquote>
<p>returns an an image with the same shape as the input image</p>
</div></blockquote>
<dl class="docutils">
<dt>nonLocalMean3d( (object)image, (NormPolicy)policy [, (float)sigmaSpatial=2.0 [, (int)searchRadius=3 [, (int)patchRadius=1 [, (float)sigmaMean=1.0 [, (int)stepSize=2 [, (int)iterations=1 [, (int)nThreads=8 [, (bool)verbose=True [, (object)out=None]]]]]]]]]) -&gt; object :</dt>
<dd><p class="first">loop over an image and do something with each pixels</p>
<p>Args:</p>
<blockquote>
<div>image : input image</div></blockquote>
<p class="last">returns an an image with the same shape as the input image</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.nonLocalMean4d">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">nonLocalMean4d</tt><big>(</big><em>(object)image</em>, <em>(RatioPolicy)policy</em><span class="optional">[</span>, <em>(float)sigmaSpatial=2.0</em><span class="optional">[</span>, <em>(int)searchRadius=3</em><span class="optional">[</span>, <em>(int)patchRadius=1</em><span class="optional">[</span>, <em>(float)sigmaMean=1.0</em><span class="optional">[</span>, <em>(int)stepSize=2</em><span class="optional">[</span>, <em>(int)iterations=1</em><span class="optional">[</span>, <em>(int)nThreads=8</em><span class="optional">[</span>, <em>(bool)verbose=True</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.nonLocalMean4d" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>loop over an image and do something with each pixels</p>
<p>Args:</p>
<blockquote>
<div>image : input image</div></blockquote>
<p>returns an an image with the same shape as the input image</p>
</div></blockquote>
<dl class="docutils">
<dt>nonLocalMean4d( (object)image, (NormPolicy)policy [, (float)sigmaSpatial=2.0 [, (int)searchRadius=3 [, (int)patchRadius=1 [, (float)sigmaMean=1.0 [, (int)stepSize=2 [, (int)iterations=1 [, (int)nThreads=8 [, (bool)verbose=True [, (object)out=None]]]]]]]]]) -&gt; object :</dt>
<dd><p class="first">loop over an image and do something with each pixels</p>
<p>Args:</p>
<blockquote>
<div>image : input image</div></blockquote>
<p class="last">returns an an image with the same shape as the input image</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.nonlinearDiffusion">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">nonlinearDiffusion</tt><big>(</big><em>(object)image</em>, <em>(float)edgeThreshold</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.nonlinearDiffusion" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform edge-preserving smoothing at the given scale.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__NonLinearDiffusion.html#ga682a281ec8f2abbf2e3b18aaa7753c60">nonlinearDiffusion</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.normalizedConvolveImage">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">normalizedConvolveImage</tt><big>(</big><em>(object)image</em>, <em>(object)mask</em>, <em>(Kernel2D)kernel</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.normalizedConvolveImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform normalized convolution of an image. If the image has multiple channels, every channel is convolved independently. The &#8216;mask&#8217; tells the algorithm whether input pixels are valid (non-zero mask value) or not. Invalid pixels are ignored in the convolution. The mask must have one channel (which is then used for all channels input channels) or as many channels as the input image.</p>
<p>For details, see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#ga69ac94967f6044203ebb85d84cc51b84">normalizedConvolveImage</a> in the C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.radialSymmetryTransform2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">radialSymmetryTransform2D</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.radialSymmetryTransform2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Find centers of radial symmetry in an 2D image.</p>
<p>This algorithm implements the Fast Radial Symmetry Transform according to [G. Loy, A. Zelinsky: &#8220;A Fast Radial Symmetry Transform for Detecting Points of Interest&#8221;, in: A. Heyden et al. (Eds.): Proc. of 7th European Conf. on Computer Vision, Part 1, pp. 358-368, Springer LNCS 2350, 2002]</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__SymmetryDetection.html#ga5ea9947261f0d49f92521e9f3ca38ee0">radialSymmetryTransform</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.recursiveFilter2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">recursiveFilter2D</tt><big>(</big><em>(object)image</em>, <em>(float)b</em><span class="optional">[</span>, <em>(BorderTreatmentMode)borderTreament=vigra.filters.BorderTreatmentMode.BORDER_TREATMENT_REFLECT</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.recursiveFilter2D" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Perform 2D convolution with a first-order recursive filter with parameter &#8216;b&#8217; and given &#8216;borderTreatment&#8217;. &#8216;b&#8217; must be between -1 and 1.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gaf634b87803c602b9f3f34e670119f035">recursiveFilterX</a> and <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gaa2197533a4dc993998f89641f61015cb">recursiveFilterY</a> (which this function calls in succession) in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>recursiveFilter2D( (object)image, (float)b1, (float)b2 [, (object)out=None]) -&gt; object :</dt>
<dd><p class="first">Perform 2D convolution with a second-order recursive filter with parameters &#8216;b1&#8217; and &#8216;b2&#8217;. Border treatment is always BORDER_TREATMENT_REFLECT.</p>
<p class="last">For details see <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gaf634b87803c602b9f3f34e670119f035">recursiveFilterX</a> and <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gaa2197533a4dc993998f89641f61015cb">recursiveFilterY</a> (which this function calls in succession) in the vigra C++ documentation.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.recursiveGaussianSmoothing2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">recursiveGaussianSmoothing2D</tt><big>(</big><em>(object)image</em>, <em>(tuple)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.recursiveGaussianSmoothing2D" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Compute a fast approximate Gaussian smoothing of a 2D scalar or multiband image.</p>
<p>This function uses the third-order recursive filter approximation to the Gaussian filter proposed by Young and van Vliet. Each channel of the array is smoothed independently. If &#8216;sigma&#8217; is a single value, an isotropic Gaussian filter at this scale is applied (i.e. each dimension is smoothed in the same way). If &#8216;sigma&#8217; is a tuple of values, the amount of smoothing will be different for each spatial dimension. The length of the tuple must be equal to the number of spatial dimensions.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gac3b0b8f9de1d4349523c013e86f7d87b">recursiveGaussianFilterLine</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>recursiveGaussianSmoothing2D( (object)image, (float)sigma [, (object)out=None]) -&gt; object :</dt>
<dd>Compute isotropic fast approximate Gaussian smoothing.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.recursiveGradient2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">recursiveGradient2D</tt><big>(</big><em>(object)arg1</em>, <em>(float)image</em>, <em>(BorderTreatmentMode)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.recursiveGradient2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gradient of a scalar image using a recursive (exponential) filter at the given &#8216;scale&#8217;. The output image (if given) must have two channels.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gad82fca7f8ede53725047c44b4715f9a8">recursiveSmoothLine</a> and <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#ga60a94e16526f93f19d0cee9cf6bb9343">recursiveFirstDerivativeLine</a> (which this function calls internally) in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.recursiveLaplacian2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">recursiveLaplacian2D</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.recursiveLaplacian2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the gradient of a 2D scalar or multiband image using a recursive (exponential) filter at the given &#8216;scale&#8217;. The output image (if given) must have as many channels as the input.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gad82fca7f8ede53725047c44b4715f9a8">recursiveSmoothLine</a> and <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#ga514cd0d70fc617cfea89b9dcb779ea18">recursiveSecondDerivativeLine</a> (which this function calls internally) in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.recursiveSmooth2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">recursiveSmooth2D</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(BorderTreatmentMode)borderTreament=vigra.filters.BorderTreatmentMode.BORDER_TREATMENT_REFLECT</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.recursiveSmooth2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls recursiveFilter2D() with b = exp(-1/scale), which corresponds to smoothing with an exponential filter exp(-abs(x)/scale).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__RecursiveConvolution.html#gad82fca7f8ede53725047c44b4715f9a8">recursiveSmoothLine</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.rieszTransformOfLOG2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">rieszTransformOfLOG2D</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em>, <em>(int)xorder</em>, <em>(int)yorder</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.rieszTransformOfLOG2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Riesz transforms of the Laplacian of Gaussian.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#ga1725cf1cffa836093e343d85ed6cc684">rieszTransformOfLOG</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.shockFilter">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">shockFilter</tt><big>(</big><em>(object)image</em>, <em>(float)sigma</em>, <em>(float)rho</em>, <em>(float)updwindFactorH</em>, <em>(int)iterations</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.shockFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform edge-preserving smoothing at the given scale.</p>
<p>For details see <a href="#id103"><span class="problematic" id="id104">shockFilter_</span></a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.simpleSharpening2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">simpleSharpening2D</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)sharpeningFactor=1.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.simpleSharpening2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform simple sharpening function.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#ga036bfcbd28303db0c41d32d292af3bb3">simpleSharpening</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.skeletonizeImage">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">skeletonizeImage</tt><big>(</big><em>(object)labels</em><span class="optional">[</span>, <em>(str)mode='PruneSalienceRelative'</em><span class="optional">[</span>, <em>(float)pruning_threshold=0.2</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.skeletonizeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Skeletonize all regions in the given label image. Each skeleton receives
the label of the corresponding region, unless &#8216;length&#8217; or &#8216;salience&#8217; are
requested, in which case the skeleton points hold real numbers. Non-skeleton
points always have the value zero. When the input image contains label zero,
it is always considered background and therefore ignored.
The &#8216;mode&#8217; must be one of the following strings:</p>
<blockquote>
<div><ul>
<li><p class="first">&#8216;DontPrune&#8217;:  don&#8217;t remove any branches</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;ReturnLength&#8217;:  mark each pixel with the length of the longest branch</dt>
<dd><p class="first last">it belongs to</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;PruneLength&#8217;:  remove all branches that are shorter than the given</dt>
<dd><p class="first last">&#8216;pruning_threshold&#8217;</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;PruneLengthRelative&#8217;:  remove all branches that are shorter than the</dt>
<dd><p class="first last">fraction specified in &#8216;pruning_threshold&#8217; of the
longest branch in the present region</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;ReturnSalience&#8217;:  mark each pixel with the salience of the longest branch</dt>
<dd><p class="first last">it belongs to</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;PruneSalience&#8217;:  remove all branches whose salience is less than the given</dt>
<dd><p class="first last">&#8216;pruning_threshold&#8217;</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;PruneSalienceRelative&#8217;:  remove all branches whose salience is less than the</dt>
<dd><p class="first last">fraction specified in &#8216;pruning_threshold&#8217; of the
most salient branch in the present region
(default with pruning_threshold=0.2)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;PruneTopology&#8217;:  prune all branches that are not essential for the topology,</dt>
<dd><p class="first last">but keep the skeleton center</p>
</dd>
</dl>
</li>
<li><p class="first">&#8216;PruneAggressive&#8217;:  like &#8216;PruneTopology&#8217;, but don&#8217;t necessarily preserve the center</p>
</li>
</ul>
</div></blockquote>
<p>For details see <a class="reference external" href="../../doc/vigra/group__DistanceTransform.html#gaf13e3ae513b5d88d86a1ef073325006b">skeletonizeImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.structureTensor">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">structureTensor</tt><big>(</big><em>(object)array</em>, <em>(object)innerScale</em>, <em>(object)outerScale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)sigma_d=0.0</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(float)window_size=0.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.structureTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the structure tensor of an array (up to 5D) by means of Gaussian
(derivative) filters at the given scales. If the input has multiple channels,
the structure tensors of each channel are added to get the result.
The result has N*(N+1)/2 channels representing the flattened upper
triangular part of the structure tensor (N is the dimension of the input).</p>
<p>If &#8216;innerScale&#8217; and &#8216;outerScale&#8217; are single values, isotropic filters at
these scales are applied (i.e., each dimension is filtered in the same way).
SIf &#8216;innerScale&#8217; and/or &#8216;outerScale&#8217; are are tuples or lists of values,
the amount of smoothing will be different for each spatial dimension.
The optional &#8216;sigma_d&#8217; (single, tuple, or list) denotes the PSF standard
deviation per axis, the optional &#8216;step_size&#8217; (single, tuple, or list) the
distance between two adjacent pixels for each dimension. The length of the
tuples or lists must be equal to the number of spatial dimensions.</p>
<p>&#8216;window_size&#8217; and &#8216;roi&#8217; have the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.structureTensorEigenvalues">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">structureTensorEigenvalues</tt><big>(</big><em>image</em>, <em>innerScale</em>, <em>outerScale</em>, <em>out=None</em>, <em>sigma_d=0.0</em>, <em>step_size=1.0</em>, <em>window_size=0.0</em>, <em>roi=None</em><big>)</big><a class="headerlink" href="#vigra.filters.structureTensorEigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the eigenvalues of the structure tensor at the given scales
for a scalar or multi-channel image or volume.</p>
<p>Calls <a class="reference internal" href="#vigra.filters.structureTensor" title="vigra.filters.structureTensor"><tt class="xref py py-func docutils literal"><span class="pre">structureTensor()</span></tt></a> and <a class="reference internal" href="#vigra.filters.tensorEigenvalues" title="vigra.filters.tensorEigenvalues"><tt class="xref py py-func docutils literal"><span class="pre">tensorEigenvalues()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.symmetricGradient">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">symmetricGradient</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">[</span>, <em>(object)step_size=1.0</em><span class="optional">[</span>, <em>(object)roi=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.symmetricGradient" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Calculate gradient of a scalar 2D image using symmetric difference filters.
The optional tuple or list &#8216;step_size&#8217; denotes the distance between two adjacent pixels for each dimension; its length must be equal to the number of spatial dimensions.</p>
<p>&#8216;roi&#8217; has the same meaning as in <a class="reference internal" href="#vigra.filters.gaussianSmoothing" title="vigra.filters.gaussianSmoothing"><tt class="xref py py-func docutils literal"><span class="pre">gaussianSmoothing()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__ConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1ConvolutionOptions.html">ConvolutionOptions</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>symmetricGradient( (object)volume [, (object)out=None [, (object)step_size=1.0 [, (object)roi=None]]]) -&gt; object :</dt>
<dd>Likewise for a 3D scalar volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.tensorDeterminant">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">tensorDeterminant</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.tensorDeterminant" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the elementwise determinant of an array which stores the flattened
upper triangular part of a symmetric tensor in each element (e.g. the
output of <a class="reference internal" href="#vigra.filters.structureTensor" title="vigra.filters.structureTensor"><tt class="xref py py-func docutils literal"><span class="pre">structureTensor()</span></tt></a>).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiPointoperators.html#ga50a97001588cdbec053d23d1d99079eb">tensorDeterminantMultiArray</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.tensorEigenRepresentation2D">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">tensorEigenRepresentation2D</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.tensorEigenRepresentation2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate eigen representation of a symmetric 2x2 tensor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__TensorImaging.html#gac6c6ac6dbf29130be5337bb4d4c4c250">tensorEigenRepresentation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.tensorEigenvalues">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">tensorEigenvalues</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.tensorEigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the eigenvalues in every element of an array which stores the
flattened upper triangular part of a symmetric tensor in each element
(e.g. the output of <a class="reference internal" href="#vigra.filters.structureTensor" title="vigra.filters.structureTensor"><tt class="xref py py-func docutils literal"><span class="pre">structureTensor()</span></tt></a>).
The result has as many channels (= eigenvalues) as the spatial dimension
of the input.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiPointoperators.html#gacc06f88a0cd7dcdb73f0c4af5b0e0312">tensorEigenvaluesMultiArray</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.tensorTrace">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">tensorTrace</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.tensorTrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the elementwise trace of an array which stores the flattened
upper triangular part of a symmetric tensor in each element (e.g. the
output of <a class="reference internal" href="#vigra.filters.structureTensor" title="vigra.filters.structureTensor"><tt class="xref py py-func docutils literal"><span class="pre">structureTensor()</span></tt></a>).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiPointoperators.html#ga0e407a39a189369be86f6e2a9a4a1415">tensorTraceMultiArray</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.totalVariationFilter">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">totalVariationFilter</tt><big>(</big><em>(object)image</em>, <em>(float)alpha</em>, <em>(int)steps</em>, <em>(float)eps</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.totalVariationFilter" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Perform total variation filter on 2D single band images.</p>
<p>For details see totalVariationFilter in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>totalVariationFilter( (object)image, (object)weight, (float)alpha, (int)steps, (float)eps [, (object)out=None]) -&gt; object :</dt>
<dd><p class="first">Perform weighted total variation filter on 2D single band images.</p>
<p class="last">For details see totalVariationFilter in the vigra C++ documentation.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.vectorDistanceTransform">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">vectorDistanceTransform</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(bool)background=True</em><span class="optional">[</span>, <em>(object)pixel_pitch=()</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.vectorDistanceTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Euclidean vector distance transform of a scalar array (up to 3D).
The function returns an array with a many channels as the input dimension.</p>
<p>In contrast to the plain distance transform, this function returns the difference
vector of each background pixel to the nearest foreground pixel (when
&#8216;background=True&#8217;, the default), or the other way around (when &#8216;background=False&#8217;).
Otherwise, this function behaves like <a class="reference internal" href="#vigra.filters.distanceTransform" title="vigra.filters.distanceTransform"><tt class="xref py py-func docutils literal"><span class="pre">distanceTransform()</span></tt></a> (which just
returns the magnitude of the difference vectors).</p>
<p>For more detailed documentation, see <a class="reference internal" href="#vigra.filters.distanceTransform2D" title="vigra.filters.distanceTransform2D"><tt class="xref py py-func docutils literal"><span class="pre">distanceTransform2D()</span></tt></a> and
<a class="reference external" href="../../doc/vigra/group__DistanceTransform.html#ga3e9ff9a7ff80b4c8ca39d90c258e2de7">separableVectorDistance</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.filters.vectorToTensor">
<tt class="descclassname">vigra.filters.</tt><tt class="descname">vectorToTensor</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.filters.vectorToTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn a vector valued 2D or 3D array (e.g. the gradient array) into a tensor array by computing the outer product in every pixel.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__MultiPointoperators.html#gad869b7b263b104e005a1ddc66b5c1f80">vectorToTensorMultiArray</a> in the vigra C++ documentation.</p>
</dd></dl>

</div>
<div class="section" id="sampling-image-resizing-and-image-pyramids">
<h2><a class="toc-backref" href="#id91">Sampling: Image Resizing and Image Pyramids</a><a class="headerlink" href="#sampling-image-resizing-and-image-pyramids" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.sampling contains methods to change the number and/or location of
the image sampling points, such as resizing, rotation, and interpolation.</p>
<span class="target" id="module-vigra.sampling"></span><dl class="function">
<dt id="vigra.sampling.resampleImage">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resampleImage</tt><big>(</big><em>(object)image</em>, <em>(float)factor</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resampleImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample an image by the given &#8216;factor&#8217;</p>
<p>The &#8216;out&#8217; parameter must have, if given, the according dimensions.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga823eb2815225a1fc8771c4138a5ccb1b">resampleImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resamplingGaussian">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resamplingGaussian</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)sigmaX=1.0</em><span class="optional">[</span>, <em>(int)derivativeOrderX=0</em><span class="optional">[</span>, <em>(float)samplingRatioX=2.0</em><span class="optional">[</span>, <em>(float)offsetX=0.0</em><span class="optional">[</span>, <em>(float)sigmaY=1.0</em><span class="optional">[</span>, <em>(int)derivativeOrderY=0</em><span class="optional">[</span>, <em>(float)samplingRatioY=2.0</em><span class="optional">[</span>, <em>(float)offsetY=0.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resamplingGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample image using a gaussian filter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">resamplingGaussian</span><span class="p">(</span><span class="n">image</span><span class="p">,</span>
                   <span class="n">sigmaX</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">derivativeOrderX</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">samplingRatioX</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">offsetX</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                   <span class="n">sigmaY</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">derivativeOrderY</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">samplingRatioY</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">offsetY</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                   <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<p>This function utilizes <a class="reference external" href="../../doc/vigra/group__ResamplingConvolutionFilters.html#gac820754f8e34277afa6f098a2d51303a">resamplingConvolveImage</a> with a Gaussianfilter
(see the vigra C++ documentation for details).</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resize">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resize</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(int)order=3</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resize" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Resize image or volume using B-spline interpolation.</p>
<p>The spline order is given in the parameter &#8216;order&#8217;.
The desired shape of the output array is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree. This function also works for multi-channel data, it is then executed on every channel independently.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga7c1095b357ec19b9edefa849a0a4d178">resizeImageSplineInterpolation</a> and <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga2cd9b31e7f0c8648bc0d9e1a8f1a3305">resizeMultiArraySplineInterpolation</a> in the vigra C++ documentation.</p>
</div></blockquote>
<p>resize( (object)image [, (object)shape=None [, (int)order=3 [, (object)out=None]]]) -&gt; object</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resizeImageCatmullRomInterpolation">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resizeImageCatmullRomInterpolation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resizeImageCatmullRomInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image using the Catmull/Rom interpolation function.</p>
<p>The desired shape of the output image is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga8c2f8475feaeaf94dcb5df8fd4679d30">resizeImageCatmullRomInterpolation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resizeImageCoscotInterpolation">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resizeImageCoscotInterpolation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resizeImageCoscotInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image using the Coscot interpolation function.</p>
<p>The desired shape of the output image is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga725f478e6b802647d77f19c528273947">resizeImageCoscotInterpolation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resizeImageLinearInterpolation">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resizeImageLinearInterpolation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resizeImageLinearInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image using linear interpolation.
The function uses the standard separable bilinear interpolation algorithm to obtain a good compromise between quality and speed.</p>
<p>The desired shape of the output image is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga5269b1cd9d82b394fa7cda279a42423b">resizeImageLinearInterpolation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resizeImageNoInterpolation">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resizeImageNoInterpolation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resizeImageNoInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image by repeating the nearest pixel values.</p>
<p>The desired shape of the output image is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#gaad7f1a2f1e089f2e29b486d81741c9f6">resizeImageNoInterpolation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resizeImageSplineInterpolation">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resizeImageSplineInterpolation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(int)order=3</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resizeImageSplineInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize image using B-spline interpolation.</p>
<p>The spline order is given in the parameter &#8216;order&#8217;.
The desired shape of the output image is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga7c1095b357ec19b9edefa849a0a4d178">resizeImageSplineInterpolation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.resizeVolumeSplineInterpolation">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">resizeVolumeSplineInterpolation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)shape=None</em><span class="optional">[</span>, <em>(int)order=3</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.resizeVolumeSplineInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize volume using B-spline interpolation.</p>
<p>The spline order is given in the parameter &#8216;order&#8217;.
The dimensions of the output volume is taken either from &#8216;shape&#8217; or &#8216;out&#8217;.
If both are given, they must agree.
This function also works for multiband volumes, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga2cd9b31e7f0c8648bc0d9e1a8f1a3305">resizeMultiArraySplineInterpolation</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.rotateImageDegree">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">rotateImageDegree</tt><big>(</big><em>(object)image</em>, <em>(float)degree</em><span class="optional">[</span>, <em>(RotationDirection)direction=vigra.sampling.RotationDirection.CLOCKWISE</em><span class="optional">[</span>, <em>(int)splineOrder=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.rotateImageDegree" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate an image by an arbitrary angle using splines for interpolation around its center.</p>
<p>The angle may be given in degree (parameter degree).
The parameter &#8216;splineOrder&#8217; indicates the order of the splines used for interpolation.
If the &#8216;out&#8217; parameter is given, the image is cropped for it&#8217;s dimensions. If the &#8216;out&#8217;
parameter is not given, an output image with the same dimensions as the input image is created.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#gacc7041b192dfb4a79de8d168abd495c9">GeometricTransformations.rotationMatrix2DDegrees</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.rotateImageRadiant">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">rotateImageRadiant</tt><big>(</big><em>(object)image</em>, <em>(float)radiant</em><span class="optional">[</span>, <em>(RotationDirection)direction=vigra.sampling.RotationDirection.CLOCKWISE</em><span class="optional">[</span>, <em>(int)splineOrder=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.rotateImageRadiant" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate an image by an arbitrary angle around its center using splines for interpolation.</p>
<p>The angle may be given in radiant (parameter radiant).
The parameter &#8216;splineOrder&#8217; indicates the order of the splines used for interpolation.
If the &#8216;out&#8217; parameter is given, the image is cropped for it&#8217;s dimensions. If the &#8216;out&#8217;
parameter is not given, an output image with the same dimensions as the input image is created.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#ga814c2b60d8b8579e159e939a76cd6db3">GeometricTransformations.rotationMatrix2DRadians</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.sampling.rotateImageSimple">
<tt class="descclassname">vigra.sampling.</tt><tt class="descname">rotateImageSimple</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(RotationDirection)orientation=vigra.sampling.RotationDirection.CLOCKWISE</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.rotateImageSimple" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate an image by a multiple of 90 degrees.</p>
<p>The &#8216;orientation&#8217; parameter (which must be one of CLOCKWISE, COUNTER_CLOCKWISE and UPSIDE_DOWN
indicates the rotation direction. The &#8216;out&#8217; parameter must, if given, have the according dimensions.
This function also works for multiband images, it is then executed on every band.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__GeometricTransformations.html#gaca913f155ee3de0d6c1177d953370f3a">rotateImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<hr class="docutils" />
<p>Spline image views implement an interpolated view for an image which can be accessed
at real-valued coordinates (in contrast to the plain image, which can only be
accessed at integer coordinates). Module vigra.sampling defines:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SplineImageView0</span>
<span class="n">SplineImageView1</span>
<span class="n">SplineImageView2</span>
<span class="n">SplineImageView3</span>
<span class="n">SplineImageView4</span>
<span class="n">SplineImageView5</span>
</pre></div>
</div>
<p>The number denotes the spline interpolation order of the respective classes.
Below, we describe SplineImageView3 in detail, but the other classes work
analogously. See <a class="reference external" href="../../doc/vigra/classvigra_1_1SplineImageView.html">SplineImageView</a> in the C++ documentation for more detailed information.</p>
<dl class="class">
<dt id="vigra.sampling.SplineImageView3">
<em class="property">class </em><tt class="descclassname">vigra.sampling.</tt><tt class="descname">SplineImageView3</tt><big>(</big><em>(object)arg1</em>, <em>(object)arg2</em><big>)</big><a class="headerlink" href="#vigra.sampling.SplineImageView3" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a SplineImageView for the given image:</p>
<div class="highlight-python"><div class="highlight"><pre>    SplineImageView(image, skipPrefilter = False)

Currently, &#39;image&#39; can have dtype numpy.uint8, numpy.int32, and numpy.float32. If &#39;skipPrefilter&#39; is True, image values are directly used as spline coefficients, so that the view performs approximation rather than interploation.
</pre></div>
</div>
<p>__init__( (object)arg1, (object)arg2) -&gt; object</p>
<p>__init__( (object)arg1, (object)arg2) -&gt; object</p>
<p>__init__( (object)arg1, (object)arg2, (bool)arg3) -&gt; object</p>
<p>__init__( (object)arg1, (object)arg2, (bool)arg3) -&gt; object</p>
<p>__init__( (object)arg1, (object)arg2, (bool)arg3) -&gt; object</p>
<dl class="method">
<dt id="vigra.sampling.SplineImageView3.coefficientImage">
<tt class="descname">coefficientImage</tt><big>(</big><em>(SplineImageView3)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.sampling.SplineImageView3.coefficientImage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dx">
<tt class="descname">dx</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return first derivative in x direction at a real-valued coordinate.</p>
<p>SplineImageView.dx(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dx3">
<tt class="descname">dx3</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dx3" title="Permalink to this definition">¶</a></dt>
<dd><p>Return third derivative in x direction at a real-valued coordinate.</p>
<p>SplineImageView.dx3(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dx3Image">
<tt class="descname">dx3Image</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dx3Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dx3" title="vigra.sampling.SplineImageView3.dx3"><tt class="xref py py-meth docutils literal"><span class="pre">dx3()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dx3Image(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxImage">
<tt class="descname">dxImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dx" title="vigra.sampling.SplineImageView3.dx"><tt class="xref py py-meth docutils literal"><span class="pre">dx()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dxImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxx">
<tt class="descname">dxx</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return second derivative in x direction at a real-valued coordinate.</p>
<p>SplineImageView.dxx(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxxImage">
<tt class="descname">dxxImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxxImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dxx" title="vigra.sampling.SplineImageView3.dxx"><tt class="xref py py-meth docutils literal"><span class="pre">dxx()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dxxImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxxy">
<tt class="descname">dxxy</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mixed third derivative at a real-valued coordinate.</p>
<p>SplineImageView.dxxy(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxxyImage">
<tt class="descname">dxxyImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxxyImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dxxy" title="vigra.sampling.SplineImageView3.dxxy"><tt class="xref py py-meth docutils literal"><span class="pre">dxxy()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dxxyImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxy">
<tt class="descname">dxy</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mixed second derivative at a real-valued coordinate.</p>
<p>SplineImageView.dxy(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxyImage">
<tt class="descname">dxyImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxyImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dxy" title="vigra.sampling.SplineImageView3.dxy"><tt class="xref py py-meth docutils literal"><span class="pre">dxy()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dxyImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxyy">
<tt class="descname">dxyy</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxyy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mixed third derivative at a real-valued coordinate.</p>
<p>SplineImageView.dxyy(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dxyyImage">
<tt class="descname">dxyyImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dxyyImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dxyy" title="vigra.sampling.SplineImageView3.dxyy"><tt class="xref py py-meth docutils literal"><span class="pre">dxyy()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dxyyImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dy">
<tt class="descname">dy</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return first derivative in y direction at a real-valued coordinate.</p>
<p>SplineImageView.dy(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dy3">
<tt class="descname">dy3</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dy3" title="Permalink to this definition">¶</a></dt>
<dd><p>Return third derivative in y direction at a real-valued coordinate.</p>
<p>SplineImageView.dy3(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dy3Image">
<tt class="descname">dy3Image</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dy3Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dy3" title="vigra.sampling.SplineImageView3.dy3"><tt class="xref py py-meth docutils literal"><span class="pre">dy3()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dy3Image(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dyImage">
<tt class="descname">dyImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dyImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dy" title="vigra.sampling.SplineImageView3.dy"><tt class="xref py py-meth docutils literal"><span class="pre">dy()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dyImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dyy">
<tt class="descname">dyy</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dyy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return second derivative in y direction at a real-valued coordinate.</p>
<p>SplineImageView.dyy(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.dyyImage">
<tt class="descname">dyyImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.dyyImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.dyy" title="vigra.sampling.SplineImageView3.dyy"><tt class="xref py py-meth docutils literal"><span class="pre">dyy()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.dyyImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.facetCoefficients">
<tt class="descname">facetCoefficients</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)arg2</em>, <em>(float)arg3</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.facetCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>SplineImageView.facetCoefficients(x, y) -&gt; matrix</p>
<p>Return the facet coefficient matrix so that spline values can be computed
explicitly. The matrix has size (order+1)x(order+1), where order is 
the order of the spline. The matrix must be multiplied from left and right
with the powers of the local facet x- and y-coordinates respectively
(note that local facet coordinates are in the range [0,1] for odd order
splines and [-0.5, 0.5] for even order splines).</p>
<p>Usage for odd spline order:</p>
<blockquote>
<div>s = SplineImageView3(image)
c = s.coefficients(10.1, 10.7)
x = matrix([1, 0.1, 0.1**2, 0.1**3])
y = matrix([1, 0.7, 0.7**2, 0.7**3])
assert abs(x * c * y.T - s[10.1, 10.7]) &lt; smallNumber</div></blockquote>
<p>Usage for even spline order:</p>
<blockquote>
<div>s = SplineImageView2(image)
c = s.coefficients(10.1, 10.7)
x = matrix([1, 0.1, 0.1**2])
y = matrix([1, -0.3, (-0.3)**2])
assert abs(x * c * y.T - s[10.1, 10.7]) &lt; smallNumber</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.g2">
<tt class="descname">g2</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.g2" title="Permalink to this definition">¶</a></dt>
<dd><p>Return gradient squared magnitude at a real-valued coordinate.</p>
<p>SplineImageView.g2(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.g2Image">
<tt class="descname">g2Image</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.g2Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.g2" title="vigra.sampling.SplineImageView3.g2"><tt class="xref py py-meth docutils literal"><span class="pre">g2()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.g2Image(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.g2x">
<tt class="descname">g2x</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.g2x" title="Permalink to this definition">¶</a></dt>
<dd><p>Return first derivative in x direction of the gradient squared magnitude at a real-valued coordinate.</p>
<p>SplineImageView.g2x(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.g2xImage">
<tt class="descname">g2xImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.g2xImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.g2x" title="vigra.sampling.SplineImageView3.g2x"><tt class="xref py py-meth docutils literal"><span class="pre">g2x()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.g2xImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.g2y">
<tt class="descname">g2y</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)x</em>, <em>(float)y</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.sampling.SplineImageView3.g2y" title="Permalink to this definition">¶</a></dt>
<dd><p>Return first derivative in y direction of the gradient squared magnitude at a real-valued coordinate.</p>
<p>SplineImageView.g2y(x, y) -&gt; value</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.g2yImage">
<tt class="descname">g2yImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.g2yImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#vigra.sampling.SplineImageView3.g2y" title="vigra.sampling.SplineImageView3.g2y"><tt class="xref py py-meth docutils literal"><span class="pre">g2y()</span></tt></a>, but returns an entire image with the given sampling factors. For example,</p>
<p>SplineImageView.g2yImage(2.0, 2.0) -&gt; image</p>
<p>creates an derivative image with two-fold oversampling in both directions.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.height">
<tt class="descname">height</tt><big>(</big><em>(SplineImageView3)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.sampling.SplineImageView3.height" title="Permalink to this definition">¶</a></dt>
<dd><p>The height of the underlying image.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.interpolatedImage">
<tt class="descname">interpolatedImage</tt><big>(</big><em>(SplineImageView3)arg1</em><span class="optional">[</span>, <em>(float)xfactor=2.0</em><span class="optional">[</span>, <em>(float)yfactor=2.0</em><span class="optional">[</span>, <em>(int)xorder=0</em><span class="optional">[</span>, <em>(int)yorder=0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.interpolatedImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an interpolated image or derivative image with the given sampling factors and derivative orders. For example, we get a two-fold oversampled image with the x-derivatives in each pixel by:</p>
<p>SplineImageView.interpolatedImage(2.0, 2.0, 1, 0) -&gt; image</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.isInside">
<tt class="descname">isInside</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)arg2</em>, <em>(float)arg3</em><big>)</big> &rarr; bool :<a class="headerlink" href="#vigra.sampling.SplineImageView3.isInside" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a coordinate is inside the underlying image.</p>
<p>SplineImageView.isInside(x, y) -&gt; bool</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.isValid">
<tt class="descname">isValid</tt><big>(</big><em>(SplineImageView3)arg1</em>, <em>(float)arg2</em>, <em>(float)arg3</em><big>)</big> &rarr; bool :<a class="headerlink" href="#vigra.sampling.SplineImageView3.isValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a coordinate is within the valid range of the SplineImageView.</p>
<p>SplineImageView.isValid(x, y) -&gt; bool</p>
<p>Thanks to reflective boundary conditions, the valid range is three times as big as the size of the underlying image.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.shape">
<tt class="descname">shape</tt><big>(</big><em>(SplineImageView3)arg1</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.sampling.SplineImageView3.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the underlying image.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.size">
<tt class="descname">size</tt><big>(</big><em>(SplineImageView3)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.sampling.SplineImageView3.size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.sampling.SplineImageView3.width">
<tt class="descname">width</tt><big>(</big><em>(SplineImageView3)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.sampling.SplineImageView3.width" title="Permalink to this definition">¶</a></dt>
<dd><p>The width of the underlying image.</p>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<dl class="class">
<dt id="vigra.sampling.ImagePyramid">
<em class="property">class </em><tt class="descclassname">vigra.sampling.</tt><tt class="descname">ImagePyramid</tt><big>(</big><em>image</em>, <em>copyImageToLevel=0</em>, <em>lowestLevel=0</em>, <em>highestLevel=0</em><big>)</big><a class="headerlink" href="#vigra.sampling.ImagePyramid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">list</span></tt></p>
<p>Create a new pyramid.
The new pyramid levels range from &#8216;lowestLevel&#8217; to &#8216;highestLevel&#8217; (inclusive),
and the given &#8216;image&#8217; is copied to &#8216;copyImageToLevel&#8217;. The images at other
levels are filled with zeros and sized so that the shape is reduced by half
when going up (to higher levels), and doubled when going down.</p>
<p>This class can handle multi-channel images, but only when image.channelIndex
exists and returns image.ndim-1 (i.e. the image must have axistags, and the
channel axis must correspond to the last index, as in C- or V-order).</p>
<dl class="attribute">
<dt id="vigra.sampling.ImagePyramid.axistags">
<tt class="descname">axistags</tt><a class="headerlink" href="#vigra.sampling.ImagePyramid.axistags" title="Permalink to this definition">¶</a></dt>
<dd><p>The axistags of the images in this pyramid.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.sampling.ImagePyramid.channelIndex">
<tt class="descname">channelIndex</tt><a class="headerlink" href="#vigra.sampling.ImagePyramid.channelIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>The channel dimension of the images in this pyramid.
If the images have no axistags, or no channel axis is
specified, this defaults to &#8216;ndim&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.ImagePyramid.createLevel">
<tt class="descname">createLevel</tt><big>(</big><em>level</em><big>)</big><a class="headerlink" href="#vigra.sampling.ImagePyramid.createLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure that &#8216;level&#8217; exists. If &#8216;level&#8217; is outside the current range of levels,
empty images of the appropriate shape are inserted into the pyramid.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.sampling.ImagePyramid.dtype">
<tt class="descname">dtype</tt><a class="headerlink" href="#vigra.sampling.ImagePyramid.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>The pixel type of the images in this pyramid.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.ImagePyramid.expand">
<tt class="descname">expand</tt><big>(</big><em>srcLevel</em>, <em>destLevel</em>, <em>centerValue=0.42</em><big>)</big><a class="headerlink" href="#vigra.sampling.ImagePyramid.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the image at &#8216;srcLevel&#8217; to &#8216;destLevel&#8217;, using the Burt smoothing filter
with the given &#8216;centerValue&#8217;. srcLevel must be larger than destLevel.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__ResamplingConvolutionFilters.html#ga3abb6e1a494b5d3ce952dbacf71c3092">pyramidExpandBurtFilter</a> in the C++ documentation.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.ImagePyramid.expandLaplacian">
<tt class="descname">expandLaplacian</tt><big>(</big><em>srcLevel</em>, <em>destLevel</em>, <em>centerValue=0.42</em><big>)</big><a class="headerlink" href="#vigra.sampling.ImagePyramid.expandLaplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the image at &#8216;srcLevel&#8217; to &#8216;destLevel&#8217;, using the Burt smoothing filter
with the given &#8216;centerValue&#8217;, and reconstruct the images for the levels
srcLevel-1 ... destLevel from their Laplacian images. srcLevel must be larger than destLevel.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__ResamplingConvolutionFilters.html#ga220bd2af2ffb47ed8ed6ba583207c079">pyramidExpandBurtLaplacian</a> in the C++ documentation.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.sampling.ImagePyramid.highestLevel">
<tt class="descname">highestLevel</tt><a class="headerlink" href="#vigra.sampling.ImagePyramid.highestLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>The pyramids highest level (inclusive).</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.sampling.ImagePyramid.lowestLevel">
<tt class="descname">lowestLevel</tt><a class="headerlink" href="#vigra.sampling.ImagePyramid.lowestLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>The pyramids lowest level.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.sampling.ImagePyramid.ndim">
<tt class="descname">ndim</tt><a class="headerlink" href="#vigra.sampling.ImagePyramid.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of the images in this pyramid.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.ImagePyramid.reduce">
<tt class="descname">reduce</tt><big>(</big><em>srcLevel</em>, <em>destLevel</em>, <em>centerValue=0.42</em><big>)</big><a class="headerlink" href="#vigra.sampling.ImagePyramid.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the image at &#8216;srcLevel&#8217; to &#8216;destLevel&#8217;, using the Burt smoothing filter
with the given &#8216;centerValue&#8217;. srcLevel must be smaller than destLevel.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__ResamplingConvolutionFilters.html#gafde4a3aeaffdb86f415419444acf49e7">pyramidReduceBurtFilter</a> in the C++ documentation.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.sampling.ImagePyramid.reduceLaplacian">
<tt class="descname">reduceLaplacian</tt><big>(</big><em>srcLevel</em>, <em>destLevel</em>, <em>centerValue=0.42</em><big>)</big><a class="headerlink" href="#vigra.sampling.ImagePyramid.reduceLaplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the image at &#8216;srcLevel&#8217; to &#8216;destLevel&#8217;, using the Burt smoothing filter
with the given &#8216;centerValue&#8217;, and compute Laplacian images for the levels
srcLevel ... destLevel-1. srcLevel must be smaller than destLevel.</p>
<p>For more details, see <a class="reference external" href="../../doc/vigra/group__ResamplingConvolutionFilters.html#ga6608e09fdd3756af97586288bc2db2c7">pyramidReduceBurtLaplacian</a> in the C++ documentation.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="fourier-transforms">
<h2><a class="toc-backref" href="#id92">Fourier Transforms</a><a class="headerlink" href="#fourier-transforms" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.fourier contains functions for Fourier transforms, Cosine/Sine
transforms, and Fourier-domain filters.</p>
<span class="target" id="module-vigra.fourier"></span><dl class="function">
<dt id="vigra.fourier.angularGaborSigma">
<tt class="descclassname">vigra.fourier.</tt><tt class="descname">angularGaborSigma</tt><big>(</big><em>(int)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.fourier.angularGaborSigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate sensible angular sigma for given parameters.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.fourier.createGaborFilter">
<tt class="descclassname">vigra.fourier.</tt><tt class="descname">createGaborFilter</tt><big>(</big><em>(object)shape</em>, <em>(float)orientation</em>, <em>(float)centerFrequency</em>, <em>(float)angularSigma</em>, <em>(float)radialSigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.fourier.createGaborFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a 2-dimensional gabor filter in frequency space.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.fourier.fourierTransform">
<tt class="descclassname">vigra.fourier.</tt><tt class="descname">fourierTransform</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.fourier.fourierTransform" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Perform 2-dimensional Fourier transformation of a scalar float32 image.If the input array has multiple channels, each channel is transformed separately.</div></blockquote>
<dl class="docutils">
<dt>fourierTransform( (object)volume [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3D float32 volume.</dd>
<dt>fourierTransform( (object)image [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 2D complex64 image.</dd>
<dt>fourierTransform( (object)volume [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3D complex64 volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.fourier.fourierTransformInverse">
<tt class="descclassname">vigra.fourier.</tt><tt class="descname">fourierTransformInverse</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.fourier.fourierTransformInverse" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Perform 2-dimensional inverse Fourier transformation of a complex64 array.If the input array has multiple channels, each channel is transformed separately.</div></blockquote>
<dl class="docutils">
<dt>fourierTransformInverse( (object)volume [, (object)out=None]) -&gt; object :</dt>
<dd>Likewise for a 3D complex128 volume.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.fourier.radialGaborSigma">
<tt class="descclassname">vigra.fourier.</tt><tt class="descname">radialGaborSigma</tt><big>(</big><em>(float)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.fourier.radialGaborSigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate sensible radial sigma for given parameters.</p>
</dd></dl>

</div>
<div class="section" id="image-analysis">
<h2><a class="toc-backref" href="#id93">Image Analysis</a><a class="headerlink" href="#image-analysis" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.analysis contains segmentation algorithms (e.g. watershed), edge and
corner detection, localization of maxima and minima etc.</p>
<span class="target" id="module-vigra.analysis"></span><dl class="class">
<dt id="vigra.analysis.Edgel">
<em class="property">class </em><tt class="descclassname">vigra.analysis.</tt><tt class="descname">Edgel</tt><big>(</big><em>(object)arg1</em><big>)</big><a class="headerlink" href="#vigra.analysis.Edgel" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent an Edgel at a particular subpixel position (x, y), having given &#8216;strength&#8217; and &#8216;orientation&#8217;.</p>
<p>For details, see <a class="reference external" href="../../doc/vigra/classvigra_1_1Edgel.html">Edgel</a> in the vigra C++ documentation.</p>
<p>Standard constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Edgel</span><span class="p">()</span>
</pre></div>
</div>
<dl class="docutils">
<dt>__init__( (object)arg1, (float)x, (float)y, (float)strength, (float)orientation) -&gt; None :</dt>
<dd><p class="first">Constructor:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">Edgel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">strength</span><span class="p">,</span> <span class="n">orientation</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="attribute">
<dt id="vigra.analysis.Edgel.orientation">
<tt class="descname">orientation</tt><a class="headerlink" href="#vigra.analysis.Edgel.orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>The edgel&#8217;s orientation.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.analysis.Edgel.strength">
<tt class="descname">strength</tt><a class="headerlink" href="#vigra.analysis.Edgel.strength" title="Permalink to this definition">¶</a></dt>
<dd><p>The edgel&#8217;s strength.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.analysis.Edgel.x">
<tt class="descname">x</tt><a class="headerlink" href="#vigra.analysis.Edgel.x" title="Permalink to this definition">¶</a></dt>
<dd><p>The edgel&#8217;s x position.</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.analysis.Edgel.y">
<tt class="descname">y</tt><a class="headerlink" href="#vigra.analysis.Edgel.y" title="Permalink to this definition">¶</a></dt>
<dd><p>The edgel&#8217;s y position.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vigra.analysis.FeatureAccumulator">
<em class="property">class </em><tt class="descclassname">vigra.analysis.</tt><tt class="descname">FeatureAccumulator</tt><a class="headerlink" href="#vigra.analysis.FeatureAccumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of this accumulator class is returned by <a class="reference internal" href="#vigra.analysis.extractFeatures" title="vigra.analysis.extractFeatures"><tt class="xref py py-func docutils literal"><span class="pre">extractFeatures()</span></tt></a>. The object contains the computed features (i.e. the selected features and their dependencies).</p>
<p>Raises an exception
This class cannot be instantiated from Python</p>
<dl class="method">
<dt id="vigra.analysis.FeatureAccumulator.activeFeatures">
<tt class="descname">activeFeatures</tt><big>(</big><em>(FeatureAccumulator)arg1</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.FeatureAccumulator.activeFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with the names of all computed features.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.FeatureAccumulator.createAccumulator">
<tt class="descname">createAccumulator</tt><big>(</big><em>(FeatureAccumulator)arg1</em><big>)</big> &rarr; FeatureAccumulator :<a class="headerlink" href="#vigra.analysis.FeatureAccumulator.createAccumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an empty accumulator with the same active features as &#8216;self&#8217;. This is useful for merging.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.FeatureAccumulator.isActive">
<tt class="descname">isActive</tt><big>(</big><em>(FeatureAccumulator)arg1</em>, <em>(str)feature</em><big>)</big> &rarr; bool :<a class="headerlink" href="#vigra.analysis.FeatureAccumulator.isActive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if &#8216;feature&#8217; has been computed and False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.FeatureAccumulator.keys">
<tt class="descname">keys</tt><big>(</big><em>(FeatureAccumulator)arg1</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.FeatureAccumulator.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with the names of all computed features.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.FeatureAccumulator.merge">
<tt class="descname">merge</tt><big>(</big><em>(FeatureAccumulator)arg1</em>, <em>(FeatureAccumulator)other</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.analysis.FeatureAccumulator.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge features with the features from accumulator &#8216;other&#8217;. Raises a TypeError when &#8216;other&#8217; is incompatible with &#8216;self&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.FeatureAccumulator.supportedFeatures">
<tt class="descname">supportedFeatures</tt><big>(</big><em>(FeatureAccumulator)arg1</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.FeatureAccumulator.supportedFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all supported features for the given input data array.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vigra.analysis.RegionFeatureAccumulator">
<em class="property">class </em><tt class="descclassname">vigra.analysis.</tt><tt class="descname">RegionFeatureAccumulator</tt><a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of this accumulator class is returned by <a class="reference internal" href="#vigra.analysis.extractRegionFeatures" title="vigra.analysis.extractRegionFeatures"><tt class="xref py py-func docutils literal"><span class="pre">extractRegionFeatures()</span></tt></a> and contains the computed global and per-region features.</p>
<p>Raises an exception
This class cannot be instantiated from Python</p>
<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.activeFeatures">
<tt class="descname">activeFeatures</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.activeFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with the names of all selected features.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.createAccumulator">
<tt class="descname">createAccumulator</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em><big>)</big> &rarr; RegionFeatureAccumulator :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.createAccumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an empty accumulator with the same active features as &#8216;self&#8217;. This is useful for merging.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.isActive">
<tt class="descname">isActive</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em>, <em>(str)feature</em><big>)</big> &rarr; bool :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.isActive" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if &#8216;feature&#8217; has been computed and False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.keys">
<tt class="descname">keys</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with the names of all selected features.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.maxRegionLabel">
<tt class="descname">maxRegionLabel</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.maxRegionLabel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the highest region label in this accumulator.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.merge">
<tt class="descname">merge</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em>, <em>(RegionFeatureAccumulator)other</em><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.merge" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Merge features with the features from accumulator &#8216;other&#8217;. &#8216;self&#8217; and &#8216;other&#8217; must have the same <cite>maxRegionLabel`(), or &#8216;self&#8217; must be an empty accumulator (as returned by `create</cite>).</div></blockquote>
<dl class="docutils">
<dt>merge( (RegionFeatureAccumulator)arg1, (RegionFeatureAccumulator)other, (object)labelMap) -&gt; None :</dt>
<dd>Merge features with the features from accumulator &#8216;other&#8217;. The &#8216;labelMap&#8217; determines the correspondence of regions between &#8216;self&#8217; and &#8216;other&#8217; (i.e. region k of accumulator &#8216;other&#8217; is merged into region labelMap[k] of &#8216;self&#8217;).</dd>
<dt>merge( (RegionFeatureAccumulator)arg1, (int)i, (int)j) -&gt; None :</dt>
<dd>Merge features from region &#8216;j&#8217; into region &#8216;i&#8217; of this accumulator.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.analysis.RegionFeatureAccumulator.supportedFeatures">
<tt class="descname">supportedFeatures</tt><big>(</big><em>(RegionFeatureAccumulator)arg1</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.RegionFeatureAccumulator.supportedFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list with the names of all supported features for the given input arrays.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="vigra.analysis.applyMapping">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">applyMapping</tt><big>(</big><em>(object)labels</em>, <em>(dict)mapping</em><span class="optional">[</span>, <em>(bool)allow_incomplete_mapping=False</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.applyMapping" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Map all values in <cite>labels</cite> to new values using the given mapping (a dict).
Useful for maps with large values, for which a numpy index array would need too much RAM.
To relabel in-place, set <cite>out=labels</cite>.</p>
<p>labels: ndarray
mapping: dict of <tt class="docutils literal"><span class="pre">{old_label</span> <span class="pre">:</span> <span class="pre">new_label}</span></tt>
allow_incomplete_mapping: If True, then any voxel values in the original data that are missing</p>
<blockquote>
<div>from the mapping dict will be copied (and casted) into the output.
Otherwise, an <tt class="docutils literal"><span class="pre">IndexError</span></tt> will be raised if the map is incomplete
for the input data.</div></blockquote>
<dl class="docutils">
<dt>out: ndarray to hold the data. If None, it will be allocated for you.</dt>
<dd>The dtype of <tt class="docutils literal"><span class="pre">out</span></tt> is allowed to be smaller (or bigger) than the dtype of <tt class="docutils literal"><span class="pre">labels</span></tt>.</dd>
</dl>
<p>Note: As with other vigra functions, you should provide accurate axistags for optimal performance.</p>
</div></blockquote>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
<p>applyMapping( (object)src, (dict)mapping [, (bool)allow_incomplete_mapping=False [, (object)out=None]]) -&gt; object</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.beautifyCrackEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">beautifyCrackEdgeImage</tt><big>(</big><em>(object)image</em>, <em>(int)edgeMarker</em>, <em>(int)backgroundMarker</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.beautifyCrackEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Beautify crack edge image for visualization.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga372f1a443c561d454cf46a517f0425e0">beautifyCrackEdgeImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cannyEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cannyEdgeImage</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em>, <em>(float)threshold</em>, <em>(int)edgeMarker</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cannyEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Detect and mark edges in an edge image using Canny&#8217;s algorithm.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga729ddcc1323a9c0fd31c52812f08adb6">cannyEdgeImage</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>cannyEdgeImage( (object)image, (float)scale, (float)threshold, (int)edgeMarker [, (object)out=None]) -&gt; object :</dt>
<dd><p class="first">Detect and mark edges in an edge image using Canny&#8217;s algorithm.</p>
<p class="last">For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga729ddcc1323a9c0fd31c52812f08adb6">cannyEdgeImage</a> in the vigra C++ documentation.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cannyEdgeImageWithThinning">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cannyEdgeImageWithThinning</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em>, <em>(float)threshold</em>, <em>(int)edgeMarker</em><span class="optional">[</span>, <em>(bool)addBorder=True</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cannyEdgeImageWithThinning" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect and mark edges in an edge image using Canny&#8217;s algorithm.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga9aa609d12e327e0d633047b78d61c84e">cannyEdgeImageWithThinning</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cannyEdgelList">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cannyEdgelList</tt><big>(</big><em>(object)gradient</em>, <em>(float)threshold</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.cannyEdgelList" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Return a list of <a class="reference internal" href="#vigra.analysis.Edgel" title="vigra.analysis.Edgel"><tt class="xref py py-class docutils literal"><span class="pre">Edgel</span></tt></a> objects whose strength is at least &#8216;threshold&#8217;.</p>
<p>The function comes in two forms:</p>
<div class="highlight-python"><div class="highlight"><pre>cannyEdgelList(gradient, threshold) -&gt; list
cannyEdgelList(image, scale, threshold) -&gt; list
</pre></div>
</div>
<p>The first form expects a gradient image (i.e. with two channels) to compute edgels, whereas the second form expects a scalar image and computes the gradient internally at &#8216;scale&#8217;.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#gaf2233c5ec0e42a15134feda453f6fca5">cannyEdgelList</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>cannyEdgelList( (object)image, (float)scale, (float)threshold) -&gt; list :</dt>
<dd>Compute edgels of a 2D scalar image, given the filter scale.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cannyEdgelList3x3">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cannyEdgelList3x3</tt><big>(</big><em>(object)gradient</em>, <em>(float)threshold</em><big>)</big> &rarr; list :<a class="headerlink" href="#vigra.analysis.cannyEdgelList3x3" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Return a list of <a class="reference internal" href="#vigra.analysis.Edgel" title="vigra.analysis.Edgel"><tt class="xref py py-class docutils literal"><span class="pre">Edgel</span></tt></a> objects whose strength is at least &#8216;threshold&#8217;.</p>
<p>The function comes in two forms:</p>
<div class="highlight-python"><div class="highlight"><pre>cannyEdgelList3x3(gradient, threshold) -&gt; list
cannyEdgelList3x3(image, scale, threshold) -&gt; list
</pre></div>
</div>
<p>The first form expects a gradient image (i.e. with two channels) to compute edgels, whereas the second form expects a scalar image and computes the gradient internally at &#8216;scale&#8217;. The results are slightly better than those of <a class="reference internal" href="#vigra.analysis.cannyEdgelList" title="vigra.analysis.cannyEdgelList"><tt class="xref py py-func docutils literal"><span class="pre">cannyEdgelList()</span></tt></a>.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga04e860482291f33d59c0992b479041e6">cannyEdgelList3x3</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>cannyEdgelList3x3( (object)image, (float)scale, (float)threshold) -&gt; list :</dt>
<dd>Compute edgels of a 2D scalar image, given the filter scale.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.closeGapsInCrackEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">closeGapsInCrackEdgeImage</tt><big>(</big><em>(object)image</em>, <em>(int)edgeMarker</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.closeGapsInCrackEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Close one-pixel wide gaps in a cell grid edge image.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#gab9c56ad0d2769ad7ddca5708e7adfee5">closeGapsInCrackEdgeImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cornernessBeaudet">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cornernessBeaudet</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cornernessBeaudet" title="Permalink to this definition">¶</a></dt>
<dd><p>Find corners in a scalar 2D image using the method of Beaudet at the given &#8216;scale&#8217;.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__CornerDetection.html#ga0c750a26d679a2ea13fd697dac73a123">beaudetCornerDetector</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cornernessBoundaryTensor">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cornernessBoundaryTensor</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cornernessBoundaryTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Find corners in a scalar 2D image using the boundary tensor at the given &#8216;scale&#8217;.</p>
<p>Specifically, the cornerness is defined as twice the small eigenvalue of the boundary tensor.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__TensorImaging.html#gab4ee0f19130a109119cc9cbc594ed1b7">boundaryTensor</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cornernessFoerstner">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cornernessFoerstner</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cornernessFoerstner" title="Permalink to this definition">¶</a></dt>
<dd><p>Find corners in a scalar 2D image using the method of Foerstner at the given &#8216;scale&#8217;.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__CornerDetection.html#gab70e0f0cec3312e4b0df415c6b2a733b">foerstnerCornerDetector</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cornernessHarris">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cornernessHarris</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cornernessHarris" title="Permalink to this definition">¶</a></dt>
<dd><p>Find corners in a scalar 2D image using the method of Harris at the given &#8216;scale&#8217;.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__CornerDetection.html#ga8ac6885918f92043c688fca04401248f">cornerResponseFunction</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.cornernessRohr">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">cornernessRohr</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.cornernessRohr" title="Permalink to this definition">¶</a></dt>
<dd><p>Find corners in a scalar 2D image using the method of Rohr at the given &#8216;scale&#8217;.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__CornerDetection.html#ga425b0f1d2d17b7aa2518dff5cd1abd8e">rohrCornerDetector</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extendedLocalMaxima">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extendedLocalMaxima</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=8</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.extendedLocalMaxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local maxima and maximal plateaus in an image and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 4 or 8 (default).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#gacf065fa5d3b1f0e8b2b6eedc742e117a">extendedLocalMaxima</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extendedLocalMaxima3D">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extendedLocalMaxima3D</tt><big>(</big><em>(object)volume</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=6</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.extendedLocalMaxima3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local maxima and maximal plateaus in a volume and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 6 (default) or 26 .</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#ga0db91012c965e9950ae09ab25ec2c786">extendedLocalMaxima3D</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extendedLocalMinima">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extendedLocalMinima</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=8</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.extendedLocalMinima" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local minima and minimal plateaus in an image and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 4 or 8 (default).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#ga5d85854a266cf6f5d4bff98b34e123fb">extendedLocalMinima</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extendedLocalMinima3D">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extendedLocalMinima3D</tt><big>(</big><em>(object)volume</em><span class="optional">[</span>, <em>(int)marker=1</em><span class="optional">[</span>, <em>(int)neighborhood=6</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.extendedLocalMinima3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local minima and minimal plateaus in a volume and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 6(default) or 26 .</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#gad1280b5f8335ebdadbb45a1b8cf8e8f5">extendedLocalMinima3D</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extractFeatures">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extractFeatures</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)features='all'</em><span class="optional">]</span><big>)</big> &rarr; FeatureAccumulator :<a class="headerlink" href="#vigra.analysis.extractFeatures" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Extract global features (e.g. Mean, Variance, Minimum, etc.)
from the input array (&#8216;image&#8217; or &#8216;volume&#8217;). An accumulator object
of type <a class="reference internal" href="#vigra.analysis.FeatureAccumulator" title="vigra.analysis.FeatureAccumulator"><tt class="xref py py-class docutils literal"><span class="pre">FeatureAccumulator</span></tt></a> is returned that holds the computed
features.</p>
<p>The overloaded function extractFeatures() supports 2D or 3D
arrays with arbitrary many channels. The element type of the
input array must be <strong>dtype=numpy.float32</strong>. The set of available features
depends on the input array. The &#8216;Histogram&#8217; feature, for example,
is only supported for singleband arrays. Call <a class="reference internal" href="#vigra.analysis.supportedFeatures" title="vigra.analysis.supportedFeatures"><tt class="xref py py-func docutils literal"><span class="pre">supportedFeatures()</span></tt></a>
with the same input array to get a list of all available features
for this input.</p>
<p>The argument &#8216;features&#8217; can take the following values:</p>
<blockquote>
<div><ul>
<li><p class="first">&#8216;all&#8217;: compute all supported features (default)</p>
</li>
<li><p class="first">name:  compute a single feature (and its dependencies)</p>
</li>
<li><p class="first">[name1, name2,...]:  compute the given features plus dependencies</p>
</li>
<li><dl class="first docutils">
<dt>None or &#8216;&#8217;:  return an empty accumulator, whose method </dt>
<dd><p class="first last"><a class="reference internal" href="#vigra.analysis.FeatureAccumulator.supportedFeatures" title="vigra.analysis.FeatureAccumulator.supportedFeatures"><tt class="xref py py-meth docutils literal"><span class="pre">supportedFeatures()</span></tt></a>
tells you the list of supported features for the
given input array.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>To compute per-region features, use <a class="reference internal" href="#vigra.analysis.extractRegionFeatures" title="vigra.analysis.extractRegionFeatures"><tt class="xref py py-func docutils literal"><span class="pre">extractRegionFeatures()</span></tt></a>.</p>
<p>This overload is called for 2D input arrays two or more than
four channels. Histograms and quantiles are not supported for
this input.</p>
<p>For further details about the meaning of the features, see
<a class="reference external" href="../vigra/group__FeatureAccumulators.html">Feature Accumulators</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>extractFeatures( (object)volume [, (object)features=&#8217;all&#8217;]) -&gt; FeatureAccumulator :</dt>
<dd>Overload for 3D arrays with arbitrary many channels.
Histograms and quantiles are not supported for this input.</dd>
<dt>extractFeatures( (object)image [, (object)features=&#8217;all&#8217;]) -&gt; FeatureAccumulator :</dt>
<dd>Likewise for 2D arrays with 3 channels.
Histograms and quantiles are not supported for this input.</dd>
<dt>extractFeatures( (object)volume [, (object)features=&#8217;all&#8217;]) -&gt; FeatureAccumulator :</dt>
<dd>Likewise for 3D arrays with 3 channels.
Histograms and quantiles are not supported for this input.</dd>
</dl>
<p>extractFeatures( (object)image [, (object)features=&#8217;all&#8217; [, (object)histogramRange=&#8217;globalminmax&#8217; [, (int)binCount=64]]]) -&gt; FeatureAccumulator :</p>
<blockquote>
<div><p>This overload of extractFeatures() computes global statistics for a
2D scalar input array, e.g. <a class="reference internal" href="#vigra.ScalarImage" title="vigra.ScalarImage"><tt class="xref py py-class docutils literal"><span class="pre">vigra.ScalarImage</span></tt></a></p>
<p>Features &#8216;Histogram&#8217; and &#8216;Quantiles&#8217; are supported for this input.
Options are:</p>
<blockquote>
<div><ul>
<li><p class="first">histogramRange: lower and upper bound of the histogram</p>
<blockquote>
<div><ul>
<li><p class="first">&#8216;globalminmax&#8217;:  compute and use global minimum/maximum (default)</p>
</li>
<li><dl class="first docutils">
<dt>[lower, upper]:  provide explicit bounds (float numbers),</dt>
<dd><p class="first last">useful to ensure that merge will be allowed.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">binCount: number of bins (default: 64).</p>
</li>
</ul>
</div></blockquote>
<p>Histogram options are ignored when the histogram feature is not selected.
Quantiles (0%, 10%, 25%, 50%, 75%, 90%, 100%) are computed from
the specified histogram.</p>
</div></blockquote>
<dl class="docutils">
<dt>extractFeatures( (object)volume [, (object)features=&#8217;all&#8217; [, (object)histogramRange=&#8217;globalminmax&#8217; [, (int)binCount=64]]]) -&gt; FeatureAccumulator :</dt>
<dd>Likewise for a scalar 3D input array, e.g. <a class="reference internal" href="#vigra.ScalarVolume" title="vigra.ScalarVolume"><tt class="xref py py-class docutils literal"><span class="pre">vigra.ScalarVolume</span></tt></a>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extractRegionFeatures">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extractRegionFeatures</tt><big>(</big><em>(object)image</em>, <em>(object)labels</em><span class="optional">[</span>, <em>(object)features='all'</em><span class="optional">[</span>, <em>(object)ignoreLabel=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; RegionFeatureAccumulator :<a class="headerlink" href="#vigra.analysis.extractRegionFeatures" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Extract region features from an input array with <strong>dtype=numpy.float32</strong>
and return a <a class="reference internal" href="#vigra.analysis.RegionFeatureAccumulator" title="vigra.analysis.RegionFeatureAccumulator"><tt class="xref py py-class docutils literal"><span class="pre">RegionFeatureAccumulator</span></tt></a> object.</p>
<p>Membership of the array elements (pixels) to regions is specified
by a &#8216;labels&#8217; array with element type <strong>dtype=uint32</strong>.</p>
<p>The set of available features depends on the input array.
Call <a class="reference internal" href="#vigra.analysis.supportedRegionFeatures" title="vigra.analysis.supportedRegionFeatures"><tt class="xref py py-func docutils literal"><span class="pre">supportedRegionFeatures()</span></tt></a> with the same input and label
arrays to get a list of all available features for these inputs.</p>
<p>The argument &#8216;features&#8217; can take the following values:</p>
<blockquote>
<div><ul>
<li><p class="first">&#8216;all&#8217;: compute all supported features (default)</p>
</li>
<li><p class="first">name:  compute a single feature (and its dependencies)</p>
</li>
<li><p class="first">[name1, name2,...]:  compute the given features plus dependencies</p>
</li>
<li><dl class="first docutils">
<dt>None or &#8216;&#8217;:  return an empty accumulator, whose method </dt>
<dd><p class="first last"><a class="reference internal" href="#vigra.analysis.RegionFeatureAccumulator.supportedFeatures" title="vigra.analysis.RegionFeatureAccumulator.supportedFeatures"><tt class="xref py py-meth docutils literal"><span class="pre">supportedFeatures()</span></tt></a>
tells you the list of supported features for the
given input array.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>When the feature name starts with &#8216;Global&#8217;, the feature is computed
globally, i.e. without considering region membership.</p>
<p>The argument &#8216;ignoreLabel&#8217; is useful when the label array contains
a background region (usually label 0) that should be ignored during
feature computation. If &#8216;ignoreLabel&#8217; is None (the default), all
region labels are used.</p>
<p>This overload is called for 2D input arrays with two or more than
four channels. Histograms and quantiles are not supported for this
input.</p>
<p>For further details about the meaning of the features, see
<a class="reference external" href="../vigra/group__FeatureAccumulators.html">Feature Accumulators</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>extractRegionFeatures( (object)volume, (object)labels [, (object)features=&#8217;all&#8217; [, (object)ignoreLabel=None]]) -&gt; RegionFeatureAccumulator :</dt>
<dd>Likewise for a 3D input array  with two or more than four channels.
Histograms and quantiles are not supported for this input.</dd>
<dt>extractRegionFeatures( (object)image, (object)labels [, (object)features=&#8217;all&#8217; [, (object)ignoreLabel=None]]) -&gt; RegionFeatureAccumulator :</dt>
<dd>This overload of extractRegionFeatures() is called for
2D input arrays with 3 channels.</dd>
<dt>extractRegionFeatures( (object)volume, (object)labels [, (object)features=&#8217;all&#8217; [, (object)ignoreLabel=None]]) -&gt; RegionFeatureAccumulator :</dt>
<dd>This overload of extractRegionFeatures() is called for
3D input arrays with 3 channels.</dd>
</dl>
<p>extractRegionFeatures( (object)image, (object)labels [, (object)features=&#8217;all&#8217; [, (object)histogramRange=&#8217;globalminmax&#8217; [, (int)binCount=64 [, (object)ignoreLabel=None]]]]) -&gt; RegionFeatureAccumulator :</p>
<blockquote>
<div><p>This overload of extractRegionFeatures() computes region statistics
for a scalar 2D input array, e.g. <a class="reference internal" href="#vigra.ScalarImage" title="vigra.ScalarImage"><tt class="xref py py-class docutils literal"><span class="pre">vigra.ScalarImage</span></tt></a>.</p>
<p>Features &#8216;Histogram&#8217; and &#8216;Quantiles&#8217; are supported for this input. Options are:</p>
<blockquote>
<div><ul>
<li><p class="first">histogramRange: lower and upper bound of the histogram</p>
<blockquote>
<div><ul>
<li><p class="first">&#8216;globalminmax&#8217;:  compute and use global minimum/maximum (default)</p>
</li>
<li><p class="first">&#8216;regionminmax&#8217;:   use minimum/maximum within each region</p>
</li>
<li><dl class="first docutils">
<dt>[lower, upper]:  provide explicit bounds (float numbers),</dt>
<dd><p class="first last">useful to ensure that merge will be allowed.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">binCount: number of bins (default: 64).</p>
</li>
</ul>
</div></blockquote>
<p>Histogram options are ignored when Histogram feature is not selected.
Quantiles (0%, 10%, 25%, 50%, 75%, 90%, 100%) are computed from
the specified histogram.</p>
</div></blockquote>
<dl class="docutils">
<dt>extractRegionFeatures( (object)volume, (object)labels [, (object)features=&#8217;all&#8217; [, (object)histogramRange=&#8217;globalminmax&#8217; [, (int)binCount=64 [, (object)ignoreLabel=None]]]]) -&gt; RegionFeatureAccumulator :</dt>
<dd>Likewise for 3D scalar arrays, e.g. <a class="reference internal" href="#vigra.ScalarVolume" title="vigra.ScalarVolume"><tt class="xref py py-class docutils literal"><span class="pre">vigra.ScalarVolume</span></tt></a>.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.extractSkeletonFeatures">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">extractSkeletonFeatures</tt><big>(</big><em>(object)labels</em><span class="optional">[</span>, <em>(float)pruning_threshold=0.2</em><span class="optional">[</span>, <em>(bool)list_features_only=False</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.extractSkeletonFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract skeleton features for each region of a labeled 2D image
(with dtype=numpy.uint32) and return a dictionary holding the
resulting feature arrays. Label 0 is always considered background
and therefore skipped. The skeleton is computed using mode
&#8216;PruneSalienceRelative&#8217; with the given &#8216;pruning_threshold&#8217;.</p>
<p>The result dictionary holds the following keys:</p>
<blockquote>
<div><ul>
<li><p class="first">&#8216;Diameter&#8217;:  the longest path between two terminals of the skeleton</p>
</li>
<li><p class="first">&#8216;Center&#8217;:  the center point of this path</p>
</li>
<li><p class="first">&#8216;Terminal1&#8217;:  first end point of this path</p>
</li>
<li><p class="first">&#8216;Terminal2&#8217;:  second end point of this path</p>
</li>
<li><p class="first">&#8216;EuclideanDiameter&#8217;:  the Euclidean distance between Terminal1 and Terminal2</p>
</li>
<li><p class="first">&#8216;TotalLength&#8217;:  total length of the (pruned) skeleton</p>
</li>
<li><p class="first">&#8216;AverageLength&#8217;:  the average length of the skeleton&#8217;s branches after pruning</p>
</li>
<li><p class="first">&#8216;BranchCount&#8217;:  the number of skeleton branches (i.e. end points after pruning)</p>
</li>
<li><dl class="first docutils">
<dt>&#8216;HoleCount&#8217;:  the number of cycles in the skeleton</dt>
<dd><p class="first last">(i.e. the number of cavities in the region)</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.labelImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">labelImage</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)neighborhood=4</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.labelImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the connected components of a segmented image. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 4 (default) or 8.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#ga8692820fcfdc8adb7ad57582bbb20392">labelMultiArray</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.labelImageWithBackground">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">labelImageWithBackground</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(object)neighborhood=4</em><span class="optional">[</span>, <em>(float)background_value=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.labelImageWithBackground" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the connected components of a segmented image, excluding the background from labeling, where the background is the set of all pixels with the given &#8216;background_value&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 4 (default) or 8.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#gacab3be2814f7ca04b10136257dc05c81">labelMultiArrayWithBackground</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.labelMultiArray">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">labelMultiArray</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(object)neighborhood=''</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.labelMultiArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the connected components of a segmented multi-dimensional array
(supported dimensions: 2 to 5).
Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used
and can be &#8216;direct&#8217; (default) or &#8216;indirect&#8217; or the exact number of
neighbors (2D: 4 or 8, 3D: 6 or 26, 4D: 8 or 80, 5D: 10 or 242).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#ga8692820fcfdc8adb7ad57582bbb20392">labelMultiArray</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.labelMultiArrayWithBackground">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">labelMultiArrayWithBackground</tt><big>(</big><em>(object)array</em><span class="optional">[</span>, <em>(object)neighborhood=''</em><span class="optional">[</span>, <em>(float)background_value=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.labelMultiArrayWithBackground" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the connected components of a segmented multi-dimensional array
(supported dimensions: 2 to 5), excluding the background from labeling,
where background is the set of all pixels with the given &#8216;background_value&#8217;.
Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used
and can be &#8216;direct&#8217; (default) or &#8216;indirect&#8217; or the exact number of
neighbors (2D: 4 or 8, 3D: 6 or 26, 4D: 8 or 80, 5D: 10 or 242).</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#gacab3be2814f7ca04b10136257dc05c81">labelMultiArrayWithBackground</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.labelVolume">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">labelVolume</tt><big>(</big><em>(object)volume</em><span class="optional">[</span>, <em>(object)neighborhood=6</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.labelVolume" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the connected components of a segmented volume. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 6 (default) or 26.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#ga8692820fcfdc8adb7ad57582bbb20392">labelMultiArray</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.labelVolumeWithBackground">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">labelVolumeWithBackground</tt><big>(</big><em>(object)volume</em><span class="optional">[</span>, <em>(object)neighborhood=6</em><span class="optional">[</span>, <em>(float)background_value=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.labelVolumeWithBackground" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the connected components of a segmented volume, excluding the background from labeling, where the background is the set of all pixels with the given &#8216;background_value&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 6 (default) or 26.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#gacab3be2814f7ca04b10136257dc05c81">labelMultiArrayWithBackground</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.localMaxima">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">localMaxima</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=8</em><span class="optional">[</span>, <em>(bool)allowAtBorder=False</em><span class="optional">[</span>, <em>(bool)allowPlateaus=False</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.localMaxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local maxima in an image and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 4 or 8 (default).
If &#8216;allowAtBorder&#8217; is set to &#8216;True&#8217; local maxima at image border will be detected.
If &#8216;allowPlateaus&#8217; is set to &#8216;True&#8217; regions of constant gray value whose neighbors are all lower than the value of the region will be detected.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#ga00086937b5ac265fc74b5a8ee0c15c47">localMaxima</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.localMaxima3D">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">localMaxima3D</tt><big>(</big><em>(object)volume</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=6</em><span class="optional">[</span>, <em>(bool)allowAtBorder=False</em><span class="optional">[</span>, <em>(bool)allowPlateaus=False</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.localMaxima3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local maxima and maximal plateaus in a volume and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 6(default) or 26.
If &#8216;allowAtBorder&#8217; is set to &#8216;True&#8217; local maxima at the volume border will be detected.
If &#8216;allowPlateaus&#8217; is set to &#8216;True&#8217; regions of constant gray value whose neighbors are all lower than the value of the region will be detected.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#ga00086937b5ac265fc74b5a8ee0c15c47">localMaxima</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.localMinima">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">localMinima</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=8</em><span class="optional">[</span>, <em>(bool)allowAtBorder=False</em><span class="optional">[</span>, <em>(bool)allowPlateaus=False</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.localMinima" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local minima in an image and mark them with the given &#8216;marker&#8217;. Parameter &#8216;neighborhood&#8217; specifies the pixel neighborhood to be used and can be 4 or 8 (default). 
If &#8216;allowAtBorder&#8217; is true local minima at the image border will be detected.
If &#8216;allowPlateaus&#8217; is true regions of constant gray value whose neighbors are all higher than the value of the region will be detected.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#ga527dfba5468e97ca7f1d676d34bc7162">localMinima</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.localMinima3D">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">localMinima3D</tt><big>(</big><em>(object)volume</em><span class="optional">[</span>, <em>(float)marker=1.0</em><span class="optional">[</span>, <em>(int)neighborhood=6</em><span class="optional">[</span>, <em>(bool)allowAtBorder=False</em><span class="optional">[</span>, <em>(bool)allowPlateaus=False</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.localMinima3D" title="Permalink to this definition">¶</a></dt>
<dd><p>Find local minima in a volume and mark them with the given &#8216;marker&#8217;. Parameter 6 (default) or 26.
If &#8216;allowAtBorder&#8217; is set to &#8216;True&#8217; local minima at the volume border will be detected.
If &#8216;allowPlateaus&#8217; is set to &#8216;True&#8217; regions of constant gray value whose neighbors are all higher than the value of the region will be detected.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__LocalMinMax.html#ga527dfba5468e97ca7f1d676d34bc7162">localMinima</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.regionImageToCrackEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">regionImageToCrackEdgeImage</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(int)edgeLabel=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.regionImageToCrackEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Transform a labeled uint32 image into a crack edge image.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#ga0d13d25c5b735aaca90c5a506bb274ac">regionImageToCrackEdgeImage</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>regionImageToCrackEdgeImage( (object)image [, (int)edgeLabel=0 [, (object)out=None]]) -&gt; object :</dt>
<dd>Likewise for a uint64 image.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.regionImageToEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">regionImageToEdgeImage</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(int)edgeLabel=1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.regionImageToEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Transform a labeled uint32 image into an edge image.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Labeling.html#ga6b16eb7df332ab9392e0927c2b5383e2">regionImageToEdgeImage</a> in the vigra C++ documentation.</p>
</div></blockquote>
<dl class="docutils">
<dt>regionImageToEdgeImage( (object)image [, (int)edgeLabel=1 [, (object)out=None]]) -&gt; object :</dt>
<dd>Likewise for a uint64 image.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.relabelConsecutive">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">relabelConsecutive</tt><big>(</big><em>(object)labels</em><span class="optional">[</span>, <em>(int)start_label=1</em><span class="optional">[</span>, <em>(bool)keep_zeros=True</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; tuple :<a class="headerlink" href="#vigra.analysis.relabelConsecutive" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Relabel the given label image to have consecutive label values.
Note: The relative order between label values will not necessarily be preserved.</p>
<p>labels: ndarray
start_label: The lowest label of the output array.
keep_zeros: Don&#8217;t relabel zero-valued items.
out: ndarray to hold the data. If None, it will be allocated for you.</p>
<blockquote>
<div>A combination of uint64 labels and uint32 &#8216;out&#8217; is permitted.</div></blockquote>
<p>Returns a tuple of <tt class="docutils literal"><span class="pre">(newlabels,</span> <span class="pre">maxlabel,</span> <span class="pre">mapping)</span></tt>, where:
<tt class="docutils literal"><span class="pre">maxlabel</span></tt> is the maximum label of the new labels, and
<tt class="docutils literal"><span class="pre">mapping</span></tt> is a dict showing how the old labels were converted to the new label values.</p>
<p>Note: As with other vigra functions, you should provide accurate axistags for optimal performance.</p>
</div></blockquote>
<p>relabelConsecutive( (object)labels [, (int)start_label=1 [, (bool)keep_zeros=True [, (object)out=None]]]) -&gt; tuple</p>
<p>relabelConsecutive( (object)labels [, (int)start_label=1 [, (bool)keep_zeros=True [, (object)out=None]]]) -&gt; tuple</p>
<p>relabelConsecutive( (object)labels [, (int)start_label=1 [, (bool)keep_zeros=True [, (object)out=None]]]) -&gt; tuple</p>
<p>relabelConsecutive( (object)labels [, (int)start_label=1 [, (bool)keep_zeros=True [, (object)out=None]]]) -&gt; tuple</p>
<p>relabelConsecutive( (object)labels [, (int)start_label=1 [, (bool)keep_zeros=True [, (object)out=None]]]) -&gt; tuple</p>
<p>relabelConsecutive( (object)labels [, (int)start_label=1 [, (bool)keep_zeros=True [, (object)out=None]]]) -&gt; tuple</p>
<p>relabelConsecutive( (object)labels [, (int)start_label=1 [, (bool)keep_zeros=True [, (object)out=None]]]) -&gt; tuple</p>
<p>relabelConsecutive( (object)labels [, (int)start_label=1 [, (bool)keep_zeros=True [, (object)out=None]]]) -&gt; tuple</p>
<p>relabelConsecutive( (object)labels [, (int)start_label=1 [, (bool)keep_zeros=True [, (object)out=None]]]) -&gt; tuple</p>
<p>relabelConsecutive( (object)labels [, (int)start_label=1 [, (bool)keep_zeros=True [, (object)out=None]]]) -&gt; tuple</p>
<p>relabelConsecutive( (object)labels [, (int)start_label=1 [, (bool)keep_zeros=True [, (object)out=None]]]) -&gt; tuple</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.removeShortEdges">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">removeShortEdges</tt><big>(</big><em>(object)image</em>, <em>(int)minEdgeLength</em>, <em>(int)nonEdgeMarker</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.removeShortEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove short edges from an edge image.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga6f9601dcf8f062b88b8cb80b8fdd76a5">removeShortEdges</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.segToSeeds">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">segToSeeds</tt><big>(</big><em>(object)image</em>, <em>(int)shrinkN</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.segToSeeds" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>shrink / ungrow a labeling / segmentation</div></blockquote>
<dl class="docutils">
<dt>segToSeeds( (object)image, (int)shrinkN [, (object)out=None]) -&gt; object :</dt>
<dd>shrink / ungrow a labeling / segmentation</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.shenCastanCrackEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">shenCastanCrackEdgeImage</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em>, <em>(float)threshold</em>, <em>(int)edgeMarker</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.shenCastanCrackEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect and mark edges in a crack edge image using the Shen/Castan zero-crossing detector.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga52ce27e210e918ed15281dff03ee712e">differenceOfExponentialCrackEdgeImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.shenCastanEdgeImage">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">shenCastanEdgeImage</tt><big>(</big><em>(object)image</em>, <em>(float)scale</em>, <em>(float)threshold</em>, <em>(int)edgeMarker</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.shenCastanEdgeImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect and mark edges in an edge image using the Shen/Castan zero-crossing detector.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__EdgeDetection.html#ga82468161d9b270516e72ab0bc76f63b7">differenceOfExponentialEdgeImage</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.sizeFilterSegInplace">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">sizeFilterSegInplace</tt><big>(</big><em>(object)seg</em>, <em>(int)maxLabel</em>, <em>(int)sizeLimit</em><span class="optional">[</span>, <em>(bool)checkAtBorder=False</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.sizeFilterSegInplace" title="Permalink to this definition">¶</a></dt>
<dd><p>replace every occurance of each number in the array &#8216;seg&#8217; with zeros if this number occures less than &#8216;sizeLimit&#8217; times in the array. If &#8216;checkAtBorder&#8217; is false (default) segments that touch the border of the array will not be changed.
&#8216;maxLabel&#8217; is the maximum label in seg</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.slicSuperpixels">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">slicSuperpixels</tt><big>(</big><em>(object)array</em>, <em>(float)intensityScaling</em>, <em>(int)seedDistance</em><span class="optional">[</span>, <em>(int)minSize=0</em><span class="optional">[</span>, <em>(int)iterations=10</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; tuple :<a class="headerlink" href="#vigra.analysis.slicSuperpixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Slic superpixels for a 2D or 3D image.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="docutils">
<dt>array:</dt>
<dd>The array on which the superpixels will be calculated. Accepts single- and
threeband images/volumes.</dd>
<dt>intensityScaling:</dt>
<dd>Scale (divide) color/intensity difference by this parameter before comparing
to spatial distance.</dd>
<dt>seedDistance:</dt>
<dd>specify the radius of the window around each seed in which the algorithm looks
for potential members of the corresponding superpixel thus limiting the
superpixel size. The grid spacing for seed placement is determined by this parameter.</dd>
<dt>minSize:</dt>
<dd>Minimum size for superpixels. By default the algorithm merges all regions smaller
than a quarter of the average superpixel size.</dd>
<dt>iterations:</dt>
<dd>Specify number of iterations. The default is 10.</dd>
<dt>out:</dt>
<dd>The label image (with dtype=numpy.uint32) to be filled by the algorithm.     It will be allocated by the slicSuperpixels function if not provided)</dd>
</dl>
</div></blockquote>
<p>The function returns a Python tuple (labelImage, maxRegionLabel)</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.supportedConvexHullFeatures">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">supportedConvexHullFeatures</tt><big>(</big><em>labels</em><big>)</big><a class="headerlink" href="#vigra.analysis.supportedConvexHullFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of Convex Hull feature names that are available for the given label array.
These Convex Hull feature names are the valid inputs to a call with
<tt class="xref py py-func docutils literal"><span class="pre">extract2DConvexHullFeatures()</span></tt> or <cite>extract3DConvexHullFeatures</cite>. E.g., to compute just the first two features in the
list, use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">supportedConvexHullFeatures</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&quot;Computing Convex Hull features:&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">extract2DConvexHullFeatures</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">f</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.supportedFeatures">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">supportedFeatures</tt><big>(</big><em>array</em><big>)</big><a class="headerlink" href="#vigra.analysis.supportedFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of feature names that are available for the given array. These feature
names are the valid inputs to a call of <a class="reference internal" href="#vigra.analysis.extractFeatures" title="vigra.analysis.extractFeatures"><tt class="xref py py-func docutils literal"><span class="pre">extractFeatures()</span></tt></a>. E.g., to compute
just the first two features in the list, use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">supportedFeatures</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&quot;Computing features:&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">extractFeatures</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">f</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.supportedRegionFeatures">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">supportedRegionFeatures</tt><big>(</big><em>array</em>, <em>labels</em><big>)</big><a class="headerlink" href="#vigra.analysis.supportedRegionFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of feature names that are available for the given array and label array.
These feature names are the valid inputs to a call of
<a class="reference internal" href="#vigra.analysis.extractRegionFeatures" title="vigra.analysis.extractRegionFeatures"><tt class="xref py py-func docutils literal"><span class="pre">extractRegionFeatures()</span></tt></a>. E.g., to compute just the first two features in the
list, use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">supportedRegionFeatures</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&quot;Computing features:&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">extractRegionFeatures</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">f</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.supportedSkeletonFeatures">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">supportedSkeletonFeatures</tt><big>(</big><em>labels</em><big>)</big><a class="headerlink" href="#vigra.analysis.supportedSkeletonFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of Skeleton feature names that are available for the given 2D label array.
These Skeleton feature names are the valid inputs to a call of
<a class="reference internal" href="#vigra.analysis.extractSkeletonFeatures" title="vigra.analysis.extractSkeletonFeatures"><tt class="xref py py-func docutils literal"><span class="pre">extractSkeletonFeatures()</span></tt></a>. E.g., to compute just the first two features in the
list, use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">supportedSkeletonFeatures</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&quot;Computing Skeleton features:&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">extractSkeletonFeatures</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">f</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.unionFindWatershed3D">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">unionFindWatershed3D</tt><big>(</big><em>(object)image</em>, <em>(object)blockShape</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; tuple<a class="headerlink" href="#vigra.analysis.unionFindWatershed3D" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="vigra.analysis.unique">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">unique</tt><big>(</big><em>(object)arr</em><span class="optional">[</span>, <em>(bool)sort=True</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.analysis.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Find unique values in the given label array.
If <tt class="docutils literal"><span class="pre">sort</span></tt> is True, then the output is sorted.
Much faster then <tt class="docutils literal"><span class="pre">numpy.unique()</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.watersheds">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">watersheds</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.analysis.watersheds" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the watersheds of a 2D image.</p>
<blockquote>
<div><dl class="docutils">
<dt>watersheds(image, neighborhood=4, seeds = None, methods = &#8216;RegionGrowing&#8217;, </dt>
<dd>terminate=CompleteGrow, threshold=0, out = None) -&gt; (labelimage, max_ragion_label)</dd>
</dl>
</div></blockquote>
<p>Parameters:</p>
<blockquote>
<div><dl class="docutils">
<dt>image:</dt>
<dd>the image or volume containing the boundary indicator values     (high values = high edgeness, dtype=numpy.uint8 or numpy.float32).</dd>
<dt>neighborhood:</dt>
<dd><p class="first">the pixel neighborhood to be used. Feasible values depend on the     dimension and method:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>2-dimensional data:</dt>
<dd>4 (default) or 8.</dd>
<dt>3-dimensional data:</dt>
<dd>6 (default) or 26</dd>
</dl>
</div></blockquote>
</dd>
<dt>seeds:</dt>
<dd>a label image specifying region seeds, only supported by methods &#8216;RegionGrowing&#8217; and &#8216;Turbo&#8217;    (with dtype=numpy.uint32).</dd>
<dt>method:</dt>
<dd><p class="first">the algorithm to be used for watershed computation. Possible values:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>&#8216;Turbo&#8217;:</dt>
<dd>(default if input dtype == uint8) use fastSeededRegionGrowing() (in 2D) or tws() (in 3D)</dd>
<dt>&#8216;RegionGrowing&#8217;:</dt>
<dd>(default if input dtype != uint8) use <a class="reference external" href="../../doc/vigra/group__Superpixels.html#ga7b54436edf7b15b9628d17a22917b4b1">seededRegionGrowing</a> or <a class="reference external" href="../../doc/vigra/group__Superpixels.html#gae9e3ebc5978a393267485d426141a201">seededRegionGrowing3D</a> respectively</dd>
<dt>&#8216;UnionFind:</dt>
<dd>use <a class="reference external" href="../../doc/vigra/group__Superpixels.html#ga798e1da19d24c46a3762057b1708e8b3">watershedsUnionFind</a> or <a class="reference external" href="../../doc/vigra/group__Superpixels.html#ga848b9a3983f20e8ad753d104aad16810">watersheds3D</a> respectively</dd>
</dl>
</div></blockquote>
</dd>
<dt>terminate:</dt>
<dd><p class="first">when to stop growing. Possible values:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>CompleteGrow:</dt>
<dd>(default) grow until all pixels are assigned to a region</dd>
<dt>KeepCountours:</dt>
<dd>keep a 1-pixel wide contour between all regions, only supported         by method &#8216;RegionGrowing&#8217;</dd>
<dt>StopAtThreshold:</dt>
<dd>stop when the boundary indicator values exceed the threshold given by         parameter &#8216;max_cost&#8217;, only supported by method &#8216;RegionGrowing&#8217;</dd>
<dt>KeepCountours | StopAtThreshold:</dt>
<dd>keep 1-pixel wide contour and stop at given &#8216;max_cost&#8217;, only         supported by method &#8216;RegionGrowing&#8217;</dd>
</dl>
</div></blockquote>
</dd>
<dt>max_cost:</dt>
<dd>terminate growing when boundary indicator exceeds this value (ignored when     &#8216;terminate&#8217; is not StopAtThreshold or method is not &#8216;RegionGrowing&#8217;)</dd>
<dt>out:</dt>
<dd>the label image (with dtype=numpy.uint32) to be filled by the algorithm.     It will be allocated by the watershed function if not provided)</dd>
</dl>
</div></blockquote>
<p>The function returns a Python tuple (labelImage, maxRegionLabel)</p>
<p>Compute the watersheds of a 2D image.</p>
<blockquote>
<div><dl class="docutils">
<dt>watersheds(image, neighborhood=4, seeds = None, methods = &#8216;RegionGrowing&#8217;, </dt>
<dd>terminate=CompleteGrow, threshold=0, out = None) -&gt; (labelimage, max_ragion_label)</dd>
</dl>
</div></blockquote>
<p>Parameters:</p>
<blockquote>
<div><dl class="docutils">
<dt>image:</dt>
<dd>the image or volume containing the boundary indicator values     (high values = high edgeness, dtype=numpy.uint8 or numpy.float32).</dd>
<dt>neighborhood:</dt>
<dd><p class="first">the pixel neighborhood to be used. Feasible values depend on the     dimension and method:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>2-dimensional data:</dt>
<dd>4 (default) or 8.</dd>
<dt>3-dimensional data:</dt>
<dd>6 (default) or 26</dd>
</dl>
</div></blockquote>
</dd>
<dt>seeds:</dt>
<dd>a label image specifying region seeds, only supported by methods &#8216;RegionGrowing&#8217; and &#8216;Turbo&#8217;    (with dtype=numpy.uint32).</dd>
<dt>method:</dt>
<dd><p class="first">the algorithm to be used for watershed computation. Possible values:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>&#8216;Turbo&#8217;:</dt>
<dd>(default if input dtype == uint8) use fastSeededRegionGrowing() (in 2D) or tws() (in 3D)</dd>
<dt>&#8216;RegionGrowing&#8217;:</dt>
<dd>(default if input dtype != uint8) use <a class="reference external" href="../../doc/vigra/group__Superpixels.html#ga7b54436edf7b15b9628d17a22917b4b1">seededRegionGrowing</a> or <a class="reference external" href="../../doc/vigra/group__Superpixels.html#gae9e3ebc5978a393267485d426141a201">seededRegionGrowing3D</a> respectively</dd>
<dt>&#8216;UnionFind:</dt>
<dd>use <a class="reference external" href="../../doc/vigra/group__Superpixels.html#ga798e1da19d24c46a3762057b1708e8b3">watershedsUnionFind</a> or <a class="reference external" href="../../doc/vigra/group__Superpixels.html#ga848b9a3983f20e8ad753d104aad16810">watersheds3D</a> respectively</dd>
</dl>
</div></blockquote>
</dd>
<dt>terminate:</dt>
<dd><p class="first">when to stop growing. Possible values:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>CompleteGrow:</dt>
<dd>(default) grow until all pixels are assigned to a region</dd>
<dt>KeepCountours:</dt>
<dd>keep a 1-pixel wide contour between all regions, only supported         by method &#8216;RegionGrowing&#8217;</dd>
<dt>StopAtThreshold:</dt>
<dd>stop when the boundary indicator values exceed the threshold given by         parameter &#8216;max_cost&#8217;, only supported by method &#8216;RegionGrowing&#8217;</dd>
<dt>KeepCountours | StopAtThreshold:</dt>
<dd>keep 1-pixel wide contour and stop at given &#8216;max_cost&#8217;, only         supported by method &#8216;RegionGrowing&#8217;</dd>
</dl>
</div></blockquote>
</dd>
<dt>max_cost:</dt>
<dd>terminate growing when boundary indicator exceeds this value (ignored when     &#8216;terminate&#8217; is not StopAtThreshold or method is not &#8216;RegionGrowing&#8217;)</dd>
<dt>out:</dt>
<dd>the label image (with dtype=numpy.uint32) to be filled by the algorithm.     It will be allocated by the watershed function if not provided)</dd>
</dl>
</div></blockquote>
<p>The function returns a Python tuple (labelImage, maxRegionLabel)</p>
<p>Likewise, compute watersheds of a volume.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.watershedsNew">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">watershedsNew</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(int)neighborhood=4</em><span class="optional">[</span>, <em>(object)seeds=None</em><span class="optional">[</span>, <em>(str)method=''</em><span class="optional">[</span>, <em>(SRGType)terminate=vigra.analysis.SRGType.CompleteGrow</em><span class="optional">[</span>, <em>(float)max_cost=0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; tuple :<a class="headerlink" href="#vigra.analysis.watershedsNew" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>graph-based watershed</div></blockquote>
<dl class="docutils">
<dt>watershedsNew( (object)image [, (int)neighborhood=6 [, (object)seeds=None [, (str)method=&#8217;&#8217; [, (SRGType)terminate=vigra.analysis.SRGType.CompleteGrow [, (int)max_cost=0 [, (object)out=None]]]]]]) -&gt; tuple :</dt>
<dd>graph-based watershed</dd>
<dt>watershedsNew( (object)image [, (int)neighborhood=6 [, (object)seeds=None [, (str)method=&#8217;&#8217; [, (SRGType)terminate=vigra.analysis.SRGType.CompleteGrow [, (float)max_cost=0 [, (object)out=None]]]]]]) -&gt; tuple :</dt>
<dd>graph-based watershed</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.watershedsUnionFind">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">watershedsUnionFind</tt><big>(</big><em>image</em>, <em>neighborhood=None</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.analysis.watershedsUnionFind" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute watersheds of an image using the union find algorithm.
If &#8216;neighborhood&#8217; is &#8216;None&#8217;, it defaults to 8-neighborhood for 2D inputs
and 6-neighborhood for 3D inputs.</p>
<p>Calls <a class="reference internal" href="#vigra.analysis.watersheds" title="vigra.analysis.watersheds"><tt class="xref py py-func docutils literal"><span class="pre">watersheds()</span></tt></a> with parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">watersheds</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">neighborhood</span><span class="o">=</span><span class="n">neighborhood</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;UnionFind&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="vigra.analysis.wsDtSegmentation">
<tt class="descclassname">vigra.analysis.</tt><tt class="descname">wsDtSegmentation</tt><big>(</big><em>pmap</em>, <em>pmin</em>, <em>minMembraneSize</em>, <em>minSegmentSize</em>, <em>sigmaMinima</em>, <em>sigmaWeights</em>, <em>cleanCloseSeeds=True</em><big>)</big><a class="headerlink" href="#vigra.analysis.wsDtSegmentation" title="Permalink to this definition">¶</a></dt>
<dd><p>A probability map &#8216;pmap&#8217; is provided and thresholded using pmin.
This results in a mask. Every connected component which has fewer pixel
than &#8216;minMembraneSize&#8217; is deleted from the mask. The mask is used to
calculate the signed distance transformation.</p>
<p>From this distance transformation the segmentation is computed using
a seeded watershed algorithm. The seeds are placed on the local maxima
of the distanceTrafo after smoothing with &#8216;sigmaMinima&#8217;.</p>
<p>The weights of the watershed are defined by the inverse of the signed
distance transform smoothed with &#8216;sigmaWeights&#8217;.</p>
<p>&#8216;minSegmentSize&#8217; determines how small the smallest segment in the final
segmentation is allowed to be. If there are smaller ones the corresponding
seeds are deleted and the watershed is done again.</p>
<p>If &#8216;cleanCloseSeeds&#8217; is True, multiple seed points that are clearly in the
same neuron will be merged with a heuristik that ensures that no seeds of
two different neurons are merged.</p>
</dd></dl>

</div>
<div class="section" id="geometry">
<h2><a class="toc-backref" href="#id94">Geometry</a><a class="headerlink" href="#geometry" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.geometry contains geometric primitives (such as polygons) and related algorithms.</p>
<span class="target" id="module-vigra.geometry"></span><dl class="function">
<dt id="vigra.geometry.convexHull">
<tt class="descclassname">vigra.geometry.</tt><tt class="descname">convexHull</tt><big>(</big><em>(object)points</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.geometry.convexHull" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the convex hull of a point set.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Geometry.html#ga8ba489a131e75016f32095b106659d22">convexHull</a> in the vigra C++ documentation.</p>
</dd></dl>

</div>
<div class="section" id="optimization">
<h2><a class="toc-backref" href="#id95">Optimization</a><a class="headerlink" href="#optimization" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.optimization provides functions for constrained and unconstrained linear regression.</p>
<span class="target" id="module-vigra.optimization"></span><dl class="function">
<dt id="vigra.optimization.lassoRegression">
<tt class="descclassname">vigra.optimization.</tt><tt class="descname">lassoRegression</tt><big>(</big><em>(object)A</em>, <em>(object)b</em><span class="optional">[</span>, <em>(bool)nonNegative=False</em><span class="optional">[</span>, <em>(bool)lsq=True</em><span class="optional">[</span>, <em>(bool)lasso=False</em><span class="optional">[</span>, <em>(int)maxSolutionCount=0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; tuple :<a class="headerlink" href="#vigra.optimization.lassoRegression" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform linear regression with L1 regularization.</p>
<p>If &#8216;nonNegative&#8217; is &#8216;True&#8217;, the solution will be constrained to non-negative
values, otherwise values may have arbitrary sign (the default).
If &#8216;lsq&#8217; is &#8216;True&#8217;, the algorithm will return the least squares solution
for each active set. If &#8216;lasso&#8217; is &#8216;True&#8217;, the LASSO solution will be returned
for each active set. Both may be &#8216;True&#8217; simultaneously.
If &#8216;maxSolutionCount&#8217; is non-zero, atr most so many active sets will
be computed.</p>
<p>The algorithm returns a tuple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">numActiveSets</span><span class="p">,</span> <span class="n">activeSets</span><span class="p">,</span> <span class="n">lsqSolutions</span><span class="p">,</span> <span class="n">lassoSolutions</span><span class="p">)</span>
</pre></div>
</div>
<p>where &#8216;numActiveSets&#8217; specifies how many active sets have been computed,
&#8216;activeSets&#8217; is the list of all active sets (ordered by decreasing regularization),
and &#8216;lsqSolutions&#8217; and &#8216;lassoSolutions&#8217; are lists of the corresponding solutions
for each active set (&#8216;lsqSolutions&#8217; and &#8216;lassoSolutions&#8217; will be &#8216;None&#8217; when
the corresponding function argument was &#8216;False&#8217;). An active set is a list of
indices of all variables whose values are non-zero in the corresponding
solution.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Optimization.html#gab47cd570de4c39a53b4da2d830d4568c">leastAngleRegression</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.optimization.leastSquares">
<tt class="descclassname">vigra.optimization.</tt><tt class="descname">leastSquares</tt><big>(</big><em>(object)A</em>, <em>(object)b</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.optimization.leastSquares" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform plain linear regression.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Optimization.html#gab3be347f5631d0aa2ee74c07479e0383">leastSquares</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.optimization.nonnegativeLeastSquares">
<tt class="descclassname">vigra.optimization.</tt><tt class="descname">nonnegativeLeastSquares</tt><big>(</big><em>(object)A</em>, <em>(object)b</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.optimization.nonnegativeLeastSquares" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform linear regression where the solution is constrained to be non-negative.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Optimization.html#ga0bc5b5c5ef032c809f1008ca9f13c68b">nonnegativeLeastSquares</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.optimization.ridgeRegression">
<tt class="descclassname">vigra.optimization.</tt><tt class="descname">ridgeRegression</tt><big>(</big><em>(object)A</em>, <em>(object)b</em>, <em>(float)lambda</em><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.optimization.ridgeRegression" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform linear regression with L2 regularization.</p>
<p>&#8216;lambda&#8217; is the regularization parameter - the larger it is, the more
biased towards zero the solution will become.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__Optimization.html#ga647810e9f3f2ff2e401f410b4855c58a">ridgeRegression</a> in the vigra C++ documentation.</p>
</dd></dl>

</div>
<div class="section" id="machine-learning">
<h2><a class="toc-backref" href="#id96">Machine Learning</a><a class="headerlink" href="#machine-learning" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.learning will eventually provide a wide range of machine learning
tools. Right now, it only contains an implementation of the random forest classifier
and probabilistic latent semantic analysis (pLSA) as an example for unsupervised learning.</p>
<span class="target" id="module-vigra.learning"></span><dl class="function">
<dt id="vigra.learning.pLSA">
<tt class="descclassname">vigra.learning.</tt><tt class="descname">pLSA</tt><big>(</big><em>(object)features</em>, <em>(int)nComponents</em><span class="optional">[</span>, <em>(int)nIterations=50</em><span class="optional">[</span>, <em>(float)minGain=0.0001</em><span class="optional">[</span>, <em>(bool)normalize=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; tuple :<a class="headerlink" href="#vigra.learning.pLSA" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform probabilistic latent semantic analysis.</p>
<p>The imput matrix &#8216;features&#8217; must have shape (nFeatures*nSamples). PCA will
reduce it to a smaller matrix &#8216;C&#8217; with shape (nComponents*nSamples) that 
preserves as much information as possible. Specifically, the call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">pLSA</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>returns a projection matrix &#8216;P&#8217; with shape (nComponents*nFeatures)
such that the matrix <tt class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">numpy.dot(P,</span> <span class="pre">C)</span></tt> is a rank-nComponents matrix
that approximates the matrix &#8216;features&#8217; well under the pLSA criterion.
Note that the result of pLSA() is not unique, since the algorithm uses random
initialization.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Unsupervised__Decomposition.html#ga7aff6f8e1ad85add65d226bcd899e07b">pLSA</a> in the C++ documentation for more detailed
information.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.learning.principalComponents">
<tt class="descclassname">vigra.learning.</tt><tt class="descname">principalComponents</tt><big>(</big><em>(object)features</em>, <em>(int)nComponents</em><big>)</big> &rarr; tuple :<a class="headerlink" href="#vigra.learning.principalComponents" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform principal component analysis.</p>
<p>The imput matrix &#8216;features&#8217; must have shape (nFeatures*nSamples). PCA will
reduce it to a smaller matrix &#8216;C&#8217; with shape (nComponents*nSamples) that 
preserves as much variance as possible. Specifically, the call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">P</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">principalComponents</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>returns a projection matrix &#8216;P&#8217; with shape (nComponents*nFeatures)
such that <tt class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">numpy.dot(numpy.transpose(P),</span> <span class="pre">features)</span></tt>. Conversely, the
matrix  <tt class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">numpy.dot(P,</span> <span class="pre">C)</span></tt> is the best possible rank-nComponents
approximation to the matrix &#8216;features&#8217; under the least-squares criterion.</p>
<p>See <a class="reference external" href="../../doc/vigra/group__Unsupervised__Decomposition.html#ga690e2fe92330ced7c6a604ddbff1197a">principalComponents</a> in the C++ documentation for more detailed
information.</p>
</dd></dl>

<dl class="class">
<dt id="vigra.learning.RandomForest">
<em class="property">class </em><tt class="descclassname">vigra.learning.</tt><tt class="descname">RandomForest</tt><big>(</big><em>(object)arg1</em>, <em>(int)file_id</em><span class="optional">[</span>, <em>(str)pathInFile=''</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#vigra.learning.RandomForest" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Load from an open HDF5 file id (note that the keyword &#8216;file_id&#8217; must</dt>
<dd><p class="first">be specified explicitly, otherwise the argument will be interpreted as
the number of trees to be used):</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">RandomForest</span><span class="p">(</span><span class="n">file_id</span><span class="o">=</span><span class="nb">id</span><span class="p">,</span> <span class="n">pathInFile</span><span class="o">=</span><span class="s">&#39;/path/to/dataset&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p>__init__( (object)arg1, (str)filename [, (str)pathInFile=&#8217;&#8216;]) -&gt; object :</p>
<blockquote>
<div><p>Load from HDF5 file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">RandomForest</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">pathInFile</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>__init__( (object)arg1 [, (int)treeCount=255 [, (int)mtry=-1 [, (int)min_split_node_size=1 [, (int)training_set_size=0 [, (float)training_set_proportions=1.0 [, (bool)sample_with_replacement=True [, (bool)sample_classes_individually=False [, (bool)prepare_online_learning=False [, (object)labels=[]]]]]]]]]]) -&gt; object :</p>
<blockquote>
<div><p>Construct a new random forest:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">RandomForest</span><span class="p">(</span><span class="n">treeCount</span> <span class="o">=</span> <span class="mi">255</span><span class="p">,</span> <span class="n">mtry</span><span class="o">=</span><span class="n">RF_SQRT</span><span class="p">,</span> <span class="n">min_split_node_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
             <span class="n">training_set_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">training_set_proportions</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
             <span class="n">sample_with_replacement</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">sample_classes_individually</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">prepare_online_learning</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>treeCount:</dt>
<dd>controls the number of trees that are created.</dd>
<dt>labels:</dt>
<dd>is a list specifying the permitted labels.
If empty (default), the labels are automatically determined
from the training data. A non-empty list is useful when some
labels lack training examples.</dd>
</dl>
<p>See <a href="#id105"><span class="problematic" id="id106">RandomForest_</span></a> and <a href="#id107"><span class="problematic" id="id108">RandomForestOptions_</span></a> in the C++ documentation for the meaning of the other parameters.</p>
</div></blockquote>
<dl class="method">
<dt id="vigra.learning.RandomForest.featureCount">
<tt class="descname">featureCount</tt><big>(</big><em>(RandomForest)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.learning.RandomForest.featureCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of features the RandomForest works with.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.labelCount">
<tt class="descname">labelCount</tt><big>(</big><em>(RandomForest)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.learning.RandomForest.labelCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of labels, the RandomForest knows.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.learnRF">
<tt class="descname">learnRF</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(object)trainData</em>, <em>(object)trainLabels</em><span class="optional">[</span>, <em>(int)randomSeed=0</em><span class="optional">[</span>, <em>(int)maxDepth=-1</em><span class="optional">[</span>, <em>(int)minSize=0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; float :<a class="headerlink" href="#vigra.learning.RandomForest.learnRF" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains a random Forest using &#8216;trainData&#8217; and &#8216;trainLabels&#8217;.</p>
<p>and returns the OOB. See the vigra documentation for the meaning af the rest of the parameters.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.learnRFWithFeatureSelection">
<tt class="descname">learnRFWithFeatureSelection</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(object)trainData</em>, <em>(object)trainLabels</em><span class="optional">[</span>, <em>(int)randomSeed=0</em><span class="optional">]</span><big>)</big> &rarr; tuple :<a class="headerlink" href="#vigra.learning.RandomForest.learnRFWithFeatureSelection" title="Permalink to this definition">¶</a></dt>
<dd><p>Train a random Forest using &#8216;trainData&#8217; and &#8216;trainLabels&#8217;.</p>
<p>and returns the OOB and the Variable importanceSee the vigra documentation for the meaning af the rest of the paremeters.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.onlineLearn">
<tt class="descname">onlineLearn</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(object)trainData</em>, <em>(object)trainLabels</em>, <em>(int)startIndex</em><span class="optional">[</span>, <em>(bool)adjust_thresholds=False</em><span class="optional">[</span>, <em>(int)randomSeed=0</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.learning.RandomForest.onlineLearn" title="Permalink to this definition">¶</a></dt>
<dd><p>Learn online.</p>
<p>Works only if forest has been created with prepare_online_learning=true. Needs the old training data and the new appened, starting at startIndex.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.predictLabels">
<tt class="descname">predictLabels</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(object)testData</em><span class="optional">[</span>, <em>(object)nanLabel=None</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.learning.RandomForest.predictLabels" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict labels on &#8216;testData&#8217;.</p>
<p>If a &#8216;nanLabel&#8217; is provided, it will be returned for all rows of
the &#8216;testData&#8217; that contain an NaN value. Otherwise, an exception is
thrown whenever Nan is encountered.</p>
<p>The output is an array containing a label for every test samples.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.predictProbabilities">
<tt class="descname">predictProbabilities</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(object)testData</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.learning.RandomForest.predictProbabilities" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Predict probabilities for different classes on &#8216;testData&#8217;.</p>
<p>The output is an array containing a probability for every test sample and class.</p>
</div></blockquote>
<dl class="docutils">
<dt>predictProbabilities( (RandomForest)arg1, (RF_OnlinePredictionSet)testData [, (object)out=None]) -&gt; object :</dt>
<dd>The output is an array containing a probability for every test sample and class.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.reLearnTree">
<tt class="descname">reLearnTree</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(object)trainData</em>, <em>(object)trainLabels</em>, <em>(int)treeId</em><span class="optional">[</span>, <em>(int)randomSeed=0</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.learning.RandomForest.reLearnTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-learn one tree of the forest using &#8216;trainData&#8217; and &#8216;trainLabels&#8217;.</p>
<p>and returns the OOB. This might be helpful in an online learning setup to improve the classifier.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.treeCount">
<tt class="descname">treeCount</tt><big>(</big><em>(RandomForest)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.learning.RandomForest.treeCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the &#8216;treeCount&#8217;, that was set when constructing the RandomForest.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForest.writeHDF5">
<tt class="descname">writeHDF5</tt><big>(</big><em>(RandomForest)arg1</em>, <em>(str)filename</em><span class="optional">[</span>, <em>(str)pathInFile=''</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#vigra.learning.RandomForest.writeHDF5" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Store the random forest in the given HDF5 file &#8216;filename&#8217; under the internal
path &#8216;pathInFile&#8217;.</div></blockquote>
<dl class="docutils">
<dt>writeHDF5( (RandomForest)arg1, (int)file_id [, (str)pathInFile=&#8217;&#8216;]) -&gt; None :</dt>
<dd>Store the random forest in the HDF5 file with given &#8216;file_id&#8217; 
under the internal path &#8216;pathInFile&#8217;.</dd>
</dl>
</dd></dl>

</dd></dl>

<p>For more information, refer to <a href="#id109"><span class="problematic" id="id110">RandomForest_</span></a> in the C++ documentation.</p>
<dl class="class">
<dt id="vigra.learning.RandomForestOld">
<em class="property">class </em><tt class="descclassname">vigra.learning.</tt><tt class="descname">RandomForestOld</tt><big>(</big><em>(object)arg1</em>, <em>(object)trainData</em>, <em>(object)trainLabels</em><span class="optional">[</span>, <em>(int)treeCount=255</em><span class="optional">[</span>, <em>(int)mtry=0</em><span class="optional">[</span>, <em>(int)min_split_node_size=1</em><span class="optional">[</span>, <em>(int)training_set_size=0</em><span class="optional">[</span>, <em>(float)training_set_proportions=1.0</em><span class="optional">[</span>, <em>(bool)sample_with_replacement=True</em><span class="optional">[</span>, <em>(bool)sample_classes_individually=False</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#vigra.learning.RandomForestOld" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">RandomForestOld</span><span class="p">(</span><span class="n">trainData</span><span class="p">,</span> <span class="n">trainLabels</span><span class="p">,</span>
                <span class="n">treeCount</span> <span class="o">=</span> <span class="mi">255</span><span class="p">,</span> <span class="n">mtry</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_split_node_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">training_set_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">training_set_proportions</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">sample_with_replacement</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">sample_classes_individually</span><span class="o">=</span><span class="bp">False</span><span class="p">,)</span>
</pre></div>
</div>
<p>Construct and train a RandomForest using &#8216;trainData&#8217; and &#8216;trainLabels&#8217;. &#8216;treeCount&#8217; controls the number of trees that are created.</p>
<p>See <a href="#id111"><span class="problematic" id="id112">RandomForest_</span></a> and <a href="#id113"><span class="problematic" id="id114">RandomForestOptions_</span></a> in the C++ documentation for the meaning of the other parameters.</p>
<dl class="method">
<dt id="vigra.learning.RandomForestOld.featureCount">
<tt class="descname">featureCount</tt><big>(</big><em>(RandomForestOld)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.learning.RandomForestOld.featureCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of features the RandomForest works with.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForestOld.labelCount">
<tt class="descname">labelCount</tt><big>(</big><em>(RandomForestOld)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.learning.RandomForestOld.labelCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of labels, the RanfomForest knows.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForestOld.predictLabels">
<tt class="descname">predictLabels</tt><big>(</big><em>(RandomForestOld)arg1</em>, <em>(object)testData</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.learning.RandomForestOld.predictLabels" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict labels on &#8216;testData&#8217;.The output is an array containing a labels for every test samples.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForestOld.predictProbabilities">
<tt class="descname">predictProbabilities</tt><big>(</big><em>(RandomForestOld)arg1</em>, <em>(object)testData</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.learning.RandomForestOld.predictProbabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict probabilities for different classes on &#8216;testData&#8217;.The output is an array containing a probability for every test sample and class.</p>
</dd></dl>

<dl class="method">
<dt id="vigra.learning.RandomForestOld.treeCount">
<tt class="descname">treeCount</tt><big>(</big><em>(RandomForestOld)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.learning.RandomForestOld.treeCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the &#8216;treeCount&#8217;, that was set when constructing the RandomForest.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="noise-estimation-and-normalization">
<h2><a class="toc-backref" href="#id97">Noise Estimation and Normalization</a><a class="headerlink" href="#noise-estimation-and-normalization" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.noise provides noise estimation and normalization according to a
method proposed by Foerstner.</p>
<span class="target" id="module-vigra.noise"></span><dl class="function">
<dt id="vigra.noise.linearNoiseNormalization">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">linearNoiseNormalization</tt><big>(</big><em>(object)image</em>, <em>(float)a0</em>, <em>(float)a1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.noise.linearNoiseNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Noise normalization by means of an estimated linear noise model.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__NoiseNormalization.html#ga98960448c1bac4e2e068e7dd6ffdfe66">linearNoiseNormalization</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.noise.linearNoiseNormalizationEstimated">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">linearNoiseNormalizationEstimated</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(bool)useGradient=True</em><span class="optional">[</span>, <em>(int)windowRadius=6</em><span class="optional">[</span>, <em>(int)clusterCount=10</em><span class="optional">[</span>, <em>(float)averagingQuantile=0.8</em><span class="optional">[</span>, <em>(float)noiseEstimationQuantile=1.5</em><span class="optional">[</span>, <em>(float)noiseVarianceInitialGuess=10.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.noise.linearNoiseNormalizationEstimated" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="vigra.noise.noiseVarianceClustering">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">noiseVarianceClustering</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(bool)useGradient=True</em><span class="optional">[</span>, <em>(int)windowRadius=6</em><span class="optional">[</span>, <em>(int)clusterCount=10</em><span class="optional">[</span>, <em>(float)averagingQuantile=0.8</em><span class="optional">[</span>, <em>(float)noiseEstimationQuantile=1.5</em><span class="optional">[</span>, <em>(float)noiseVarianceInitialGuess=10.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.noise.noiseVarianceClustering" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the noise variance as a function of the image intensity and cluster the results.
This operator first calls noiseVarianceEstimation() to obtain a sequence of intensity/variance pairs,
which are then clustered using the median cut algorithm. Then the cluster centers (i.e. average variance vs. average intensity)
are determined and returned in the result sequence.</p>
<p>Since the length of the resulting array is not known beforhand, it cannot be written into an preallocated array
(the &#8220;out&#8221; argument in most other vigra python functions)
.
For details see the vigra documentation <a class="reference external" href="../../doc/vigra/group__NoiseNormalization.html#ga78d48b96e66ee00680567fe9b84d2b71">noiseVarianceClustering</a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.noise.noiseVarianceEstimation">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">noiseVarianceEstimation</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(bool)useGradient=True</em><span class="optional">[</span>, <em>(int)windowRadius=6</em><span class="optional">[</span>, <em>(int)clusterCount=10</em><span class="optional">[</span>, <em>(float)averagingQuantile=0.8</em><span class="optional">[</span>, <em>(float)noiseEstimationQuantile=1.5</em><span class="optional">[</span>, <em>(float)noiseVarianceInitialGuess=10.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.noise.noiseVarianceEstimation" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the noise variance as a function of the image intensity.</p>
<p>Returns an array with the means in the first column and the variances in the second column.
Since the length of the resulting array is not known beforhand, it can not be written into an preallocated array
(the &#8220;out&#8221; argument in most other vigra python functions.</p>
<p>For details see the vigra documentation <a class="reference external" href="../../doc/vigra/group__NoiseNormalization.html#gac7a0f3b1b8de238ad40a4925f9e62d3f">noiseVarianceEstimation</a>.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.noise.nonparametricNoiseNormalization">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">nonparametricNoiseNormalization</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(bool)useGradient=True</em><span class="optional">[</span>, <em>(int)windowRadius=6</em><span class="optional">[</span>, <em>(int)clusterCount=10</em><span class="optional">[</span>, <em>(float)averagingQuantile=0.8</em><span class="optional">[</span>, <em>(float)noiseEstimationQuantile=1.5</em><span class="optional">[</span>, <em>(float)noiseVarianceInitialGuess=10.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.noise.nonparametricNoiseNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Noise normalization by means of an estimated non-parametric noise model.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__NoiseNormalization.html#ga1d937331b5773114d6c1187560bb901e">nonparametricNoiseNormalization</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.noise.quadraticNoiseNormalization">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">quadraticNoiseNormalization</tt><big>(</big><em>(object)image</em>, <em>(float)a0</em>, <em>(float)a1</em>, <em>(float)a2</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.noise.quadraticNoiseNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Noise normalization by means of an estimated quadratic noise model.</p>
<p>For details see <a class="reference external" href="../../doc/vigra/group__NoiseNormalization.html#gaeac0754774b3c445c953359f5d2d495f">quadraticNoiseNormalization</a> in the vigra C++ documentation.</p>
</dd></dl>

<dl class="function">
<dt id="vigra.noise.quadraticNoiseNormalizationEstimated">
<tt class="descclassname">vigra.noise.</tt><tt class="descname">quadraticNoiseNormalizationEstimated</tt><big>(</big><em>(object)image</em><span class="optional">[</span>, <em>(bool)useGradient=True</em><span class="optional">[</span>, <em>(int)windowRadius=6</em><span class="optional">[</span>, <em>(int)clusterCount=10</em><span class="optional">[</span>, <em>(float)averagingQuantile=0.8</em><span class="optional">[</span>, <em>(float)noiseEstimationQuantile=1.5</em><span class="optional">[</span>, <em>(float)noiseVarianceInitialGuess=10.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.noise.quadraticNoiseNormalizationEstimated" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="histogram-and-channel-representation">
<h2><a class="toc-backref" href="#id98">Histogram and Channel Representation</a><a class="headerlink" href="#histogram-and-channel-representation" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.histogram provides histograms and channel representation</p>
<span class="target" id="module-vigra.histogram"></span><dl class="function">
<dt id="vigra.histogram.gaussianCoHistogram">
<tt class="descclassname">vigra.histogram.</tt><tt class="descname">gaussianCoHistogram</tt><big>(</big><em>(object)imageA</em>, <em>(object)imageB</em>, <em>(object)minVals</em>, <em>(object)maxVals</em>, <em>(object)bins</em>, <em>(object)sigma</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.histogram.gaussianCoHistogram" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><dl class="docutils">
<dt>C++ signature :</dt>
<dd>vigra::NumpyAnyArray gaussianCoHistogram(vigra::NumpyArray&lt;2u, float, vigra::StridedArrayTag&gt;,vigra::NumpyArray&lt;2u, float, vigra::StridedArrayTag&gt;,vigra::TinyVector&lt;float, 2&gt;,vigra::TinyVector&lt;float, 2&gt;,vigra::TinyVector&lt;int, 2&gt;,vigra::TinyVector&lt;float, 3&gt; [,vigra::NumpyArray&lt;4u, float, vigra::StridedArrayTag&gt;=None])</dd>
</dl>
</div></blockquote>
<p>gaussianCoHistogram( (object)imageA, (object)imageB, (object)minVals, (object)maxVals, (object)bins, (object)sigma [, (object)out=None]) -&gt; object :</p>
<blockquote>
<div><dl class="docutils">
<dt>C++ signature :</dt>
<dd>vigra::NumpyAnyArray gaussianCoHistogram(vigra::NumpyArray&lt;3u, float, vigra::StridedArrayTag&gt;,vigra::NumpyArray&lt;3u, float, vigra::StridedArrayTag&gt;,vigra::TinyVector&lt;float, 2&gt;,vigra::TinyVector&lt;float, 2&gt;,vigra::TinyVector&lt;int, 2&gt;,vigra::TinyVector&lt;float, 3&gt; [,vigra::NumpyArray&lt;5u, float, vigra::StridedArrayTag&gt;=None])</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.histogram.gaussianHistogram">
<tt class="descclassname">vigra.histogram.</tt><tt class="descname">gaussianHistogram</tt><big>(</big><em>image</em>, <em>minVals</em>, <em>maxVals</em>, <em>bins=30</em>, <em>sigma=3.0</em>, <em>sigmaBin=2.0</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.histogram.gaussianHistogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="vigra.histogram.gaussianHistogram_">
<tt class="descclassname">vigra.histogram.</tt><tt class="descname">gaussianHistogram_</tt><big>(</big><em>(object)image</em>, <em>(object)minVals</em>, <em>(object)maxVals</em><span class="optional">[</span>, <em>(int)bins=30</em><span class="optional">[</span>, <em>(float)sigma=3.0</em><span class="optional">[</span>, <em>(float)sigmaBin=2.0</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.histogram.gaussianHistogram_" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><dl class="docutils">
<dt>C++ signature :</dt>
<dd>vigra::NumpyAnyArray gaussianHistogram_(vigra::NumpyArray&lt;2u, vigra::TinyVector&lt;float, 1&gt;, vigra::StridedArrayTag&gt;,vigra::TinyVector&lt;float, 1&gt;,vigra::TinyVector&lt;float, 1&gt; [,unsigned long=30 [,float=3.0 [,float=2.0 [,vigra::NumpyArray&lt;4u, float, vigra::StridedArrayTag&gt;=None]]]])</dd>
</dl>
</div></blockquote>
<p>gaussianHistogram_( (object)image, (object)minVals, (object)maxVals [, (int)bins=30 [, (float)sigma=3.0 [, (float)sigmaBin=2.0 [, (object)out=None]]]]) -&gt; object :</p>
<blockquote>
<div><dl class="docutils">
<dt>C++ signature :</dt>
<dd>vigra::NumpyAnyArray gaussianHistogram_(vigra::NumpyArray&lt;2u, vigra::TinyVector&lt;float, 3&gt;, vigra::StridedArrayTag&gt;,vigra::TinyVector&lt;float, 3&gt;,vigra::TinyVector&lt;float, 3&gt; [,unsigned long=30 [,float=3.0 [,float=2.0 [,vigra::NumpyArray&lt;4u, float, vigra::StridedArrayTag&gt;=None]]]])</dd>
</dl>
</div></blockquote>
<p>gaussianHistogram_( (object)image, (object)minVals, (object)maxVals [, (int)bins=30 [, (float)sigma=3.0 [, (float)sigmaBin=2.0 [, (object)out=None]]]]) -&gt; object :</p>
<blockquote>
<div><dl class="docutils">
<dt>C++ signature :</dt>
<dd>vigra::NumpyAnyArray gaussianHistogram_(vigra::NumpyArray&lt;3u, vigra::TinyVector&lt;float, 1&gt;, vigra::StridedArrayTag&gt;,vigra::TinyVector&lt;float, 1&gt;,vigra::TinyVector&lt;float, 1&gt; [,unsigned long=30 [,float=3.0 [,float=2.0 [,vigra::NumpyArray&lt;5u, float, vigra::StridedArrayTag&gt;=None]]]])</dd>
</dl>
</div></blockquote>
<p>gaussianHistogram_( (object)image, (object)minVals, (object)maxVals [, (int)bins=30 [, (float)sigma=3.0 [, (float)sigmaBin=2.0 [, (object)out=None]]]]) -&gt; object :</p>
<blockquote>
<div><dl class="docutils">
<dt>C++ signature :</dt>
<dd>vigra::NumpyAnyArray gaussianHistogram_(vigra::NumpyArray&lt;3u, vigra::TinyVector&lt;float, 3&gt;, vigra::StridedArrayTag&gt;,vigra::TinyVector&lt;float, 3&gt;,vigra::TinyVector&lt;float, 3&gt; [,unsigned long=30 [,float=3.0 [,float=2.0 [,vigra::NumpyArray&lt;5u, float, vigra::StridedArrayTag&gt;=None]]]])</dd>
</dl>
</div></blockquote>
<p>gaussianHistogram_( (object)image, (object)minVals, (object)maxVals [, (int)bins=30 [, (float)sigma=3.0 [, (float)sigmaBin=2.0 [, (object)out=None]]]]) -&gt; object :</p>
<blockquote>
<div><dl class="docutils">
<dt>C++ signature :</dt>
<dd>vigra::NumpyAnyArray gaussianHistogram_(vigra::NumpyArray&lt;3u, vigra::TinyVector&lt;float, 10&gt;, vigra::StridedArrayTag&gt;,vigra::TinyVector&lt;float, 10&gt;,vigra::TinyVector&lt;float, 10&gt; [,unsigned long=30 [,float=3.0 [,float=2.0 [,vigra::NumpyArray&lt;5u, float, vigra::StridedArrayTag&gt;=None]]]])</dd>
</dl>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="graphs-and-algorithms-on-graphs">
<span id="sec-graph-algorithms"></span><h2><a class="toc-backref" href="#id99">Graphs and Algorithms on Graphs</a><a class="headerlink" href="#graphs-and-algorithms-on-graphs" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.graphs provides graphs and graph algorithms</p>
<span class="target" id="module-vigra.graphs"></span><dl class="class">
<dt id="vigra.graphs.AdjacencyListGraph">
<em class="property">class </em><tt class="descclassname">vigra.graphs.</tt><tt class="descname">AdjacencyListGraph</tt><big>(</big><em>(object)arg1</em>, <em>(int)arg2</em>, <em>(int)arg3</em><big>)</big><a class="headerlink" href="#vigra.graphs.AdjacencyListGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>undirected adjacency list graph</p>
<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.addEdge">
<tt class="descname">addEdge</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(NodeAdjacencyListGraph)arg2</em>, <em>(NodeAdjacencyListGraph)arg3</em><big>)</big> &rarr; EdgeAdjacencyListGraph<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.addEdge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.addEdges">
<tt class="descname">addEdges</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(object)edges</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.addEdges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.addNode">
<tt class="descname">addNode</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; NodeAdjacencyListGraph<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.addNode" title="Permalink to this definition">¶</a></dt>
<dd><p>addNode( (AdjacencyListGraph)arg1, (int)arg2) -&gt; NodeAdjacencyListGraph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.arcFromId">
<tt class="descname">arcFromId</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; ArcAdjacencyListGraph :<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.arcFromId" title="Permalink to this definition">¶</a></dt>
<dd><p>get the arc descriptor from the given id</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.arcIds">
<tt class="descname">arcIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.arcIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.AdjacencyListGraph.arcNum">
<tt class="descname">arcNum</tt><a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.arcNum" title="Permalink to this definition">¶</a></dt>
<dd><p>number of arcs (2*edgeNum for undirected graphs)</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.axistagsArcMap">
<tt class="descname">axistagsArcMap</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; AxisTags<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.axistagsArcMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.axistagsEdgeMap">
<tt class="descname">axistagsEdgeMap</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; AxisInfo<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.axistagsEdgeMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.axistagsNodeMap">
<tt class="descname">axistagsNodeMap</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; AxisInfo<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.axistagsNodeMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.deserialize">
<tt class="descname">deserialize</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; None<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.deserialize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.edgeFromArc">
<tt class="descname">edgeFromArc</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(ArcAdjacencyListGraph)arg2</em><big>)</big> &rarr; EdgeAdjacencyListGraph<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.edgeFromArc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.edgeFromId">
<tt class="descname">edgeFromId</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; EdgeAdjacencyListGraph :<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.edgeFromId" title="Permalink to this definition">¶</a></dt>
<dd><p>get the edge descriptor from the given id</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.edgeIds">
<tt class="descname">edgeIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.edgeIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.edgeIter">
<tt class="descname">edgeIter</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; EdgeIteratorHolderAdjacencyListGraph<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.edgeIter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.AdjacencyListGraph.edgeNum">
<tt class="descname">edgeNum</tt><a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.edgeNum" title="Permalink to this definition">¶</a></dt>
<dd><p>number of edges within the graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.findEdge">
<tt class="descname">findEdge</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(NodeAdjacencyListGraph)arg2</em>, <em>(NodeAdjacencyListGraph)arg3</em><big>)</big> &rarr; EdgeAdjacencyListGraph :<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.findEdge" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>find an edge between node u and v</div></blockquote>
<dl class="docutils">
<dt>findEdge( (AdjacencyListGraph)arg1, (int)arg2, (int)arg3) -&gt; EdgeAdjacencyListGraph :</dt>
<dd>find the edge between two nodes given their id</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.findEdges">
<tt class="descname">findEdges</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(object)nodeIdPairs</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.findEdges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.id">
<tt class="descname">id</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(NodeAdjacencyListGraph)arg2</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.id" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the id of a given node</div></blockquote>
<dl class="docutils">
<dt>id( (AdjacencyListGraph)arg1, (EdgeAdjacencyListGraph)arg2) -&gt; int :</dt>
<dd>get the id of a given edge</dd>
<dt>id( (AdjacencyListGraph)arg1, (ArcAdjacencyListGraph)arg2) -&gt; int :</dt>
<dd>get the id of a given arc</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.incEdgeIter">
<tt class="descname">incEdgeIter</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(NodeAdjacencyListGraph)arg2</em><big>)</big> &rarr; IncEdgeIteratorHolderAdjacencyListGraph<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.incEdgeIter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.intrinsicArcCoordinate">
<tt class="descname">intrinsicArcCoordinate</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.intrinsicArcCoordinate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.intrinsicArcMapShape">
<tt class="descname">intrinsicArcMapShape</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.intrinsicArcMapShape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.intrinsicEdgeCoordinate">
<tt class="descname">intrinsicEdgeCoordinate</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.intrinsicEdgeCoordinate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.intrinsicEdgeMapShape">
<tt class="descname">intrinsicEdgeMapShape</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.intrinsicEdgeMapShape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.intrinsicNodeCoordinate">
<tt class="descname">intrinsicNodeCoordinate</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.intrinsicNodeCoordinate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.intrinsicNodeMapShape">
<tt class="descname">intrinsicNodeMapShape</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.intrinsicNodeMapShape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.AdjacencyListGraph.maxArcId">
<tt class="descname">maxArcId</tt><a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.maxArcId" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum id of a valid arc in the graph</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.AdjacencyListGraph.maxEdgeId">
<tt class="descname">maxEdgeId</tt><a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.maxEdgeId" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum id of a valid node in the graph</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.AdjacencyListGraph.maxNodeId">
<tt class="descname">maxNodeId</tt><a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.maxNodeId" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum id of a valid edge in the graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.neighbourNodeIter">
<tt class="descname">neighbourNodeIter</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(NodeAdjacencyListGraph)arg2</em><big>)</big> &rarr; NeighbourNodeIteratorHolderAdjacencyListGraph<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.neighbourNodeIter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.nodeFromId">
<tt class="descname">nodeFromId</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(int)id</em><big>)</big> &rarr; NodeAdjacencyListGraph :<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.nodeFromId" title="Permalink to this definition">¶</a></dt>
<dd><p>get the node descriptor from the given id</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.nodeIdMap">
<tt class="descname">nodeIdMap</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.nodeIdMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.nodeIds">
<tt class="descname">nodeIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.nodeIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.nodeIter">
<tt class="descname">nodeIter</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; NodeIteratorHolderAdjacencyListGraph<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.nodeIter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.AdjacencyListGraph.nodeNum">
<tt class="descname">nodeNum</tt><a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.nodeNum" title="Permalink to this definition">¶</a></dt>
<dd><p>number of nodes within the graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.serializationSize">
<tt class="descname">serializationSize</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.serializationSize" title="Permalink to this definition">¶</a></dt>
<dd><p>number of integers needed to serialize graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.serialize">
<tt class="descname">serialize</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)serialization=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.serialize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.source">
<tt class="descname">source</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(ArcAdjacencyListGraph)arg2</em><big>)</big> &rarr; NodeAdjacencyListGraph<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.source" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.target">
<tt class="descname">target</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(ArcAdjacencyListGraph)arg2</em><big>)</big> &rarr; NodeAdjacencyListGraph<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.target" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.u">
<tt class="descname">u</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(EdgeAdjacencyListGraph)arg2</em><big>)</big> &rarr; NodeAdjacencyListGraph :<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.u" title="Permalink to this definition">¶</a></dt>
<dd><p>get the u node of an edge</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.uId">
<tt class="descname">uId</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(EdgeAdjacencyListGraph)arg2</em><big>)</big> &rarr; int<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.uId" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.uIds">
<tt class="descname">uIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.uIds" title="Permalink to this definition">¶</a></dt>
<dd><p>uIds( (AdjacencyListGraph)arg1, (object)edgeIds [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.uvId">
<tt class="descname">uvId</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(EdgeAdjacencyListGraph)arg2</em><big>)</big> &rarr; tuple<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.uvId" title="Permalink to this definition">¶</a></dt>
<dd><p>uvId( (AdjacencyListGraph)arg1, (int)arg2) -&gt; tuple</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.uvIds">
<tt class="descname">uvIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.uvIds" title="Permalink to this definition">¶</a></dt>
<dd><p>uvIds( (AdjacencyListGraph)arg1, (object)edgeIds [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.v">
<tt class="descname">v</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(EdgeAdjacencyListGraph)arg2</em><big>)</big> &rarr; NodeAdjacencyListGraph :<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.v" title="Permalink to this definition">¶</a></dt>
<dd><p>geht the v node of an edge</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.vId">
<tt class="descname">vId</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(EdgeAdjacencyListGraph)arg2</em><big>)</big> &rarr; int<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.vId" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.vIds">
<tt class="descname">vIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.vIds" title="Permalink to this definition">¶</a></dt>
<dd><p>vIds( (AdjacencyListGraph)arg1, (object)edgeIds [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.validArcIds">
<tt class="descname">validArcIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.validArcIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.validEdgeIds">
<tt class="descname">validEdgeIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.validEdgeIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.AdjacencyListGraph.validNodeIds">
<tt class="descname">validNodeIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.AdjacencyListGraph.validNodeIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="vigra.graphs.agglomerativeClustering">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">agglomerativeClustering</tt><big>(</big><em>graph</em>, <em>edgeWeights=None</em>, <em>edgeLengths=None</em>, <em>nodeFeatures=None</em>, <em>nodeSizes=None</em>, <em>nodeLabels=None</em>, <em>nodeNumStop=None</em>, <em>beta=0.5</em>, <em>metric='l1'</em>, <em>wardness=1.0</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.agglomerativeClustering" title="Permalink to this definition">¶</a></dt>
<dd><p>agglomerative hierarchicalClustering
Keyword Arguments :</p>
<blockquote>
<div><ul>
<li><p class="first">graph : input graph</p>
</li>
<li><p class="first">edgeWeights : edge weights / indicators (default : None)</p>
</li>
<li><dl class="first docutils">
<dt>edgeLengths <span class="classifier-delimiter">:</span> <span class="classifier">length  / weight of each edge (default</span> <span class="classifier-delimiter">:</span> <span class="classifier">None)</span></dt>
<dd><p class="first last">Since we do weighted mean agglomeration, a length/weight
is needed for each edge to merge 2 edges w.r.t. weighted mean.
If no edgeLengths is given, &#8216;getEdgeLengths&#8217; is called.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>nodeFeatures <span class="classifier-delimiter">:</span> <span class="classifier">a feature vector for each node (default: None)</span></dt>
<dd><p class="first last">A feature vector as RGB values,or a histogram for each node.
Within the agglomeration, an additional edge weight will be
computed from the &#8220;difference&#8221; between the features of two adjacent nodes.
The metric specified in the keyword &#8216;metric&#8217; is used to compute this
difference</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>nodeSizes <span class="classifier-delimiter">:</span> <span class="classifier">size  / weight of each node (default</span> <span class="classifier-delimiter">:</span> <span class="classifier">None)</span></dt>
<dd><p class="first last">Since we do weighted mean agglomeration, a size / weight
is needed for each node to merge 2 edges w.r.t. weighted mean.
If no nodeSizes is given, &#8216;getNodeSizes&#8217; is called.</p>
</dd>
</dl>
</li>
<li><p class="first">nodeNumStop : stop the agglomeration at a given nodeNum (default : graph.nodeNum/2)</p>
</li>
<li><dl class="first docutils">
<dt>beta <span class="classifier-delimiter">:</span> <span class="classifier">weight between edgeWeights and nodeFeatures based edgeWeights (default:0.5) :</span></dt>
<dd><p class="first last">0.0 means only edgeWeights (from keyword edge weights) and 1.0 means only edgeWeights
from nodeFeatures differences</p>
</dd>
</dl>
</li>
<li><p class="first">metric : metric used to compute node feature difference (default : &#8216;l1&#8217;)</p>
</li>
<li><p class="first">wardness : 0 means do not apply wards critrion, 1.0 means fully apply wards critrion (default : 1.0)</p>
</li>
<li><p class="first">out : preallocated nodeMap for the resulting labeling (default : None)</p>
</li>
</ul>
</div></blockquote>
<p>Returns:</p>
<blockquote>
<div>A node labele map encoding the segmentation</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.cyclesEdges">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">cyclesEdges</tt><big>(</big><em>(AdjacencyListGraph)graph</em>, <em>(object)graph</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.cyclesEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>cyclesEdges( (GridGraphUndirected2d)graph, (object)graph [, (object)out=None]) -&gt; object</p>
<p>cyclesEdges( (GridGraphUndirected3d)graph, (object)graph [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.edgeFeaturesFromImage">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">edgeFeaturesFromImage</tt><big>(</big><em>(GridGraphUndirected2d)graph</em>, <em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.graphs.edgeFeaturesFromImage" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>convert an image with shape = graph.shape OR shape = graph.shape <a href="#id2"><span class="problematic" id="id3">*</span></a>2 -1 to an edge weight array</div></blockquote>
<dl class="docutils">
<dt>edgeFeaturesFromImage( (GridGraphUndirected2d)graph, (object)image [, (object)out=None]) -&gt; object :</dt>
<dd>convert an image with shape = graph.shape OR shape = graph.shape <a href="#id4"><span class="problematic" id="id5">*</span></a>2 -1 to an edge weight array</dd>
<dt>edgeFeaturesFromImage( (GridGraphUndirected3d)graph, (object)image [, (object)out=None]) -&gt; object :</dt>
<dd>convert an image with shape = graph.shape OR shape = graph.shape <a href="#id6"><span class="problematic" id="id7">*</span></a>2 -1 to an edge weight array</dd>
<dt>edgeFeaturesFromImage( (GridGraphUndirected3d)graph, (object)image [, (object)out=None]) -&gt; object :</dt>
<dd>convert an image with shape = graph.shape OR shape = graph.shape <a href="#id8"><span class="problematic" id="id9">*</span></a>2 -1 to an edge weight array</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.edgeFeaturesFromInterpolatedImage">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">edgeFeaturesFromInterpolatedImage</tt><big>(</big><em>(GridGraphUndirected2d)graph</em>, <em>(object)image</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object :<a class="headerlink" href="#vigra.graphs.edgeFeaturesFromInterpolatedImage" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>convert an image with <tt class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">graph.shape*2</span> <span class="pre">-</span> <span class="pre">1</span></tt> to an edge weight array</div></blockquote>
<dl class="docutils">
<dt>edgeFeaturesFromInterpolatedImage( (GridGraphUndirected3d)graph, (object)image [, (object)out=None]) -&gt; object :</dt>
<dd>convert an image with <tt class="docutils literal"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">graph.shape*2</span> <span class="pre">-</span> <span class="pre">1</span></tt> to an edge weight array</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.edgeWeightedWatersheds">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">edgeWeightedWatersheds</tt><big>(</big><em>graph</em>, <em>edgeWeights</em>, <em>seeds</em>, <em>backgroundLabel=None</em>, <em>backgroundBias=None</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.edgeWeightedWatersheds" title="Permalink to this definition">¶</a></dt>
<dd><p>edge weighted seeded watersheds</p>
<p>Keyword Arguments :</p>
<blockquote>
<div><ul>
<li><p class="first">graph : input graph</p>
</li>
<li><p class="first">edgeWeights : evaluation weights</p>
</li>
<li><dl class="first docutils">
<dt>seeds <span class="classifier-delimiter">:</span> <span class="classifier">node map with seeds .</span></dt>
<dd><p class="first last">For at least one node, seeds must be nonzero</p>
</dd>
</dl>
</li>
<li><p class="first">backgroundLabel : a specific backgroundLabel (default : None)</p>
</li>
<li><p class="first">backgroundBias : backgroundBias (default  : None)</p>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.felzenszwalbSegmentation">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">felzenszwalbSegmentation</tt><big>(</big><em>graph</em>, <em>edgeWeights</em>, <em>nodeSizes=None</em>, <em>k=1.0</em>, <em>nodeNumStop=None</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.felzenszwalbSegmentation" title="Permalink to this definition">¶</a></dt>
<dd><p>felzenszwalbs segmentation method</p>
<p>Keyword Arguments :</p>
<blockquote>
<div><ul>
<li><p class="first">graph : input graph</p>
</li>
<li><p class="first">edgeWeights : edge weights / indicators</p>
</li>
<li><dl class="first docutils">
<dt>nodeSizes <span class="classifier-delimiter">:</span> <span class="classifier">size of each node (default: None)</span></dt>
<dd><p class="first last">If nodeSizes is None, &#8216;getNodeSizes&#8217; will be called</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>k <span class="classifier-delimiter">:</span> <span class="classifier">free parameter in felzenszwalbs algorithms (default</span> <span class="classifier-delimiter">:</span> <span class="classifier">1.0)</span></dt>
<dd><p class="first last">(todo: write better docu)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>nodeNumStop <span class="classifier-delimiter">:</span> <span class="classifier">stop the agglomeration at a given nodeNum (default :None)</span></dt>
<dd><p class="first last">If nodeNumStop is None, the resulting number of nodes does depends on k.</p>
</dd>
</dl>
</li>
<li><p class="first">backgroundBias : backgroundBias (default  : None)</p>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.find3Cycles">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">find3Cycles</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.find3Cycles" title="Permalink to this definition">¶</a></dt>
<dd><p>find3Cycles( (GridGraphUndirected2d)arg1) -&gt; object</p>
<p>find3Cycles( (GridGraphUndirected3d)arg1) -&gt; object</p>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.find3CyclesEdges">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">find3CyclesEdges</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.find3CyclesEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>find3CyclesEdges( (GridGraphUndirected2d)arg1) -&gt; object</p>
<p>find3CyclesEdges( (GridGraphUndirected3d)arg1) -&gt; object</p>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.getEdgeLengths">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">getEdgeLengths</tt><big>(</big><em>graph</em><big>)</big><a class="headerlink" href="#vigra.graphs.getEdgeLengths" title="Permalink to this definition">¶</a></dt>
<dd><p>get lengths/sizes of edges:</p>
<p>This functions will try to call &#8216;graph.edgeLength()&#8217; .
If this fails, an edge map filled with 1.0 will be
returned</p>
<p>Keyword Arguments:</p>
<blockquote>
<div><ul class="simple">
<li>graph : input graph</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.getNodeSizes">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">getNodeSizes</tt><big>(</big><em>graph</em><big>)</big><a class="headerlink" href="#vigra.graphs.getNodeSizes" title="Permalink to this definition">¶</a></dt>
<dd><p>get size of nodes:</p>
<p>This functions will try to call &#8216;graph.nodeSize()&#8217; .
If this fails, a node map filled with 1.0 will be
returned</p>
<p>Keyword Arguments:</p>
<blockquote>
<div><ul class="simple">
<li>graph : input graph</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.graphMap">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">graphMap</tt><big>(</big><em>graph</em>, <em>item</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>channels=1</em>, <em>addChannelDim=False</em><big>)</big><a class="headerlink" href="#vigra.graphs.graphMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a graph map for a given graph item (<tt class="docutils literal"><span class="pre">'node'</span></tt> , <tt class="docutils literal"><span class="pre">'edge'</span></tt> or <tt class="docutils literal"><span class="pre">'arc'</span></tt>).</p>
<p>Parameters:</p>
<blockquote>
<div><ul>
<li><p class="first">graph    : graph to get a graph map for</p>
</li>
<li><p class="first">item     : <tt class="docutils literal"><span class="pre">'node'</span></tt> , <tt class="docutils literal"><span class="pre">'edge'</span></tt> or <tt class="docutils literal"><span class="pre">'arc'</span></tt></p>
</li>
<li><p class="first">dtype    : desired dtype</p>
</li>
<li><p class="first">channels : number of channels (default: 1)</p>
</li>
<li><dl class="first docutils">
<dt>addChannelDim &#8211; add an explicit channelDim :(default: False)</dt>
<dd><p class="first last">only useful if channels == 1</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Returns:</p>
<blockquote>
<div><ul class="simple">
<li>graphmap as numpy.ndarray / VigraArray</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.gridGraph">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">gridGraph</tt><big>(</big><em>shape</em>, <em>directNeighborhood=True</em><big>)</big><a class="headerlink" href="#vigra.graphs.gridGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a grid graph with certain shape.</p>
<p>Parameters:</p>
<blockquote>
<div><ul class="simple">
<li>shape &#8211; shape of the image</li>
<li>directNeighborhood &#8211; use  4 (True) or 8 (False) neighborhood (default: True)</li>
</ul>
</div></blockquote>
<p>Returns:</p>
<blockquote>
<div><ul class="simple">
<li>grid graph</li>
</ul>
</div></blockquote>
<p>use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># 4-connected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">graps</span><span class="o">.</span><span class="n">gridGraph</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">nodeNum</span>
<span class="go">200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># 8-connected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">graps</span><span class="o">.</span><span class="n">gridGraph</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">],</span><span class="n">directNeighborhood</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.gridRegionAdjacencyGraph">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">gridRegionAdjacencyGraph</tt><big>(</big><em>labels</em>, <em>ignoreLabel=None</em>, <em>reserveEdges=0</em>, <em>maxLabel=None</em>, <em>isDense=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.gridRegionAdjacencyGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>get a region adjacency graph and a grid graph from a labeling.</p>
<p>This function will call &#8216;graphs.gridGraph&#8217; and &#8216;graphs.regionAdjacencyGraph&#8217;</p>
<dl class="docutils">
<dt>Keyword Arguments:</dt>
<dd><ul class="first last simple">
<li>labels : label image</li>
<li>ignoreLabel : label to ingnore (default: None)</li>
<li>reserveEdges : reserve a number of edges (default: 0)</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.implicitMeanEdgeMap">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">implicitMeanEdgeMap</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; ImplicitMEanEdgeMap_3d_float_float<a class="headerlink" href="#vigra.graphs.implicitMeanEdgeMap" title="Permalink to this definition">¶</a></dt>
<dd><p>implicitMeanEdgeMap( (GridGraphUndirected2d)arg1, (object)arg2) -&gt; ImplicitMEanEdgeMap_2d_float_float</p>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.intrinsicGraphMapShape">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">intrinsicGraphMapShape</tt><big>(</big><em>graph</em>, <em>item</em><big>)</big><a class="headerlink" href="#vigra.graphs.intrinsicGraphMapShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Intrinsic shape of node/edge/arc-map for a given graph.</p>
<p>Node edge and arc maps are stored in numpy arrays by default.
The instric shape may not be confused with the number
of nodes/edges/arcs. The instric shape is used to
allocate a numpy are which can store data for nodes/arcs/edgeSizes
of a given graph.</p>
<p>Parameters:</p>
<blockquote>
<div><ul class="simple">
<li>graph : input graph to get the shape for</li>
<li>item  : item must be <tt class="docutils literal"><span class="pre">'node'</span></tt> , <tt class="docutils literal"><span class="pre">'edge'</span></tt> or <tt class="docutils literal"><span class="pre">'arc'</span></tt></li>
</ul>
</div></blockquote>
<p>Returns:</p>
<blockquote>
<div><ul class="simple">
<li>shape as tuple</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.isGridGraph">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">isGridGraph</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#vigra.graphs.isGridGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>check if obj is gridGraph</p>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.isGridGraph2d">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">isGridGraph2d</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#vigra.graphs.isGridGraph2d" title="Permalink to this definition">¶</a></dt>
<dd><p>check if obj is gridGraph</p>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.listGraph">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">listGraph</tt><big>(</big><em>nodes=0</em>, <em>edges=0</em><big>)</big><a class="headerlink" href="#vigra.graphs.listGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an empty directed graph</p>
<p>Parameters :</p>
<blockquote>
<div><ul class="simple">
<li>nodes : number of nodes to reserveEdges</li>
<li>edges : number of edges to reserve</li>
</ul>
</div></blockquote>
<p>Returns :</p>
<blockquote>
<div><ul class="simple">
<li>graph</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.mergeGraph">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">mergeGraph</tt><big>(</big><em>graph</em><big>)</big><a class="headerlink" href="#vigra.graphs.mergeGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>get a merge graph from input graph.</p>
<p>A merge graph might be usefull for hierarchical clustering</p>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.nodeFeaturesToEdgeWeights">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">nodeFeaturesToEdgeWeights</tt><big>(</big><em>graph</em>, <em>nodeFeatures</em>, <em>metric='l1'</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.nodeFeaturesToEdgeWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>compute an edge indicator from node features .</p>
<dl class="docutils">
<dt>Keyword Arguments :</dt>
<dd><ul class="first last">
<li><p class="first">graph : input graph</p>
</li>
<li><p class="first">nodeFeatures : node map with feature vector for each node</p>
</li>
<li><dl class="first docutils">
<dt>metric <span class="classifier-delimiter">:</span> <span class="classifier">metric / distance used to convert 2 node features to</span></dt>
<dd><p class="first last">an edge weight</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns :</dt>
<dd>edge indicator</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.nodeGtToEdgeGt">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">nodeGtToEdgeGt</tt><big>(</big><em>(AdjacencyListGraph)graph</em>, <em>(object)nodeGt</em>, <em>(int)ignoreLabel</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.nodeGtToEdgeGt" title="Permalink to this definition">¶</a></dt>
<dd><p>nodeGtToEdgeGt( (GridGraphUndirected2d)graph, (object)nodeGt, (int)ignoreLabel [, (object)out=None]) -&gt; object</p>
<p>nodeGtToEdgeGt( (GridGraphUndirected3d)graph, (object)nodeGt, (int)ignoreLabel [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.nodeWeightedWatersheds">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">nodeWeightedWatersheds</tt><big>(</big><em>graph</em>, <em>nodeWeights</em>, <em>seeds=None</em>, <em>method='regionGrowing'</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.nodeWeightedWatersheds" title="Permalink to this definition">¶</a></dt>
<dd><p>node weighted seeded watersheds</p>
<p>Keyword Arguments :</p>
<blockquote>
<div><ul>
<li><p class="first">graph : input graph</p>
</li>
<li><p class="first">nodeWeights : node height map / evaluation weights</p>
</li>
<li><dl class="first docutils">
<dt>seeds <span class="classifier-delimiter">:</span> <span class="classifier">node map with seeds (default: None)</span></dt>
<dd><p class="first last">If seeds are None, &#8216;nodeWeightedWatershedsSeeds&#8217; will be called</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.nodeWeightedWatershedsSeeds">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">nodeWeightedWatershedsSeeds</tt><big>(</big><em>graph</em>, <em>nodeWeights</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.nodeWeightedWatershedsSeeds" title="Permalink to this definition">¶</a></dt>
<dd><p>generate watersheds seeds</p>
<p>Keyword Arguments :</p>
<blockquote>
<div><ul class="simple">
<li>graph : input graph</li>
<li>nodeWeights : node height map</li>
<li>out : seed map</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.recursiveGraphSmoothing">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">recursiveGraphSmoothing</tt><big>(</big><em>graph</em>, <em>nodeFeatures</em>, <em>edgeIndicator</em>, <em>gamma</em>, <em>edgeThreshold</em>, <em>scale=1.0</em>, <em>iterations=1</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.recursiveGraphSmoothing" title="Permalink to this definition">¶</a></dt>
<dd><p>recursive graph smoothing to smooth node features.
Each node feature is smoothed with the features of neighbor nodes.
The strength of the smoothing is computed from:</p>
<blockquote>
<div>&#8220;edgeIndicator &gt; edgeThreshold ? 0 : exp(-1.0*gamma*edgeIndicator)*scale&#8221;</div></blockquote>
<p>Therefore this filter is edge preserving.</p>
<p>Keyword Arguments :</p>
<blockquote>
<div><ul class="simple">
<li>graph : input graph</li>
<li>nodeFeatures : node features which should be smoothed</li>
<li>edgeIndicator  : edge indicator</li>
<li>gamma  : scale edgeIndicator by gamma bevore taking the negative exponent</li>
<li>scale  : how much should a node be mixed with its neighbours per iteration</li>
<li>iteration : how often should recursiveGraphSmoothing be called recursively</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Returns :</dt>
<dd>smoothed nodeFeatures</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.regionAdjacencyGraph">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">regionAdjacencyGraph</tt><big>(</big><em>graph</em>, <em>labels</em>, <em>ignoreLabel=None</em>, <em>reserveEdges=0</em>, <em>maxLabel=None</em>, <em>isDense=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.regionAdjacencyGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a region adjacency graph for a labeld graph.</p>
<p>Parameters:</p>
<blockquote>
<div><ul class="simple">
<li>graph  &#8211; input graph</li>
<li>lables &#8211; node-map with labels for each nodeSumWeights</li>
<li>ignoreLabel &#8211; label to ingnore (default: None)</li>
<li>reserveEdges &#8211; reverse a certain number of edges (default: 0)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>rag &#8211; instance of RegionAdjacencyGraph or GridRegionAdjacencyGraph</dt>
<dd><p class="first last">If graph is a GridGraph or a GridRegionAdjacencyGraph, a GridRegionAdjacencyGraph
will be returned.
Otherwise a RegionAdjacencyGraph will be returned</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.seededSegmentation">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">seededSegmentation</tt><big>(</big><em>graph</em>, <em>nodeMap=None</em>, <em>edgeMap=None</em>, <em>seeds=None</em>, <em>alg='ws'</em>, <em>out=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#vigra.graphs.seededSegmentation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>alg:</dt>
<dd><ul class="first last simple">
<li>&#8216;ws&#8217; watershed</li>
<li>&#8216;sp&#8217; shortest path</li>
<li>&#8216;crf&#8217; crf/mrf method</li>
<li>&#8216;hc&#8217; hierarchical-clustering method</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="vigra.graphs.shortestPathSegmentation">
<tt class="descclassname">vigra.graphs.</tt><tt class="descname">shortestPathSegmentation</tt><big>(</big><em>graph</em>, <em>edgeWeights</em>, <em>nodeWeights</em>, <em>seeds=None</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.shortestPathSegmentation" title="Permalink to this definition">¶</a></dt>
<dd><p>node weighted seeded watersheds</p>
<p>Keyword Arguments :</p>
<blockquote>
<div><ul>
<li><p class="first">graph : input graph</p>
</li>
<li><p class="first">edgeWeights : edge weight map</p>
</li>
<li><p class="first">nodeWeights : node weight map</p>
</li>
<li><dl class="first docutils">
<dt>seeds <span class="classifier-delimiter">:</span> <span class="classifier">node map with seeds (default: None)</span></dt>
<dd><p class="first last">If seeds are None, &#8216;nodeWeightedWatershedsSeeds&#8217; will be called</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="vigra.graphs.GridGraphUndirected2d">
<em class="property">class </em><tt class="descclassname">vigra.graphs.</tt><tt class="descname">GridGraphUndirected2d</tt><big>(</big><em>(object)arg1</em>, <em>(object)arg2</em><big>)</big><a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1, (object)arg2, (bool)arg3) -&gt; object</p>
<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.affiliatedEdgesSerializationSize">
<tt class="descname">affiliatedEdgesSerializationSize</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(AdjacencyListGraph)rag</em>, <em>(GridGraphUndirected2dRagAffiliatedEdges)affiliatedEdges</em><big>)</big> &rarr; int<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.affiliatedEdgesSerializationSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.arcFromId">
<tt class="descname">arcFromId</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; ArcGridGraphUndirected2d :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.arcFromId" title="Permalink to this definition">¶</a></dt>
<dd><p>get the arc descriptor from the given id</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.arcIds">
<tt class="descname">arcIds</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.arcIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected2d.arcNum">
<tt class="descname">arcNum</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.arcNum" title="Permalink to this definition">¶</a></dt>
<dd><p>number of arcs (2*edgeNum for undirected graphs)</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.axistagsArcMap">
<tt class="descname">axistagsArcMap</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><big>)</big> &rarr; AxisTags<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.axistagsArcMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.axistagsEdgeMap">
<tt class="descname">axistagsEdgeMap</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><big>)</big> &rarr; AxisInfo<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.axistagsEdgeMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.axistagsNodeMap">
<tt class="descname">axistagsNodeMap</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><big>)</big> &rarr; AxisInfo<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.axistagsNodeMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.coordinateToNode">
<tt class="descname">coordinateToNode</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; NodeGridGraphUndirected2d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.coordinateToNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.edgeFromArc">
<tt class="descname">edgeFromArc</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(ArcGridGraphUndirected2d)arg2</em><big>)</big> &rarr; EdgeGridGraphUndirected2d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.edgeFromArc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.edgeFromId">
<tt class="descname">edgeFromId</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; EdgeGridGraphUndirected2d :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.edgeFromId" title="Permalink to this definition">¶</a></dt>
<dd><p>get the edge descriptor from the given id</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.edgeIds">
<tt class="descname">edgeIds</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.edgeIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.edgeIter">
<tt class="descname">edgeIter</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><big>)</big> &rarr; EdgeIteratorHolderGridGraphUndirected2d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.edgeIter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.edgeLengths">
<tt class="descname">edgeLengths</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.edgeLengths" title="Permalink to this definition">¶</a></dt>
<dd><p>node map filled with 1.0</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected2d.edgeNum">
<tt class="descname">edgeNum</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.edgeNum" title="Permalink to this definition">¶</a></dt>
<dd><p>number of edges within the graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.findEdge">
<tt class="descname">findEdge</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(NodeGridGraphUndirected2d)arg2</em>, <em>(NodeGridGraphUndirected2d)arg3</em><big>)</big> &rarr; EdgeGridGraphUndirected2d :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.findEdge" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>find an edge between node u and v</div></blockquote>
<dl class="docutils">
<dt>findEdge( (GridGraphUndirected2d)arg1, (int)arg2, (int)arg3) -&gt; EdgeGridGraphUndirected2d :</dt>
<dd>find the edge between two nodes given their id</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.findEdges">
<tt class="descname">findEdges</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(object)nodeIdPairs</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.findEdges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.id">
<tt class="descname">id</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(NodeGridGraphUndirected2d)arg2</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.id" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the id of a given node</div></blockquote>
<dl class="docutils">
<dt>id( (GridGraphUndirected2d)arg1, (EdgeGridGraphUndirected2d)arg2) -&gt; int :</dt>
<dd>get the id of a given edge</dd>
<dt>id( (GridGraphUndirected2d)arg1, (ArcGridGraphUndirected2d)arg2) -&gt; int :</dt>
<dd>get the id of a given arc</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.incEdgeIter">
<tt class="descname">incEdgeIter</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(NodeGridGraphUndirected2d)arg2</em><big>)</big> &rarr; IncEdgeIteratorHolderGridGraphUndirected2d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.incEdgeIter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.intrinsicArcCoordinate">
<tt class="descname">intrinsicArcCoordinate</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.intrinsicArcCoordinate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.intrinsicArcMapShape">
<tt class="descname">intrinsicArcMapShape</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.intrinsicArcMapShape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.intrinsicEdgeCoordinate">
<tt class="descname">intrinsicEdgeCoordinate</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.intrinsicEdgeCoordinate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.intrinsicEdgeMapShape">
<tt class="descname">intrinsicEdgeMapShape</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.intrinsicEdgeMapShape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.intrinsicNodeCoordinate">
<tt class="descname">intrinsicNodeCoordinate</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.intrinsicNodeCoordinate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.intrinsicNodeMapShape">
<tt class="descname">intrinsicNodeMapShape</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.intrinsicNodeMapShape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected2d.maxArcId">
<tt class="descname">maxArcId</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.maxArcId" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum id of a valid arc in the graph</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected2d.maxEdgeId">
<tt class="descname">maxEdgeId</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.maxEdgeId" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum id of a valid node in the graph</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected2d.maxNodeId">
<tt class="descname">maxNodeId</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.maxNodeId" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum id of a valid edge in the graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.neighbourNodeIter">
<tt class="descname">neighbourNodeIter</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(NodeGridGraphUndirected2d)arg2</em><big>)</big> &rarr; NeighbourNodeIteratorHolderGridGraphUndirected2d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.neighbourNodeIter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.nodeFromId">
<tt class="descname">nodeFromId</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(int)id</em><big>)</big> &rarr; NodeGridGraphUndirected2d :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.nodeFromId" title="Permalink to this definition">¶</a></dt>
<dd><p>get the node descriptor from the given id</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.nodeIdMap">
<tt class="descname">nodeIdMap</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.nodeIdMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.nodeIds">
<tt class="descname">nodeIds</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.nodeIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.nodeIter">
<tt class="descname">nodeIter</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><big>)</big> &rarr; NodeIteratorHolderGridGraphUndirected2d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.nodeIter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected2d.nodeNum">
<tt class="descname">nodeNum</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.nodeNum" title="Permalink to this definition">¶</a></dt>
<dd><p>number of nodes within the graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.nodeSize">
<tt class="descname">nodeSize</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.nodeSize" title="Permalink to this definition">¶</a></dt>
<dd><p>node map filled with 1.0</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected2d.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>shape of grid graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.source">
<tt class="descname">source</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(ArcGridGraphUndirected2d)arg2</em><big>)</big> &rarr; NodeGridGraphUndirected2d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.source" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.target">
<tt class="descname">target</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(ArcGridGraphUndirected2d)arg2</em><big>)</big> &rarr; NodeGridGraphUndirected2d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.target" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.u">
<tt class="descname">u</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(EdgeGridGraphUndirected2d)arg2</em><big>)</big> &rarr; NodeGridGraphUndirected2d :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.u" title="Permalink to this definition">¶</a></dt>
<dd><p>get the u node of an edge</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.uId">
<tt class="descname">uId</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(EdgeGridGraphUndirected2d)arg2</em><big>)</big> &rarr; int<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.uId" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.uIds">
<tt class="descname">uIds</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.uIds" title="Permalink to this definition">¶</a></dt>
<dd><p>uIds( (GridGraphUndirected2d)arg1, (object)edgeIds [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.uvId">
<tt class="descname">uvId</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(EdgeGridGraphUndirected2d)arg2</em><big>)</big> &rarr; tuple<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.uvId" title="Permalink to this definition">¶</a></dt>
<dd><p>uvId( (GridGraphUndirected2d)arg1, (int)arg2) -&gt; tuple</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.uvIds">
<tt class="descname">uvIds</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.uvIds" title="Permalink to this definition">¶</a></dt>
<dd><p>uvIds( (GridGraphUndirected2d)arg1, (object)edgeIds [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.v">
<tt class="descname">v</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(EdgeGridGraphUndirected2d)arg2</em><big>)</big> &rarr; NodeGridGraphUndirected2d :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.v" title="Permalink to this definition">¶</a></dt>
<dd><p>geht the v node of an edge</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.vId">
<tt class="descname">vId</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em>, <em>(EdgeGridGraphUndirected2d)arg2</em><big>)</big> &rarr; int<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.vId" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.vIds">
<tt class="descname">vIds</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.vIds" title="Permalink to this definition">¶</a></dt>
<dd><p>vIds( (GridGraphUndirected2d)arg1, (object)edgeIds [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.validArcIds">
<tt class="descname">validArcIds</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.validArcIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.validEdgeIds">
<tt class="descname">validEdgeIds</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.validEdgeIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected2d.validNodeIds">
<tt class="descname">validNodeIds</tt><big>(</big><em>(GridGraphUndirected2d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected2d.validNodeIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="vigra.graphs.GridGraphUndirected3d">
<em class="property">class </em><tt class="descclassname">vigra.graphs.</tt><tt class="descname">GridGraphUndirected3d</tt><big>(</big><em>(object)arg1</em>, <em>(object)arg2</em><big>)</big><a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1, (object)arg2, (bool)arg3) -&gt; object</p>
<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.affiliatedEdgesSerializationSize">
<tt class="descname">affiliatedEdgesSerializationSize</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(AdjacencyListGraph)rag</em>, <em>(GridGraphUndirected3dRagAffiliatedEdges)affiliatedEdges</em><big>)</big> &rarr; int<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.affiliatedEdgesSerializationSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.arcFromId">
<tt class="descname">arcFromId</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; ArcGridGraphUndirected3d :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.arcFromId" title="Permalink to this definition">¶</a></dt>
<dd><p>get the arc descriptor from the given id</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.arcIds">
<tt class="descname">arcIds</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.arcIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected3d.arcNum">
<tt class="descname">arcNum</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.arcNum" title="Permalink to this definition">¶</a></dt>
<dd><p>number of arcs (2*edgeNum for undirected graphs)</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.axistagsArcMap">
<tt class="descname">axistagsArcMap</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><big>)</big> &rarr; AxisTags<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.axistagsArcMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.axistagsEdgeMap">
<tt class="descname">axistagsEdgeMap</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><big>)</big> &rarr; AxisInfo<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.axistagsEdgeMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.axistagsNodeMap">
<tt class="descname">axistagsNodeMap</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><big>)</big> &rarr; AxisInfo<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.axistagsNodeMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.coordinateToNode">
<tt class="descname">coordinateToNode</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; NodeGridGraphUndirected3d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.coordinateToNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.edgeFromArc">
<tt class="descname">edgeFromArc</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(ArcGridGraphUndirected3d)arg2</em><big>)</big> &rarr; EdgeGridGraphUndirected3d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.edgeFromArc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.edgeFromId">
<tt class="descname">edgeFromId</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; EdgeGridGraphUndirected3d :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.edgeFromId" title="Permalink to this definition">¶</a></dt>
<dd><p>get the edge descriptor from the given id</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.edgeIds">
<tt class="descname">edgeIds</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.edgeIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.edgeIter">
<tt class="descname">edgeIter</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><big>)</big> &rarr; EdgeIteratorHolderGridGraphUndirected3d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.edgeIter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.edgeLengths">
<tt class="descname">edgeLengths</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.edgeLengths" title="Permalink to this definition">¶</a></dt>
<dd><p>node map filled with 1.0</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected3d.edgeNum">
<tt class="descname">edgeNum</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.edgeNum" title="Permalink to this definition">¶</a></dt>
<dd><p>number of edges within the graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.findEdge">
<tt class="descname">findEdge</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(NodeGridGraphUndirected3d)arg2</em>, <em>(NodeGridGraphUndirected3d)arg3</em><big>)</big> &rarr; EdgeGridGraphUndirected3d :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.findEdge" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>find an edge between node u and v</div></blockquote>
<dl class="docutils">
<dt>findEdge( (GridGraphUndirected3d)arg1, (int)arg2, (int)arg3) -&gt; EdgeGridGraphUndirected3d :</dt>
<dd>find the edge between two nodes given their id</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.findEdges">
<tt class="descname">findEdges</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(object)nodeIdPairs</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.findEdges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.id">
<tt class="descname">id</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(NodeGridGraphUndirected3d)arg2</em><big>)</big> &rarr; int :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.id" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the id of a given node</div></blockquote>
<dl class="docutils">
<dt>id( (GridGraphUndirected3d)arg1, (EdgeGridGraphUndirected3d)arg2) -&gt; int :</dt>
<dd>get the id of a given edge</dd>
<dt>id( (GridGraphUndirected3d)arg1, (ArcGridGraphUndirected3d)arg2) -&gt; int :</dt>
<dd>get the id of a given arc</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.incEdgeIter">
<tt class="descname">incEdgeIter</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(NodeGridGraphUndirected3d)arg2</em><big>)</big> &rarr; IncEdgeIteratorHolderGridGraphUndirected3d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.incEdgeIter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.intrinsicArcCoordinate">
<tt class="descname">intrinsicArcCoordinate</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.intrinsicArcCoordinate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.intrinsicArcMapShape">
<tt class="descname">intrinsicArcMapShape</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.intrinsicArcMapShape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.intrinsicEdgeCoordinate">
<tt class="descname">intrinsicEdgeCoordinate</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.intrinsicEdgeCoordinate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.intrinsicEdgeMapShape">
<tt class="descname">intrinsicEdgeMapShape</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.intrinsicEdgeMapShape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.intrinsicNodeCoordinate">
<tt class="descname">intrinsicNodeCoordinate</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.intrinsicNodeCoordinate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.intrinsicNodeMapShape">
<tt class="descname">intrinsicNodeMapShape</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.intrinsicNodeMapShape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected3d.maxArcId">
<tt class="descname">maxArcId</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.maxArcId" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum id of a valid arc in the graph</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected3d.maxEdgeId">
<tt class="descname">maxEdgeId</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.maxEdgeId" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum id of a valid node in the graph</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected3d.maxNodeId">
<tt class="descname">maxNodeId</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.maxNodeId" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum id of a valid edge in the graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.neighbourNodeIter">
<tt class="descname">neighbourNodeIter</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(NodeGridGraphUndirected3d)arg2</em><big>)</big> &rarr; NeighbourNodeIteratorHolderGridGraphUndirected3d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.neighbourNodeIter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.nodeFromId">
<tt class="descname">nodeFromId</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(int)id</em><big>)</big> &rarr; NodeGridGraphUndirected3d :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.nodeFromId" title="Permalink to this definition">¶</a></dt>
<dd><p>get the node descriptor from the given id</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.nodeIdMap">
<tt class="descname">nodeIdMap</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.nodeIdMap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.nodeIds">
<tt class="descname">nodeIds</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.nodeIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.nodeIter">
<tt class="descname">nodeIter</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><big>)</big> &rarr; NodeIteratorHolderGridGraphUndirected3d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.nodeIter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected3d.nodeNum">
<tt class="descname">nodeNum</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.nodeNum" title="Permalink to this definition">¶</a></dt>
<dd><p>number of nodes within the graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.nodeSize">
<tt class="descname">nodeSize</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.nodeSize" title="Permalink to this definition">¶</a></dt>
<dd><p>node map filled with 1.0</p>
</dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridGraphUndirected3d.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>shape of grid graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.source">
<tt class="descname">source</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(ArcGridGraphUndirected3d)arg2</em><big>)</big> &rarr; NodeGridGraphUndirected3d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.source" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.target">
<tt class="descname">target</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(ArcGridGraphUndirected3d)arg2</em><big>)</big> &rarr; NodeGridGraphUndirected3d<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.target" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.u">
<tt class="descname">u</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(EdgeGridGraphUndirected3d)arg2</em><big>)</big> &rarr; NodeGridGraphUndirected3d :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.u" title="Permalink to this definition">¶</a></dt>
<dd><p>get the u node of an edge</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.uId">
<tt class="descname">uId</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(EdgeGridGraphUndirected3d)arg2</em><big>)</big> &rarr; int<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.uId" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.uIds">
<tt class="descname">uIds</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.uIds" title="Permalink to this definition">¶</a></dt>
<dd><p>uIds( (GridGraphUndirected3d)arg1, (object)edgeIds [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.uvId">
<tt class="descname">uvId</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(EdgeGridGraphUndirected3d)arg2</em><big>)</big> &rarr; tuple<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.uvId" title="Permalink to this definition">¶</a></dt>
<dd><p>uvId( (GridGraphUndirected3d)arg1, (int)arg2) -&gt; tuple</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.uvIds">
<tt class="descname">uvIds</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.uvIds" title="Permalink to this definition">¶</a></dt>
<dd><p>uvIds( (GridGraphUndirected3d)arg1, (object)edgeIds [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.v">
<tt class="descname">v</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(EdgeGridGraphUndirected3d)arg2</em><big>)</big> &rarr; NodeGridGraphUndirected3d :<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.v" title="Permalink to this definition">¶</a></dt>
<dd><p>geht the v node of an edge</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.vId">
<tt class="descname">vId</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em>, <em>(EdgeGridGraphUndirected3d)arg2</em><big>)</big> &rarr; int<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.vId" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.vIds">
<tt class="descname">vIds</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.vIds" title="Permalink to this definition">¶</a></dt>
<dd><p>vIds( (GridGraphUndirected3d)arg1, (object)edgeIds [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.validArcIds">
<tt class="descname">validArcIds</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.validArcIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.validEdgeIds">
<tt class="descname">validEdgeIds</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.validEdgeIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridGraphUndirected3d.validNodeIds">
<tt class="descname">validNodeIds</tt><big>(</big><em>(GridGraphUndirected3d)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object<a class="headerlink" href="#vigra.graphs.GridGraphUndirected3d.validNodeIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">vigra.graphs.</tt><tt class="descname">AdjacencyListGraph</tt><big>(</big><em>(object)arg1</em>, <em>(int)arg2</em>, <em>(int)arg3</em><big>)</big></dt>
<dd><p>undirected adjacency list graph</p>
<dl class="method">
<dt>
<tt class="descname">addEdge</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(NodeAdjacencyListGraph)arg2</em>, <em>(NodeAdjacencyListGraph)arg3</em><big>)</big> &rarr; EdgeAdjacencyListGraph</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">addEdges</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(object)edges</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">addNode</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; NodeAdjacencyListGraph</dt>
<dd><p>addNode( (AdjacencyListGraph)arg1, (int)arg2) -&gt; NodeAdjacencyListGraph</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">arcFromId</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; ArcAdjacencyListGraph :</dt>
<dd><p>get the arc descriptor from the given id</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">arcIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">arcNum</tt></dt>
<dd><p>number of arcs (2*edgeNum for undirected graphs)</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">axistagsArcMap</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; AxisTags</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">axistagsEdgeMap</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; AxisInfo</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">axistagsNodeMap</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; AxisInfo</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">deserialize</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; None</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">edgeFromArc</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(ArcAdjacencyListGraph)arg2</em><big>)</big> &rarr; EdgeAdjacencyListGraph</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">edgeFromId</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(int)arg2</em><big>)</big> &rarr; EdgeAdjacencyListGraph :</dt>
<dd><p>get the edge descriptor from the given id</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">edgeIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">edgeIter</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; EdgeIteratorHolderAdjacencyListGraph</dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">edgeNum</tt></dt>
<dd><p>number of edges within the graph</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">findEdge</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(NodeAdjacencyListGraph)arg2</em>, <em>(NodeAdjacencyListGraph)arg3</em><big>)</big> &rarr; EdgeAdjacencyListGraph :</dt>
<dd><blockquote>
<div>find an edge between node u and v</div></blockquote>
<dl class="docutils">
<dt>findEdge( (AdjacencyListGraph)arg1, (int)arg2, (int)arg3) -&gt; EdgeAdjacencyListGraph :</dt>
<dd>find the edge between two nodes given their id</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">findEdges</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(object)nodeIdPairs</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">id</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(NodeAdjacencyListGraph)arg2</em><big>)</big> &rarr; int :</dt>
<dd><blockquote>
<div>get the id of a given node</div></blockquote>
<dl class="docutils">
<dt>id( (AdjacencyListGraph)arg1, (EdgeAdjacencyListGraph)arg2) -&gt; int :</dt>
<dd>get the id of a given edge</dd>
<dt>id( (AdjacencyListGraph)arg1, (ArcAdjacencyListGraph)arg2) -&gt; int :</dt>
<dd>get the id of a given arc</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">incEdgeIter</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(NodeAdjacencyListGraph)arg2</em><big>)</big> &rarr; IncEdgeIteratorHolderAdjacencyListGraph</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">intrinsicArcCoordinate</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">intrinsicArcMapShape</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">intrinsicEdgeCoordinate</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">intrinsicEdgeMapShape</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">intrinsicNodeCoordinate</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">intrinsicNodeMapShape</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">maxArcId</tt></dt>
<dd><p>maximum id of a valid arc in the graph</p>
</dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">maxEdgeId</tt></dt>
<dd><p>maximum id of a valid node in the graph</p>
</dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">maxNodeId</tt></dt>
<dd><p>maximum id of a valid edge in the graph</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">neighbourNodeIter</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(NodeAdjacencyListGraph)arg2</em><big>)</big> &rarr; NeighbourNodeIteratorHolderAdjacencyListGraph</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">nodeFromId</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(int)id</em><big>)</big> &rarr; NodeAdjacencyListGraph :</dt>
<dd><p>get the node descriptor from the given id</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">nodeIdMap</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">nodeIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">nodeIter</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; NodeIteratorHolderAdjacencyListGraph</dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<tt class="descname">nodeNum</tt></dt>
<dd><p>number of nodes within the graph</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">serializationSize</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><big>)</big> &rarr; int :</dt>
<dd><p>number of integers needed to serialize graph</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">serialize</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)serialization=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">source</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(ArcAdjacencyListGraph)arg2</em><big>)</big> &rarr; NodeAdjacencyListGraph</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">target</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(ArcAdjacencyListGraph)arg2</em><big>)</big> &rarr; NodeAdjacencyListGraph</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">u</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(EdgeAdjacencyListGraph)arg2</em><big>)</big> &rarr; NodeAdjacencyListGraph :</dt>
<dd><p>get the u node of an edge</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">uId</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(EdgeAdjacencyListGraph)arg2</em><big>)</big> &rarr; int</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">uIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd><p>uIds( (AdjacencyListGraph)arg1, (object)edgeIds [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">uvId</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(EdgeAdjacencyListGraph)arg2</em><big>)</big> &rarr; tuple</dt>
<dd><p>uvId( (AdjacencyListGraph)arg1, (int)arg2) -&gt; tuple</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">uvIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd><p>uvIds( (AdjacencyListGraph)arg1, (object)edgeIds [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">v</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(EdgeAdjacencyListGraph)arg2</em><big>)</big> &rarr; NodeAdjacencyListGraph :</dt>
<dd><p>geht the v node of an edge</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">vId</tt><big>(</big><em>(AdjacencyListGraph)arg1</em>, <em>(EdgeAdjacencyListGraph)arg2</em><big>)</big> &rarr; int</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">vIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd><p>vIds( (AdjacencyListGraph)arg1, (object)edgeIds [, (object)out=None]) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">validArcIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">validEdgeIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descname">validNodeIds</tt><big>(</big><em>(AdjacencyListGraph)arg1</em><span class="optional">[</span>, <em>(object)out=None</em><span class="optional">]</span><big>)</big> &rarr; object</dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="vigra.graphs.RegionAdjacencyGraph">
<em class="property">class </em><tt class="descclassname">vigra.graphs.</tt><tt class="descname">RegionAdjacencyGraph</tt><big>(</big><em>graph=None</em>, <em>labels=None</em>, <em>ignoreLabel=None</em>, <em>reserveEdges=0</em>, <em>maxLabel=None</em>, <em>isDense=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.RegionAdjacencyGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Region adjacency graph</p>
<dl class="docutils">
<dt>Keyword Arguments :</dt>
<dd><ul class="first last simple">
<li>graph : the base graph, the region adjacency graph should be based on</li>
<li>labels : label map for the graph</li>
<li>ignoreLabel : ignore a label in the labels map (default: None)</li>
<li>reserveEdges : reserve a certain number of Edges</li>
</ul>
</dd>
</dl>
<p>Attributes:</p>
<blockquote>
<div><ul>
<li><p class="first">labels : labels passed in constructor</p>
</li>
<li><p class="first">ignoreLabel  : ignoreLabel passed in constructor</p>
</li>
<li><dl class="first docutils">
<dt>baseGraphLabels <span class="classifier-delimiter">:</span> <span class="classifier">labels passed in constructor</span></dt>
<dd><p class="first last">(fixme,dublicated attribute (see labels) )</p>
</dd>
</dl>
</li>
<li><p class="first">baseGraph : baseGraph is the graph passed in constructor</p>
</li>
<li><dl class="first docutils">
<dt>affiliatedEdges <span class="classifier-delimiter">:</span> <span class="classifier">for each edge in the region adjacency graph,</span></dt>
<dd><p class="first last">a vector of edges of the baseGraph is stored in affiliatedEdges</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="vigra.graphs.RegionAdjacencyGraph.accumulateEdgeFeatures">
<tt class="descname">accumulateEdgeFeatures</tt><big>(</big><em>edgeFeatures</em>, <em>acc='mean'</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.RegionAdjacencyGraph.accumulateEdgeFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>accumulate edge features from base graphs edges features</p>
<p>Keyword Argument:</p>
<blockquote>
<div><ul>
<li><p class="first">edgeFeatures : edge features of baseGraph</p>
</li>
<li><dl class="first docutils">
<dt>acc <span class="classifier-delimiter">:</span> <span class="classifier">used accumulator (default: &#8216;mean&#8217;)</span></dt>
<dd><p class="first last">Currently only &#8216;mean&#8217; and &#8216;sum&#8217; are implemented</p>
</dd>
</dl>
</li>
<li><p class="first">out :  preallocated edge map</p>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Returns :</dt>
<dd>accumulated edge features</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.RegionAdjacencyGraph.accumulateNodeFeatures">
<tt class="descname">accumulateNodeFeatures</tt><big>(</big><em>nodeFeatures</em>, <em>acc='mean'</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.RegionAdjacencyGraph.accumulateNodeFeatures" title="Permalink to this definition">¶</a></dt>
<dd><p>accumulate edge features from base graphs edges features</p>
<p>Keyword Argument:</p>
<blockquote>
<div><ul>
<li><p class="first">nodeFeatures : node features of baseGraph</p>
</li>
<li><dl class="first docutils">
<dt>acc <span class="classifier-delimiter">:</span> <span class="classifier">used accumulator (default: &#8216;mean&#8217;)</span></dt>
<dd><p class="first last">Currently only &#8216;mean&#8217; and &#8216;sum&#8217; are implemented</p>
</dd>
</dl>
</li>
<li><p class="first">out :  preallocated node map (default: None)</p>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Returns :</dt>
<dd>accumulated node features</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.RegionAdjacencyGraph.projectLabelsBack">
<tt class="descname">projectLabelsBack</tt><big>(</big><em>steps</em>, <em>labels=None</em>, <em>_current=0</em><big>)</big><a class="headerlink" href="#vigra.graphs.RegionAdjacencyGraph.projectLabelsBack" title="Permalink to this definition">¶</a></dt>
<dd><p>project labels from current graph to baseGraph and repeat this recursively</p>
<p>Keyword  Arguments:</p>
<blockquote>
<div><ul>
<li><p class="first">steps : how often should the labels be projected back</p>
</li>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">labels for the current graph (default: None)</span></dt>
<dd><p class="first last">If labels is None, each node gets its own label</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.RegionAdjacencyGraph.projectLabelsToBaseGraph">
<tt class="descname">projectLabelsToBaseGraph</tt><big>(</big><em>labels=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.RegionAdjacencyGraph.projectLabelsToBaseGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>project node labels from this graph, to the base graph of this graph.</p>
<p>Keyword Arguments:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">node labels for this graph (default: None)</span></dt>
<dd><p class="first last">If labels is None, each node gets its own label</p>
</dd>
</dl>
</li>
<li><p class="first">out :  preallocated node map of baseGraph (default: None)</p>
</li>
</ul>
</div></blockquote>
<p>Returns :</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.RegionAdjacencyGraph.projectNodeFeatureToBaseGraph">
<tt class="descname">projectNodeFeatureToBaseGraph</tt><big>(</big><em>features</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.RegionAdjacencyGraph.projectNodeFeatureToBaseGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>project node features from this graph, to the base graph of this graph.</p>
<p>Keyword Arguments:</p>
<blockquote>
<div><ul class="simple">
<li>features : node feautres for this graph</li>
<li>out :  preallocated node map of baseGraph (default: None)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Returns :</dt>
<dd>projected node features of base graph</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vigra.graphs.GridRegionAdjacencyGraph">
<em class="property">class </em><tt class="descclassname">vigra.graphs.</tt><tt class="descname">GridRegionAdjacencyGraph</tt><big>(</big><em>graph=None</em>, <em>labels=None</em>, <em>ignoreLabel=None</em>, <em>reserveEdges=0</em>, <em>maxLabel=None</em>, <em>isDense=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.GridRegionAdjacencyGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Grid Region adjacency graph</p>
<p>A region adjaceny graph,where the base graph should be
a grid graph or a GridRegionAdjacencyGraph.</p>
<dl class="docutils">
<dt>Keyword Arguments :</dt>
<dd><ul class="first last simple">
<li>graph : the base graph, the region adjacency graph should be based on</li>
<li>labels : label map for the graph</li>
<li>ignoreLabel : ignore a label in the labels map (default: None)</li>
<li>reserveEdges : reserve a certain number of Edges</li>
</ul>
</dd>
</dl>
<p>Attributes :</p>
<blockquote>
<div><ul>
<li><p class="first">labels : labels passed in constructor</p>
</li>
<li><p class="first">ignoreLabel  : ignoreLabel passed in constructor</p>
</li>
<li><dl class="first docutils">
<dt>baseGraphLabels <span class="classifier-delimiter">:</span> <span class="classifier">labels passed in constructor</span></dt>
<dd><p class="first last">(fixme,dublicated attribute (see labels) )</p>
</dd>
</dl>
</li>
<li><p class="first">baseGraph : baseGraph is the graph passed in constructor</p>
</li>
<li><dl class="first docutils">
<dt>affiliatedEdges <span class="classifier-delimiter">:</span> <span class="classifier">for each edge in the region adjacency graph,</span></dt>
<dd><p class="first last">a vector of edges of the baseGraph is stored in affiliatedEdges</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>shape <span class="classifier-delimiter">:</span> <span class="classifier">shape of the grid graph which is a base graph in the</span></dt>
<dd><p class="first last">complete graph chain.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="vigra.graphs.GridRegionAdjacencyGraph.edgeLengths">
<tt class="descname">edgeLengths</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.graphs.GridRegionAdjacencyGraph.edgeLengths" title="Permalink to this definition">¶</a></dt>
<dd><p>get the geometric length of the edges</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridRegionAdjacencyGraph.nodeSize">
<tt class="descname">nodeSize</tt><big>(</big><big>)</big><a class="headerlink" href="#vigra.graphs.GridRegionAdjacencyGraph.nodeSize" title="Permalink to this definition">¶</a></dt>
<dd><p>get the geometric size of the nodes</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridRegionAdjacencyGraph.projectLabelsToGridGraph">
<tt class="descname">projectLabelsToGridGraph</tt><big>(</big><em>labels=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.GridRegionAdjacencyGraph.projectLabelsToGridGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>project labels of this graph to the underlying grid graph.</p>
<p>Keyword Arguments :</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">node labeling of this graph (default: None)</span></dt>
<dd><p class="first last">If labels is None, each node gets its own label</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Returns :</dt>
<dd>grid graph labeling</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridRegionAdjacencyGraph.projectNodeFeaturesToGridGraph">
<tt class="descname">projectNodeFeaturesToGridGraph</tt><big>(</big><em>features</em><big>)</big><a class="headerlink" href="#vigra.graphs.GridRegionAdjacencyGraph.projectNodeFeaturesToGridGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>project features of this graph to the underlying grid graph.
Therefore project the features to an image.</p>
<p>Keyword Arguments :</p>
<blockquote>
<div><ul class="simple">
<li>features : nodeFeatures of the current graph</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Returns :</dt>
<dd>grid graph labeling</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="vigra.graphs.GridRegionAdjacencyGraph.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#vigra.graphs.GridRegionAdjacencyGraph.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>shape of the underlying grid graph</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridRegionAdjacencyGraph.show">
<tt class="descname">show</tt><big>(</big><em>img</em>, <em>labels=None</em>, <em>edgeColor=(0</em>, <em>0</em>, <em>0)</em>, <em>alpha=0.3</em>, <em>returnImg=False</em><big>)</big><a class="headerlink" href="#vigra.graphs.GridRegionAdjacencyGraph.show" title="Permalink to this definition">¶</a></dt>
<dd><p>show the graph given an RGB image</p>
<dl class="docutils">
<dt>Keyword Arguments:</dt>
<dd><ul class="first last">
<li><p class="first">img : RGB image</p>
</li>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">node labeling of this graph (default: None)</span></dt>
<dd><p class="first last">If labels is None, each node gets its own label</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>edgeColor <span class="classifier-delimiter">:</span> <span class="classifier">RGB tuple of edge color (default: (0,0,0) ).</span></dt>
<dd><p class="first last">Do not use values bigger than 1 in edgeColor.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">make edges semi transparent (default: 0.3).</span></dt>
<dd><p class="first last">0 means no transparency,1 means full transparency.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.GridRegionAdjacencyGraph.showNested">
<tt class="descname">showNested</tt><big>(</big><em>img</em>, <em>labels=None</em>, <em>returnImg=False</em><big>)</big><a class="headerlink" href="#vigra.graphs.GridRegionAdjacencyGraph.showNested" title="Permalink to this definition">¶</a></dt>
<dd><p>show the complet graph chain  / hierarchy given an RGB image</p>
<dl class="docutils">
<dt>Keyword Arguments:</dt>
<dd><ul class="first last">
<li><p class="first">img : RGB image</p>
</li>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">node labeling of this graph (default: None)</span></dt>
<dd><p class="first last">If labels is None, each node gets its own label</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="vigra.graphs.ShortestPathPathDijkstra">
<em class="property">class </em><tt class="descclassname">vigra.graphs.</tt><tt class="descname">ShortestPathPathDijkstra</tt><big>(</big><em>graph</em><big>)</big><a class="headerlink" href="#vigra.graphs.ShortestPathPathDijkstra" title="Permalink to this definition">¶</a></dt>
<dd><p>shortest path computer</p>
<p>Keyword Arguments:</p>
<blockquote>
<div><ul class="simple">
<li>graph : input graph</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="vigra.graphs.ShortestPathPathDijkstra.distance">
<tt class="descname">distance</tt><big>(</big><em>target=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.ShortestPathPathDijkstra.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>get distance from source to target</p>
<dl class="docutils">
<dt>Keyword Arguments:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">target node (default: None)</span></dt>
<dd><p class="first last">If target node is None, the target specified
by &#8216;run&#8217; is used.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.ShortestPathPathDijkstra.distances">
<tt class="descname">distances</tt><big>(</big><em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.ShortestPathPathDijkstra.distances" title="Permalink to this definition">¶</a></dt>
<dd><p>return the full distance map</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.ShortestPathPathDijkstra.path">
<tt class="descname">path</tt><big>(</big><em>target=None</em>, <em>pathType='coordinates'</em><big>)</big><a class="headerlink" href="#vigra.graphs.ShortestPathPathDijkstra.path" title="Permalink to this definition">¶</a></dt>
<dd><p>get the shortest path from source to target</p>
<p>Keyword Arguments:</p>
<blockquote>
<div><ul>
<li><p class="first">weights : edge weights encoding distance from two adjacent nodes</p>
</li>
<li><p class="first">source : source node</p>
</li>
<li><dl class="first docutils">
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">target node (default: None)</span></dt>
<dd><p class="first last">If target node is None, the target specified
by &#8216;run&#8217; is used.</p>
</dd>
</dl>
</li>
</ul>
<p>pathType : &#8216;coordinates&#8217; or &#8216;ids&#8217; path (default: &#8216;coordinates&#8217;)</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.ShortestPathPathDijkstra.predecessors">
<tt class="descname">predecessors</tt><big>(</big><em>out=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.ShortestPathPathDijkstra.predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>return the full predecessors map</p>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.ShortestPathPathDijkstra.run">
<tt class="descname">run</tt><big>(</big><em>weights</em>, <em>source</em>, <em>target=None</em><big>)</big><a class="headerlink" href="#vigra.graphs.ShortestPathPathDijkstra.run" title="Permalink to this definition">¶</a></dt>
<dd><p>run shortest path search</p>
<p>Keyword Arguments:</p>
<blockquote>
<div><ul>
<li><p class="first">weights : edge weights encoding distance from two adjacent nodes</p>
</li>
<li><p class="first">source : source node</p>
</li>
<li><dl class="first docutils">
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">target node (default: None)</span></dt>
<dd><p class="first last">If target node is None, the shortest path
to all nodes!=source is computed</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="vigra.graphs.ShortestPathPathDijkstra.runIgnoreLargeWeights">
<tt class="descname">runIgnoreLargeWeights</tt><big>(</big><em>weights</em>, <em>source</em>, <em>val</em><big>)</big><a class="headerlink" href="#vigra.graphs.ShortestPathPathDijkstra.runIgnoreLargeWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>run shortest path search, nodes with all edge weights larger than val will be ignored</p>
<p>Keyword Arguments:</p>
<blockquote>
<div><ul class="simple">
<li>weights : edge weights encoding distance from two adjacent nodes</li>
<li>source : source node</li>
<li>val : upper bound</li>
</ul>
</div></blockquote>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="utilities">
<h2><a class="toc-backref" href="#id100">Utilities</a><a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h2>
<p>The module vigra.utilities provides  utilities and tools
like priority queues with changeable priorities</p>
<span class="target" id="module-vigra.utilities"></span></div>
<div class="section" id="writing-your-own-c-modules">
<span id="sec-own-modules"></span><h2><a class="toc-backref" href="#id101">Writing Your Own C++ Modules</a><a class="headerlink" href="#writing-your-own-c-modules" title="Permalink to this headline">¶</a></h2>
<p>When you want to write your own vigranumpy extension modules, first make sure that you compile and link with the same versions of numpy and boost_python that your current vigranumpy installation uses. Otherwise, communication between new and existing modules will not work (and even crash). Then follow these steps:</p>
<ol class="arabic">
<li><p class="first">Create the main module source file. This file contains the module&#8217;s &#8216;init&#8217; function. Let&#8217;s assume that the module will be called &#8216;my_module&#8217;, and the file is &#8216;my_module.cxx&#8217;. A stub for &#8216;my_module.cxx&#8217; typically looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre>// define PY_ARRAY_UNIQUE_SYMBOL (required by the numpy C-API)
#define PY_ARRAY_UNIQUE_SYMBOL my_module_PyArray_API

// include the vigranumpy C++ API
#include &lt;Python.h&gt;
#include &lt;boost/python.hpp&gt;
#include &lt;vigra/numpy_array.hxx&gt;
#include &lt;vigra/numpy_array_converters.hxx&gt;

... // your includes

... // implementation of your wrapper functions and classes

using namespace boost::python;

// the argument of the init macro must be the module name
BOOST_PYTHON_MODULE_INIT(my_module)
{
    // initialize numpy and vigranumpy
    vigra::import_vigranumpy();

    // export a function
    def(&quot;my_function&quot;, &amp;my_function,
        (arg(&quot;arg1&quot;), arg(&quot;arg2&quot;), ...),
        &quot;Documentation&quot;);

    // export a class and its member functions
    class_&lt;MyClass&gt;(&quot;MyClass&quot;,
        &quot;Documentation&quot;)
        .def(&quot;foo&quot;, &amp;MyClass::foo,
             (arg(&quot;arg1&quot;), arg(&quot;arg2&quot;), ...),
             &quot;Documentation&quot;)
    ;

    ... // more module functionality (refer to boost_python documentation)
}
</pre></div>
</div>
</li>
<li><p class="first">When your module uses additional C++ source files, they should start with the following defines:</p>
<div class="highlight-python"><div class="highlight"><pre>// this must define the same symbol as the main module file (numpy requirement)
#define PY_ARRAY_UNIQUE_SYMBOL my_module_PyArray_API
#define NO_IMPORT_ARRAY
</pre></div>
</div>
</li>
<li><p class="first">Implement your wrapper functions. Numpy ndarrays are passed to C++ via the wrapper classes <a class="reference external" href="../../doc/vigra/classvigra_1_1NumpyArray.html">NumpyArray</a> and <a class="reference external" href="../../doc/vigra/classvigra_1_1NumpyAnyArray.html">NumpyAnyArray</a>. You can influence the conversion from Python to C++ by using different instantiations of NumpyArray, as long as the Python array supports the axistags attribute (refer to <a class="reference internal" href="#array-order-parameter"><em>axis order definitions</em></a> for the meaning of the term &#8216;ascending order&#8217;):</p>
<div class="highlight-python"><div class="highlight"><pre>    // We add a &#39;using&#39; declaration for brevity of our examples.
    // In actual code, you should probably prefer explicit namespace qualification.
using namespace vigra;

    // Accept any array type and return an arbitrary array type.
    // Returning NumpyAnyArray is always safe, because at that point
    // C++ no longer cares about the particular type of the array.
NumpyAnyArray foo(NumpyAnyArray array);

    // Accept a 3-dimensional float32 array and transpose it
    // into ascending axis order (&#39;F&#39; order).
void foo(NumpyArray&lt;3, float&gt; array);

    // Accept a 2-dimensional float32 array with an arbitrary number of channels and
    // transpose the axes into VIGRA (&#39;V&#39;) order (channels are last, other axes ascending).
    // Note that the NumpyArray dimension is 3 to account for the channel dimension.
    // If the original numpy array has no channel axis, vigranumpy will automatically
    // insert a singleton axis.
void foo(NumpyArray&lt;3, Multiband&lt;float&gt; &gt; array);

    // Accept a 2-dimensional float32 array that has only a single channel
    // (that is, &#39;array.channels == 1&#39; must hold on the Python side).
    // Non-channel axes are transposed into ascending order.
    // Note that the NumpyArray dimension is now 2.
void foo(NumpyArray&lt;2, Singleband&lt;float&gt; &gt; array);

    // Accept a float32 array that has 2 non-channel dimensions and
    // exactly 3 channels (i.e. &#39;array.channels == 3&#39; on the Python side).
    // Non-channel axes are transposed into ascending order.
    // Note that the NumpyArray dimension is again 2, but the pixel type is
    // now a vector.
    // The conversion will only succeed if the channel axis is unstrided on
    // the Python side (that is, the following expression is True:
    //      array.strides[array.channelIndex] == array.dtype.itemsize).
void foo(NumpyArray&lt;2, TinyVector&lt;float, 3&gt; &gt; array);
void foo(NumpyArray&lt;2, RGBValue&lt;float&gt; &gt; array);
</pre></div>
</div>
<p>Or course, these functions can also be templated.</p>
<p>When your functions return newly allocated arrays, it is usually desirable to transfer the input&#8217;s axistags to the output (otherwise, vigranumpy will use <a class="reference internal" href="#vigra.VigraArray.defaultAxistags" title="vigra.VigraArray.defaultAxistags"><tt class="xref py py-meth docutils literal"><span class="pre">defaultAxistags()</span></tt></a> as a fallback). There is a standard vigranumpy idiom for this task which assumes that the wrapped function has an optional parameter &#8216;output&#8217; for a possibly pre-allocated output array. The axistags are then transferred by reshaping the output array with a <tt class="docutils literal"><span class="pre">taggedShape()</span></tt> (which is a combination of a shape and axistags):</p>
<div class="highlight-python"><div class="highlight"><pre>NumpyAnyArray
foo(NumpyArray&lt;3, Multiband&lt;float32&gt; &gt; input,
    NumpyArray&lt;3, Multiband&lt;float32&gt; &gt; output = boost::python::object())
{
    // Reshape only if the output array was not explicitly passed in.
    // Otherwise, use the output array as is.
    output.reshapeIfEmpty(input.taggedShape(),
              &quot;error message when shape is unsuitable.&quot;);

    ... // your algorithm
}
</pre></div>
</div>
<p>It is also possible to modify the tagged shape before it is applied to the output array:</p>
<div class="highlight-python"><div class="highlight"><pre>input.taggedShape()
     .resize(Shape2(new_width, new_height))
     .setChannelCount(new_channel_count)
     .setChannelDescription(&quot;a description&quot;)
</pre></div>
</div>
<p>The C++ code can be multi-threaded when you unlock Python&#8217;s global interpreter lock. After unlocking, your wrapper code must not call any Python functions, so the unlock statement should go after <tt class="docutils literal"><span class="pre">output.reshapeIfEmpty()</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>NumpyAnyArray
foo(NumpyArray&lt;3, Multiband&lt;float32&gt; &gt; input,
    NumpyArray&lt;3, Multiband&lt;float32&gt; &gt; output = boost::python::object())
{
    output.reshapeIfEmpty(input.taggedShape(), &quot;Message.&quot;);

        // Allow parallelization from here on. The destructor of
        // _pythread will automatically regain the global interpreter lock
        // just before this function returns to Python.
    PyAllowThreads _pythread;

    ... // your algorithm
}
</pre></div>
</div>
</li>
<li><p class="first">Export your wrapped functions. <tt class="docutils literal"><span class="pre">boost::python::def</span></tt> is called in its usual way, with one simple extension: Since vigranumpy does not know which NumpyArray variants you are going to use, appropriate converter functions between Python and C++ must be registered on demand. You do this by enclosing your function pointer into a call to the &#8216;registerConverters()&#8217; function:</p>
<div class="highlight-python"><div class="highlight"><pre>// in the module&#39;s init function
def(&quot;my_function&quot;, vigra::registerConverters(&amp;my_function),
   (arg(&quot;arg1&quot;), ...),
   &quot;Documentation&quot;);
</pre></div>
</div>
</li>
</ol>
<p>If you need more information, it is always a good idea to look at the source code of the existing vigranumpy modules.</p>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1><a class="toc-backref" href="#id102">Indices and tables</a><a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul>
<li><p class="first"><a class="reference internal" href="genindex.html"><em>Index</em></a></p>
</li>
<li><p class="first"><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></p>
</li>
<li><p class="first"><a class="reference internal" href="search.html"><em>Search Page</em></a></p>
<blockquote>
<div></div></blockquote>
</li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Vigranumpy Reference</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#axistags-and-the-vigraarray-data-structure">Axistags and the VigraArray Data Structure</a></li>
<li><a class="reference internal" href="#more-on-the-motivation-and-use-of-axistags">More On the Motivation and Use of Axistags</a><ul>
<li><a class="reference internal" href="#history-of-the-problem">History of the problem</a></li>
<li><a class="reference internal" href="#arrays-as-matrices">Arrays as Matrices</a></li>
<li><a class="reference internal" href="#arrays-as-images">Arrays as Images</a></li>
<li><a class="reference internal" href="#multi-dimensional-arrays">Multi-Dimensional Arrays</a></li>
<li><a class="reference internal" href="#vigra-and-numpy">VIGRA and numpy</a></li>
<li><a class="reference internal" href="#vigranumpy-axistags">Vigranumpy Axistags</a></li>
<li><a class="reference internal" href="#vigranumpy-conventions">Vigranumpy Conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#axistag-reference">Axistag Reference</a></li>
<li><a class="reference internal" href="#vigraarray-reference">VigraArray Reference</a></li>
<li><a class="reference internal" href="#chunked-arrays-and-data-bigger-than-ram">Chunked Arrays and Data Bigger than RAM</a><ul>
<li><a class="reference internal" href="#classes">Classes</a></li>
<li><a class="reference internal" href="#factory-functions">Factory Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#import-and-export-functions">Import and Export Functions</a></li>
<li><a class="reference internal" href="#mathematical-functions-and-type-coercion">Mathematical Functions and Type Coercion</a></li>
<li><a class="reference internal" href="#color-and-intensity-manipulation">Color and Intensity Manipulation</a></li>
<li><a class="reference internal" href="#filters">Filters</a></li>
<li><a class="reference internal" href="#sampling-image-resizing-and-image-pyramids">Sampling: Image Resizing and Image Pyramids</a></li>
<li><a class="reference internal" href="#fourier-transforms">Fourier Transforms</a></li>
<li><a class="reference internal" href="#image-analysis">Image Analysis</a></li>
<li><a class="reference internal" href="#geometry">Geometry</a></li>
<li><a class="reference internal" href="#optimization">Optimization</a></li>
<li><a class="reference internal" href="#machine-learning">Machine Learning</a></li>
<li><a class="reference internal" href="#noise-estimation-and-normalization">Noise Estimation and Normalization</a></li>
<li><a class="reference internal" href="#histogram-and-channel-representation">Histogram and Channel Representation</a></li>
<li><a class="reference internal" href="#graphs-and-algorithms-on-graphs">Graphs and Algorithms on Graphs</a></li>
<li><a class="reference internal" href="#utilities">Utilities</a></li>
<li><a class="reference internal" href="#writing-your-own-c-modules">Writing Your Own C++ Modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">vigranumpy 1.11.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright , Ullrich Koethe and others.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>