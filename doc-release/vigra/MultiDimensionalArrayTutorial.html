<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Multi-Dimensional Arrays</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
<script>
var runOnLoad=function(c,o,d,e){function x(){for(e=1;c.length;)c.shift()()}o[d]?(document[d]('DOMContentLoaded',x,0),o[d]('load',x,0)):o.attachEvent('onload',x);return function(t){e?o.setTimeout(t,0):c.push(t)}}([],window,'addEventListener');
</script>
<script type="text/javascript" src="documents/CollapsibleLists.js"></script>
<script type="text/javascript">
    runOnLoad(function(){ CollapsibleLists.apply(); });
</script>
<style type="text/css">
.collapsibleList li.collapsibleListOpen{
  list-style-image:url('documents/pfeil.gif');
  cursor:pointer;
}
.collapsibleList li.collapsibleListClosed{
  list-style-image:url('documents/bullet.gif');
  cursor:pointer;
}
.collapsibleList li.lastItem{
  list-style-image:url('documents/diamond.gif');
}
</style>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://ukoethe.github.io/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">Multi-Dimensional Arrays 
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="textblock"><h2>Section Contents</h2>
<ul style="list-style-image:url(documents/diamond.gif)">
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayBasics">Basic MultiArray Usage</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayIndexing">Array Indexing via Coordinates</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayScanOrder">One-dimensional Indexing and Scan-Order Iterator</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayMethods">Important MultiArray Methods</a> <ul type="disc">
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayViewBasics">The MultiArrayView Interface</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArray_subarray">subarray(p,q)</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArray_bind">bind&lt;M&gt;(i) and bindAt(M, i)</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArray_vector_elements">expandElements(k) and bindElementChannel(i)</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArray_transpose">transpose()</a> </li>
<li>
<a class="el" href="MultiDimensionalArrayTutorial.html#MultiArray_unstrided">isUnstrided(k)</a> </li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="MultiArrayBasics"></a>
Basic MultiArray Usage</h1>
<p><a class="el" href="classvigra_1_1MultiArray.html">vigra::MultiArray</a> is the most fundamental data structure in VIGRA. It holds a rectangular block of values in arbitrary many dimensions. Most VIGRA functions operate on top of MultiArray or the associated class MultiArrayView (see <a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayViewBasics">The MultiArrayView Interface</a>).</p>
<p>A 2D image can be interpreted as a matrix, i.e. a 2-dimensional array, where each element holds the information of a specific pixel. Internally, the data are stored in a single 1-dimensional piece of memory, and MultiArray encapsulates the entire mapping between our familiar 2-dimensional notation and the raw memory. Pixels in an image are identified by a coordinate pair (x,y), where indexing starts at 0. That is, the pixels in a 800x600 image are indexed by <code>x = 0,...,799 and y = 0,...,599</code>. The principle analoguously extends to higher dimensions.</p>
<p>The structure of a multidimensional array is given by its <code>shape</code> vector, and the length of the shape vector is the array's <em>dimension</em>. The dimension must be fixed as a template parameter at compule time, while the shape is passed to the array's constructor. The second important template parameter is the pixel's <code>value_type</code>, as you know it form <code>std::vector</code>.</p>
<p>To represent the data of a gray scale image, we just need to store one value per pixel, so we choose a 2-dimensional array, where each element has the <code> unsigned char </code> type (in VIGRA, this type is also available as <a class="el" href="group__FixedSizeInt.html#ga7332da5f8bfdbeecdfd09d4ed602288d">vigra::UInt8</a>). We instantiate a gray scale image object like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vigra/multi_array.hxx&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>vigra; <span class="comment">// for brevity in the examples - don&#39;t do this in header files!</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> width = ...,  height = ...;</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">MultiArray&lt;2, UInt8&gt;</a> image(Shape2(width, height));</div>
</div><!-- fragment --><p>By default, VIGRA arrays are <b>always zero-initialized</b>. Another initial value can be provided in the constructor, or later via the <code>init()</code> function or the assignment operator:</p>
<div class="fragment"><div class="line">MultiArray&lt;2, UInt8&gt; image(Shape2(width, height), 255); <span class="comment">// init with value 255</span></div>
<div class="line"></div>
<div class="line">image.init(128);  <span class="comment">// same effect, different initial value</span></div>
<div class="line">image = 100;      <span class="comment">// yet another way</span></div>
</div><!-- fragment --><p>The <code>Shape2</code> typedef also exists for higher dimensions up to five as <code>Shape3</code> etc. If you need even more dimensions, use <code>MultiArrayShape&lt;N&gt;::type</code> instead, were N is the number of dimensions:</p>
<div class="fragment"><div class="line"><span class="comment">// dimension 0 runs from 0, 1, ..., 299</span></div>
<div class="line"><span class="comment">// dimension 1 runs from 0, 1, ..., 199</span></div>
<div class="line"><span class="comment">// dimension 2 runs from 0, 1, ...,  99</span></div>
<div class="line">MultiArray&lt;3, double&gt; volume(Shape3(300, 200, 100));</div>
<div class="line"></div>
<div class="line">MultiArray&lt;7, float&gt; array7D(MultiArrayShape&lt;7&gt;::type(20, 10, ...));</div>
</div><!-- fragment --><p>When storing RGB images we obviously can't simply use the unsigned char type because every pixel contains 3 numbers: values for red, green and blue. Mathematically, you want to store a data vector for each pixel. To this end, VIGRA provides the <code>vigra::RGBValue&lt;ValueType&gt;</code> class. So for RGB-images just use: </p>
<div class="fragment"><div class="line">MultiArray&lt;2, RGBValue&lt;UInt8&gt; &gt; rgb_image(Shape2(256, 128));</div>
</div><!-- fragment --><p>vigra::RGBValue&lt;ValueType&gt; is a specialised 3-dimensional vector containing ValueType elements. Arbitrary short vectors can be stored in the <code>TinyVector&lt;ValueType, SIZE&gt;</code> class, which is the base class of RGBValue. It's length must be specified at compile time in the template parameter <code>SIZE</code>. Vectors whose length is known at compile time are very useful for the compiler to produce highly optimized code. Therefore, <code>Shape2</code> and it's higher-dimensional cousins are instances of <code>TinyVector</code> as well.</p>
<p>Alternatively you can use a 3-dimensional array <code><a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management. ">vigra::MultiArray</a>&lt;3, unsigned char&gt;</code> to represent a color image. The third dimension has size 3 and contains the information for the red, green and blue channel.</p>
<div class="fragment"><div class="line">MultiArray&lt;3, UInt8&gt; rgb_array(Shape3(256, 128, 3));</div>
</div><!-- fragment --><p>However, we are not going to use this form in the tutorial because <code>vigra::RGBValue&lt;ValueType&gt;</code> provides many helpful methods that are not available when color is just another array dimension.</p>
<h1><a class="anchor" id="MultiArrayIndexing"></a>
Array Indexing via Coordinates</h1>
<p>The easiest way to access the values of an array is via the coordinates. A tuple of coordinates can again be specified by the appropriate shape object, which must be passed to the array's indexing operator:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> width = 300, height = 200;</div>
<div class="line">MultiArray&lt;2, int&gt; image(Shape2(width, height));</div>
<div class="line"></div>
<div class="line"><span class="comment">// set all elements to 3</span></div>
<div class="line">image.init(3);</div>
<div class="line"></div>
<div class="line"><span class="comment">// print pixel at x=1 and y=2</span></div>
<div class="line"><span class="keywordtype">int</span> x=1, y=2;</div>
<div class="line">std::cout &lt;&lt; image[Shape2(x,y)] &lt;&lt; std::endl;  <span class="comment">// output: 3</span></div>
</div><!-- fragment --><p><b>Important Remark:</b> Notice that VIGRA follows the mathematical convention of the index order: dimension 0 corresponds to the x (horizontal) coordinate, dimension 1 to the y (vertical) coordinate, and so on. Accordingly, dimension 0 is changing fastest in memory: when we increase x by one, we get to the next memory location. In matrix jargon, this is also known as <em>Fortran order</em>. Many image processing libraries (e.g. <a href="http://www.imagemagick.org/">Image Magick</a>, <a href="http://opencv.willowgarage.com/">OpenCV</a>, and <a href="http://qt-project.org/">Qt</a>) use the same convention. However, others like Matlab and numpy, use the reverse order (so called <em>C order</em>). Don't be confused!</p>
<p>Internally, shape objects are implemented in terms of the powerful <a class="el" href="classvigra_1_1TinyVector.html">vigra::TinyVector</a> class. This means that shape objects support the usual mathematical operations like addition, multiplication and scalar products. Coordinate computations can thus be performed on entire coordinate objects at once - there is no need to manipulate the individual coordinates separately.</p>
<p>Nonetheless, in some circumstances it is more convenient to provide coordinates individually rather than in a shape object. This is possible with round brackets (x,y):</p>
<div class="fragment"><div class="line"><span class="comment">// access via individual coordinates</span></div>
<div class="line">image(1,2) = 22;</div>
</div><!-- fragment --><p>This kind of indexing is supported for dimensions up to five, and only if the array's dimension is known (this is not always the case: in a generic function where the dimension is a template parameter, you must use shape objects). In combination with the method <code>shape(n)</code>, that returns the length of the n-th dimension, we can use the coordinates to set the element of an entire row or column:</p>
<div class="fragment"><div class="line"><span class="comment">// set all elements of first row to 13</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; image.shape(1); i++)</div>
<div class="line">    image(1,i) = 13;</div>
</div><!-- fragment --><p>On first sight, individual coordinates may seem to be necessary for iterating over the image or parts of it. But the following example shows that the same effect can be achieved with a shape object that is allocated outside the loop: 3rd column of a 8x4-matrix (initialized with 5) to 7.</p>
<div class="fragment"><div class="line"><span class="comment">// instantiate shape object (zero intialized by default)</span></div>
<div class="line">Shape2 p;</div>
<div class="line"><span class="comment">// bind x=2</span></div>
<div class="line">p[0] = 2;</div>
<div class="line"><span class="comment">// iterator over row 2</span></div>
<div class="line"><span class="keywordflow">for</span>(p[1]=0; p[1]&lt;image.shape(1); ++p[1])</div>
<div class="line">    image[p] = 7;</div>
</div><!-- fragment --><p>We will discuss more powerful methods to access certain parts of an array in section <a class="el" href="MultiDimensionalArrayTutorial.html#MultiArrayMethods">Important MultiArray Methods</a>.</p>
<h1><a class="anchor" id="MultiArrayScanOrder"></a>
One-dimensional Indexing and Scan-Order Iterator</h1>
<p>Regardless of the array's dimension, it is always possible to access elements with 1-dimensional index, its <em>scan-order index</em>, via the normal indexing operator. For example, <code>array[1]</code> refers to the index of the second array element. Defining a scan order is often called <em>flattening</em> of an array, because a high-dimensional data structure is accessed like a 1-dimensional vector. Notive that scan-order access in VIGRA does not require the data to be copied.</p>
<p>VIGRA defines scan-order by considering the dimensions from front to back. Thus, items are accessed such that only the x coordinate is incremented, while y (and possibly further coordinates) are held fixed at 0. When x is exhausted, y is incremented by one and the iteration starts again at x=0. To control iteration, the function <code>array.size()</code> returns the total number of elements:</p>
<div class="fragment"><div class="line">MultiArray&lt;2, int&gt; intArray(Shape2(3,2));</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;intArray.size(); ++k=</div>
<div class="line">    intArray[k] = k+1;</div>
<div class="line"></div>
<div class="line"><span class="comment">// the array now contains the values</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//   1 2 3</span></div>
<div class="line"><span class="comment">//   4 5 6</span></div>
</div><!-- fragment --><p>Alternatively, scan-order access can be achieved with an STL-compatible iterator pair obtained by calling <code>array.begin()</code> and <code>array.end()</code>. Continuing with the example above, we can write:</p>
<div class="fragment"><div class="line"><span class="comment">// declare an alias for the iterator type</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html#a6a8ffa1c2eb8d394ca502402e4c60792">MultiArray&lt;2, int&gt;::iterator</a> Iter;</div>
<div class="line"></div>
<div class="line"><span class="comment">// iterate over intArray and print the elements in scan order</span></div>
<div class="line"><span class="keywordflow">for</span> (Iter i = intArray.begin(); i != intArray.end(); ++i)</div>
<div class="line">    std::cout &lt;&lt; *i &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// output: 1 2 3 4 5 6</span></div>
</div><!-- fragment --><p>The iterator is implemented by class <code>StridedScanOrderIterator</code> which encapsulates all the bookkeeping necessary to get the elements in the correct order, even when the array was transposed (see below).</p>
<p>Scan-order access is useful to implement pointwise operations, e.g. the addition of two matrices. The following code adds two matrices and stores the result in the first one:</p>
<div class="fragment"><div class="line">MultiArray&lt;2, int&gt; matrix1(Shape2(3,3)),</div>
<div class="line">                   matrix2(Shape2(3,3));</div>
<div class="line">... <span class="comment">// fill in data</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// use indexing</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; matrix1.size(); ++i)</div>
<div class="line">    matrix1[i] += matrix2[i];</div>
<div class="line"></div>
<div class="line"><span class="comment">// use iterators</span></div>
<div class="line"><span class="keywordflow">for</span> (Iter i = matrix1.begin(), j = matrix2.begin(); i != matrix1.end(); ++i, ++j)</div>
<div class="line">     i += *j;</div>
</div><!-- fragment --><p>This is convenient because the actual high-dimensional shapes of the arrays are of no significance for point-wise operations as long as the shapes match. Be careful: the arrays themselves have no way of checking this condition. So thefollowing code using two transposed shapes is perfectly valid C++, but has probably not the intended effect:</p>
<div class="fragment"><div class="line">MultiArray&lt;2, int&gt; matrix3(Shape2(3,2)),</div>
<div class="line">                   matrix4(Shape2(2,3));  <span class="comment">// transposed shape of matrix3</span></div>
<div class="line">... <span class="comment">// fill in data</span></div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; matrix3.size(); ++i)</div>
<div class="line">    matrix3[i] += matrix4[i];  <span class="comment">// works, but may not have the intended effect</span></div>
</div><!-- fragment --><p>By the way: VIGRA provides the += operator (and is cousins) to write this more concisely, and this operator throws an exception if the shapes don't match:</p>
<div class="fragment"><div class="line">matrix1 += matrix2;          <span class="comment">// works fine!</span></div>
<div class="line">matrix3 += matrix4;          <span class="comment">// error: shape mismatch!</span></div>
</div><!-- fragment --><p>For more information on mathematical operations on arrays see the <a class="el" href="group__MultiMathModule.html">multi_math</a> module.</p>
<p>As mentioned, VIGRA's scan order is similar to the NumPy-method <code>array.flatten()</code>. You use it, to copy a multi-dimensional array into an one-dimensional array, or to access elements in flattened order. The only difference is that NumPy uses "C-order" , i.e. the rightmost dimension takes priority, whereas VIGRA uses Fortran-order, i.e. the leftmost dimension takes priority. A method like flatten can be implemented in VIGRA as:</p>
<div class="fragment"><div class="line">MultiArray&lt;2, int&gt; intArray(Shape2(3,2));</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;intArray.size(); ++k=</div>
<div class="line">    intArray[k] = k+1;</div>
<div class="line"></div>
<div class="line"><span class="comment">// create 1D-array of appropriate size</span></div>
<div class="line">std::vector&lt;int&gt; flatArray(intArray.size());</div>
<div class="line"></div>
<div class="line"><span class="comment">// copy 2D-array into 1D-array using the STL</span></div>
<div class="line">std::copy(intArray.begin(), intArray.end(), flatArray.begin());</div>
<div class="line"></div>
<div class="line"><span class="comment">// print 1D-array on console</span></div>
<div class="line"><span class="comment">// (same output as printing from the StridedScanOrderIterator directly)</span></div>
<div class="line"><span class="keywordflow">for</span> (std::vector&lt;int&gt;::iterator i = flatArray.begin(); i != flatArray.end(); ++i)</div>
<div class="line">     std::cout &lt;&lt; *iter &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>To show the difference between VIGRA and NumPy we'll add the NumPy output, i.e. the result when we had used C-order in the code above:</p>
<pre class="fragment">flatArray - index     0       1       2       3       4       5
-----------------------------------------------------------------
VIGRA-output:         1       2       3       4       5       6
intArray - index    [0,0]   [1,0]   [2,0]   [0,1]   [1,1]   [2,1]
-----------------------------------------------------------------
NumPy-output:         1       4       2       5       3       6
intArray - index    [0,0]   [0,1]   [1,0]   [1,1]   [2,0]   [2,1]
</pre><p>To change the axis priorities of the StridedScanOrderIterator, look at the transpose-function in the next section.</p>
<h1><a class="anchor" id="MultiArrayMethods"></a>
Important MultiArray Methods</h1>
<p>This part of the tutorial explains important methods of MultiArray. However, before we proceed, we need to introduce the class <a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a>.</p>
<h2><a class="anchor" id="MultiArrayViewBasics"></a>
The MultiArrayView Interface</h2>
<p>A <a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a> has the same interface as a MultiArray (with the exception of <code>reshape()</code> and <code>swap()</code>), but it doesn't own its data. Instead, it provides a <em>view</em> onto the data of some other array. In contrast, a MultiArray owns its data and is responsible for freeing it in the destructor. MultiArrays are automatically converted into MultiArrayViews when needed.</p>
<p>The point of this distinction is that MultiArrayViews can be used to access and manipulate the same data in many different ways <em>without any need for creating copies</em>. For example, we can work with a 2-dimensional slice of a volume dataset (i.e. a lower dimensional part of a 3D array) without first copying the slice into a 2D image. This is possible whenever the desired view can be realized by just manipulating the internal <em>mapping</em> from indices and shapes to memory locations, and not the memory layout itself.</p>
<p>This possibility &ndash; which is similarly implemented in other packages like Matlab and numpy &ndash; is a key ingredient for efficient computations with multi-dimensional arrays. Thus, most VIGRA functions actually receive MultiArrayViews to maximize flexibility. This section describes the most important ways to create new MultiArrayViews from an existing array or view. The complete documentation is available in the <a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a> reference.</p>
<hr/>
<h2><a class="anchor" id="MultiArray_subarray"></a>
subarray(p,q)</h2>
<p>This method creates a rectangular subarray of your array between the points p and q, where p (the starting point of the subregion) is included, q (the ending point) is not. <code>subarray</code> does not change the dimension of the array (this is the task of the various <code>bind</code>-methods).</p>
<p>To give an example, we create a 4x4 array that consitst of a checkerboard with 2x2 squares:</p>
<div class="fragment"><div class="line">MultiArray&lt;2, float&gt; array_4x4(Shape2(4,4));  <span class="comment">// zero (black) initialized</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// paint the upper left 2x2 square white</span></div>
<div class="line">array_4x4.subarray(Shape2(0,0), Shape2(2,2)) = 1.0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// likewise for the lower right 2x2 square, but this time we</span></div>
<div class="line"><span class="comment">// store the array view explicitly for illustration</span></div>
<div class="line">MultiArrayView&lt;2, int&gt; lower_right_square = array_4x4.subarray(Shape2(2,2), Shape2(4,4));</div>
<div class="line">lower_right_square = 1.0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// contents of array_4x4 now:</span></div>
<div class="line"><span class="comment">//    1 1 0 0</span></div>
<div class="line"><span class="comment">//    1 1 0 0</span></div>
<div class="line"><span class="comment">//    0 0 1 1</span></div>
<div class="line"><span class="comment">//    0 0 1 1</span></div>
</div><!-- fragment --><p>The positions p and q are specified with the familiar <code>Shape</code> objects. In this example we simply overwrite parts of the array. The following larger example uses <code>subarray</code> to output a half-sized subimage around the center of the original image: <a href="subimage_tutorial_8cxx-example.html">subimage_tutorial.cxx</a> <br/>
 The relevant part of this code is shown here (the functions <code>importImage</code> and <code>exportImage</code> are described in section <a class="el" href="ImageInputOutputTutorial.html">Image Input and Output</a>):</p>
 <div class="fragment"><div class="line">        <span class="comment">// read image given as first argument</span></div>
<div class="line">        <span class="comment">// file type is determined automatically</span></div>
<div class="line">        ImageImportInfo info(argv[1]);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span>(info.isGrayscale()) </div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// read image from file</span></div>
<div class="line">            MultiArray&lt;2, UInt8&gt; imageArray(info.shape());</div>
<div class="line">            importImage(info, imageArray);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// we want to cut out the center of the original image, such that the </span></div>
<div class="line">            <span class="comment">// size of the remaining image is half the original</span></div>
<div class="line">            Shape2 upperLeft  = info.shape() / 4,</div>
<div class="line">                   lowerRight = info.shape() - upperLeft;</div>
<div class="line">        </div>
<div class="line">            <span class="comment">// create subimage around center for output</span></div>
<div class="line">            MultiArrayView&lt;2, UInt8&gt; subimage = imageArray.subarray(upperLeft, lowerRight);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// write the subimage to the file provided as second command line argument</span></div>
<div class="line">            <span class="comment">// the file type will be determined from the file name&#39;s extension</span></div>
<div class="line">            exportImage(subimage, ImageExportInfo(argv[2]));</div>
</div><!-- fragment --></p>
<p>After reading the (here: gray scale) image data to an array we need to calculate the coordinates of our subimage. In this case we want to cut out the middle part of the image. Afterwards we write the subimage into a new array. Look at the result:</p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_small.gif" alt="lenna_small.gif"/>
<div class="caption">
input file</div></div>
  </td><td><div class="image">
<img src="lenna_sub.gif" alt="lenna_sub.gif"/>
<div class="caption">
subimage output file</div></div>
   </td></tr>
</table>
<hr/>
<h2><a class="anchor" id="MultiArray_bind"></a>
bind&lt;M&gt;(i) and bindAt(M, i)</h2>
<p>These methods bind axis M to the index i and thus reduce the dimension of the array by one. The only difference between the two forms is that the axis to be bound must be known at compile time in the first form, whereas it can be specified at runtime in the second.</p>
<p>Binding is useful when we want to access and/or manipulate a particular row or column of an image, or a single slice of a volume. In principle, the same can also be achieved by explicit loops, but use of <code>bind</code> often leads to more elegant and more generic code. Consider the following code to initialize the third column of an image with the constant 5:</p>
<div class="fragment"><div class="line"><span class="comment">// initialize 200x100 image</span></div>
<div class="line">MultiArray&lt;2, int&gt; array2d(Shape2(200,100)); <span class="comment">// zero initialized</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// initialize column 2 with value 5 using a loop</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;array2d.shape(1); ++y)</div>
<div class="line">    array2d(2, y) = 5;</div>
<div class="line"></div>
<div class="line"><span class="comment">// the same using bind</span></div>
<div class="line">array2d.bind&lt;0&gt;(2) = 5;</div>
</div><!-- fragment --><p>NumPy-Users are familiar with the bind mechanism as "slicing". The example above written in numpy syntax becomes: </p>
<pre class="fragment">array2d[2, :] = 5      // NumPy-equivalent of array2d.bind&lt;0&gt;(2) = 5
</pre><p>You can also initialize a lower-dimensional array with the bind-method:</p>
<div class="fragment"><div class="line"><span class="comment">// initialize new 1D array with 3rd column of a 2D array</span></div>
<div class="line">MultiArray&lt;1, int&gt; array1d = array2d.bind&lt;0&gt;(2);</div>
</div><!-- fragment --><p>The array <code>array1d</code> contains the elements the 3rd column of <code>array2d</code>. This bahavior nicely illustrates the difference between a copy and a view: <code>array1d</code> contains a copy of the 3rd column, whereas the <code>bind</code> function only creates a new view to the existing data in <code>array2d</code>.</p>
<p>At this point we have to distinguish between the classes <code> MultiArray </code> and <code> MultiArrayView </code>. MultiArray inherits from MultiArrayView and contains the memory management of the array. With MultiArrayView we can view the data stored in a MultiArray. The code above produces a copy of the 3rd column of intArray. If we change the elements of <code>lowArray</code> nothing happens to <code> intArray </code>.</p>
<div class="fragment"><div class="line">     <span class="comment">// initialize 200x100 image</span></div>
<div class="line">MultiArray&lt;2, int&gt; array2d(Shape2(200,100)); <span class="comment">// zero initialized</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// initialize new 1D array with 3rd column of a 2D array</span></div>
<div class="line">MultiArray&lt;1, int&gt; array1d = array2d.bind&lt;0&gt;(2);</div>
<div class="line"></div>
<div class="line"><span class="comment">// overwrite element [0] of array1d</span></div>
<div class="line">array1d[0] = 1;</div>
<div class="line"></div>
<div class="line"><span class="comment">// this has no effect on the original array2d</span></div>
<div class="line"><span class="comment">// output: 0 1</span></div>
<div class="line">std::cout &lt;&lt; array2d(2, 0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; array1d[0] &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line"><span class="comment">// initialize a view and overwrite element [0]</span></div>
<div class="line">MultiArrayView&lt;1, int&gt; array_view = array2d.bind&lt;0&gt;(2);</div>
<div class="line">array_view[0] = 2;</div>
<div class="line"></div>
<div class="line"><span class="comment">// now, the original array2d has changed as well</span></div>
<div class="line"><span class="comment">// output: 2 2</span></div>
<div class="line">std::cout &lt;&lt; array2d(2, 0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; array_view[0] &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Moving on to image processing we'll give an example how you can flip an image by using bind. We read a gray scale image into a 2-dimensional array called <code> imageArray </code>. Then we initalize a new array <code> newImageArray </code> of the same dimension and size and set the first row of <code> newImageArray </code> to the values of the last row of <code> imageArray </code>, the second row to the values of the second last row and so on. Hence, we flip the image top to bottom.</p>
 <div class="fragment"><div class="line">            <span class="comment">// mirror the image horizontally </span></div>
<div class="line">            <span class="comment">// (for didactic reasons, we implement this variant explicitly,</span></div>
<div class="line">            <span class="comment">//  note that info.height()-1 is equal to the last y-index)</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y=0; y&lt;info.height(); y++) </div>
<div class="line">            {           </div>
<div class="line">                newImageArray.bind&lt;1&gt;(y) = imageArray.bind&lt;1&gt;(info.height()-1-y);</div>
<div class="line">            }</div>
</div><!-- fragment --></p>
<p>However, you don't need to implement a method like this yourself because VIGRA already provides the function <a class="el" href="group__GeometricTransformations.html#ga02b427bf3ae88c68505d5e18518d99b0">reflectImage()</a>. We use this function to flip the image left-to-right:</p>
 <div class="fragment"><div class="line">            <span class="comment">// mirror the image vertically</span></div>
<div class="line">            <a class="code" href="group__GeometricTransformations.html#ga02b427bf3ae88c68505d5e18518d99b0">reflectImage</a>(imageArray, newImageArray, vertical);</div>
</div><!-- fragment --></p>
<p>The complete example can be found in <a href="mirror_tutorial_8cxx-example.html">mirror_tutorial.cxx</a>. (This program needs an infile and an outfile as command-line arguments and contains additional I/O code which will be explained in section <a class="el" href="ImageInputOutputTutorial.html">Image Input and Output</a>.) Here you can see what happens to an input file:</p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_small.gif" alt="lenna_small.gif"/>
<div class="caption">
input file</div></div>
  </td><td><div class="image">
<img src="lenna_mirror_horizontal.gif" alt="lenna_mirror_horizontal.gif"/>
<div class="caption">
mirrored top to bottom</div></div>
 </td><td></td><td><div class="image">
<img src="lenna_mirror_vertical.gif" alt="lenna_mirror_vertical.gif"/>
<div class="caption">
mirrored left to right</div></div>
 </td><td></td></tr>
</table>
<p>For completeness, there are five additional versions of the bind()-method:</p>
<dl>
<dt><b> bindInner(i) </b> with scalar or multi-dimensional index i: </dt>
<dd>if i is an <code> integer </code>, the innermost dimension (axis 0) is fixed to i, <br/>
 if i is <code>MultiArrayShape&lt;M&gt;::type</code> (a shape of size M), then the M innermost dimensions (axes 0...M-1) are fixed to the values in the shape vector  </dd>
<dt><b> bindOuter(i) </b> with scalar or multi-dimensional index i: </dt>
<dd>if i is an <code> integer </code>, the outmost dimension (axis N-1) is fixed to i, <br/>
 if i is <code>MultiArrayShape&lt;M&gt;::type</code> (a shape of size M), then the M outmost dimensions (axes N-M ... N-1) are fixed to the values in the shape vector  </dd>
<dt><b> diagonal() </b>: </dt>
<dd>Create a 1-dimensional view to the diagonal elements of the original array (i.e. <code>view[i] == array(i,i,i)</code> for a 3D original array).  </dd>
</dl>
<p>The opposite of binding - inserting a new axis - is also possible. However, since we cannot alter the internal memory layout and thus cannot insert additional data elements, a new axis must be singleton axis, i.e. an axis with length 1. The argument of <code>insertSingletonDimension(k)</code> determines the position of the new axis, with <code>0 &lt;= k &lt;= N</code> when the original array has <code>N</code> dimensions:</p>
<div class="fragment"><div class="line">MultiArray&lt;2, int&gt; array(20,10);</div>
<div class="line">std::cout &lt;&lt; array.insertSingletonDimension(1).shape() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; <span class="comment">// prints &quot;(20, 1, 10)&quot;</span></div>
</div><!-- fragment --><hr/>
<h2><a class="anchor" id="MultiArray_vector_elements"></a>
expandElements(k) and bindElementChannel(i)</h2>
<p>When the array elements are vectors (i.e. <a class="el" href="classvigra_1_1TinyVector.html">vigra::TinyVector</a> or <a class="el" href="classvigra_1_1RGBValue.html">vigra::RGBValue</a>), we can expand these elements into an addtional array dimension: </p>
<div class="fragment"><div class="line">MultiArray&lt;2, TinyVector&lt;int, 3&gt; &gt; vector_array(20, 10);</div>
<div class="line">std::cout &lt;&lt; vector_array.shape() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;  <span class="comment">// prints &quot;(20, 10)&quot;</span></div>
<div class="line"></div>
<div class="line">MultiArrayView&lt;3, int&gt; expanded(vector_array.expandElements(2));</div>
<div class="line">std::cout &lt;&lt; expanded.shape() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;  <span class="comment">// prints &quot;(20, 10, 3)&quot;</span></div>
</div><!-- fragment --><p>The argument <code>k</code> of <code>expandElements(k)</code> determines the desired position of the channel axis, i.e. the index that refers to the vector elements. When the original vector array has <code>N</code> dimensions (not counting the channel axis), it is required that <code>0 &lt;= k &lt;= N</code>.</p>
<p>Often, we are only interested in a single channel of a vector-valued array. This can be achieved with the function <code>bindElementChannel(i)</code>. For example, we can extract the green channel (i.e. channel 1) from an RGB image like this: </p>
<div class="fragment"><div class="line">MultiArray&lt;2, RGBValue&lt;UInt8&gt; &gt; rgb_array(20, 10);</div>
<div class="line">MultiArrayView&lt;2, UInt8&gt; green_channel(rgb_array.bindElementChannel(1));</div>
</div><!-- fragment --><p> This is simply an abbreviation for <code>rgb_array.expandElements(0).bindInner(1)</code>.</p>
<hr/>
<h2><a class="anchor" id="MultiArray_transpose"></a>
transpose()</h2>
<p>Everyone is familiar with the <code><a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">transpose()</a></code> function of a matrix (i.e. a 2-dimensional array). Once again, this operation is possible without copying the data by just manipulating the internal access functions. The following example demonstrates the difference between a transposed copy and view:</p>
 <div class="fragment"><div class="line">    <span class="comment">// create array</span></div>
<div class="line">    MultiArray&lt;2, int&gt; base_array(Shape2(4,4));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// init array such that pixel values are equal to their x coordinate</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; base_array.size(); i++) </div>
<div class="line">    {</div>
<div class="line">        base_array[i] = i % base_array.shape(0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;base_array:\n&quot;</span>;</div>
<div class="line">    print(base_array);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// create a transposed array and a transposed view</span></div>
<div class="line">    MultiArray&lt;2, int&gt; transarray = base_array.transpose();</div>
<div class="line">    MultiArrayView&lt;2, int&gt; transarrayView = base_array.transpose();</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;transarray:\n&quot;</span>;</div>
<div class="line">    print(transarray);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;transArrayView:\n&quot;</span>;</div>
<div class="line">    print(transarrayView);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// set transarray to 5    </span></div>
<div class="line">    transarray = 5;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;base_array after setting transarray to 5\n(no change, since transarray is a copy):\n&quot;</span>;</div>
<div class="line">    print(base_array);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// set transarrayView to 5</span></div>
<div class="line">    transarrayView = 5;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;base_array after setting transarrayView to 5\n(base_array changes because transarrayView is a view):\n&quot;</span>;</div>
<div class="line">    print(base_array);</div>
</div><!-- fragment --></p>
<p>The output is:</p>
<pre class="fragment">base_array:
0  1  2  3
0  1  2  3
0  1  2  3
0  1  2  3
transarray:
0  0  0  0
1  1  1  1
2  2  2  2
3  3  3  3
transArrayView:
0  0  0  0
1  1  1  1
2  2  2  2
3  3  3  3
base_array after setting transarray to 5
(no change, since transarray is a copy):
0  1  2  3
0  1  2  3
0  1  2  3
0  1  2  3
base_array after setting transarrayView to 5
(base_array changes because transarrayView is a view):
5  5  5  5
5  5  5  5
5  5  5  5
5  5  5  5
</pre><p>The function <code><a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">MultiArrayView::transpose()</a></code> generalizes transposition to arrays of arbitrary dimensions. Here, it just reverses the order of the axes: axis 0 becomes axis N-1, axis 1 becomes axis N-2 and so on. In the following example we transpose a 5D array and print out its shape.</p>
 <div class="fragment"><div class="line">    <span class="comment">// transposing a 5D array</span></div>
<div class="line">    <span class="comment">// instantiate 5D array</span></div>
<div class="line">    MultiArray&lt;5, int&gt; array5D(Shape5(1,2,3,4,5));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// print the shape of the original array</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Shape of array5D: &quot;</span> &lt;&lt; array5D.shape() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// transpose array</span></div>
<div class="line">    MultiArrayView&lt;5, int&gt; arrayview5D = array5D.transpose();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// print the shape of transposed array</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Shape of array5D view after default transpose(): &quot;</span> &lt;&lt; arrayview5D.shape() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --></p>
<p>The output is:</p>
<pre class="fragment">Shape of array5D: (1, 2, 3, 4, 5)
Shape of array5D view after default transpose(): (5, 4, 3, 2, 1)
</pre><p>Finally, <code><a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">MultiArrayView::transpose()</a></code> can also be called with a shape object that specifies the desired permutation of the axes: When <code>permutation[k] = j</code>, axis <code>j</code> of the original array becomes axis <code>k</code> of the transposed array (remember, that VIGRA counts the axes from 0):</p>
 <div class="fragment"><div class="line">    <span class="comment">// transpose to an explicitly specified axis permutation</span></div>
<div class="line">    MultiArrayView&lt;5, int&gt; arrayview5D_permuted = array5D.transpose(Shape5(2,1,3,4,0));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// print the shape of transposed array</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Shape of array5D view after user-defined transpose(): &quot;</span> &lt;&lt; arrayview5D_permuted.shape() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;    (applied permutation 2 =&gt; 0, 1 =&gt; 1, 3 =&gt; 2, 4 =&gt; 3, 0 =&gt; 4 to the axes)\n&quot;</span>;</div>
</div><!-- fragment --></p>
<p>The permutation in the example is 2,1,3,4,0. Thus, original dimension 0 appears in the last position of the new view, original dimension 2 appears in the first position, and so on as demonstrated by the output of the example:</p>
<pre class="fragment">Shape of array5D view after user-defined transpose(): (3, 2, 4, 5, 1)
    (applied permutation 2 =&gt; 0, 1 =&gt; 1, 3 =&gt; 2, 4 =&gt; 3, 0 =&gt; 4 to the axes)
</pre><p>When we transpose an image about the major diagonal, we can simply use the view created by <code><a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">MultiArrayView::transpose()</a></code>. However, transposition about the minor diagonal requires a new image, which can be filled by <a class="el" href="group__GeometricTransformations.html#ga50e76dbde3e1b541755604f72e9eb090">transposeImage()</a> like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vigra/multi_array.hxx&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="impex_8hxx.html">vigra/impex.hxx</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vigra/basicgeometry.hxx&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>vigra; </div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(argc != 3) </div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; infile outfile&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;(grayscale images only, supported formats: &quot;</span> &lt;&lt; <a class="code" href="group__VigraImpex.html#ga1f42a533f86021968b8ca4d9d9644279">impexListFormats</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// choose diagonal for transpose</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Transpose about which diagonal?\n&quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;1 - major\n&quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;2 - minor\n&quot;</span>;</div>
<div class="line">    <span class="keywordtype">int</span> mode;</div>
<div class="line">    std::cin &gt;&gt; mode;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">try</span> </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// read image given as first command line argument</span></div>
<div class="line">        <a class="code" href="classvigra_1_1MultiArray.html">MultiArray&lt;2, UInt8&gt;</a> imageArray;</div>
<div class="line">        <a class="code" href="group__VigraImpex.html#ga01aca6d5278dab14e11aef62e746e63e">importImage</a>(argv[1], imageArray);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>(mode == 1)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// when transposing about the major diagonal, we can simply</span></div>
<div class="line">            <span class="comment">// write a transposed view to the file given as second argument</span></div>
<div class="line">            <a class="code" href="group__VigraImpex.html#gabd7976d498abce467cd17989176133e3">exportImage</a>(imageArray.transpose(), argv[2]);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// when transposing about the minor diagonal, we need a new</span></div>
<div class="line">            <span class="comment">// image with reversed shape to hold the transposed data</span></div>
<div class="line">            <a class="code" href="classvigra_1_1MultiArray.html">MultiArray&lt;2, UInt8&gt;</a> transposed(reverse(imageArray.shape()));</div>
<div class="line">            <a class="code" href="group__GeometricTransformations.html#ga50e76dbde3e1b541755604f72e9eb090">transposeImage</a>(imageArray, transposed, minor);</div>
<div class="line">            <a class="code" href="group__VigraImpex.html#gabd7976d498abce467cd17989176133e3">exportImage</a>(transposed, argv[2]);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (std::exception &amp; e) </div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// catch any errors that might have occurred and print their reason</span></div>
<div class="line">        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The result is:</p>
<table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="lenna_small.gif" alt="lenna_small.gif"/>
<div class="caption">
input file</div></div>
  </td><td><div class="image">
<img src="lenna_transposed_major.gif" alt="lenna_transposed_major.gif"/>
<div class="caption">
transpose about major diagonal</div></div>
  </td><td><div class="image">
<img src="lenna_transposed_minor.gif" alt="lenna_transposed_minor.gif"/>
<div class="caption">
transpose about minor diagonal</div></div>
   </td></tr>
</table>
<p>In VIGRA, image transposition is also implemented in function <code><a class="el" href="group__GeometricTransformations.html#ga50e76dbde3e1b541755604f72e9eb090" title="Transpose an image over the major or minor diagonal. ">vigra::transposeImage</a>(...)</code>. The difference is that <a class="el" href="group__GeometricTransformations.html#ga50e76dbde3e1b541755604f72e9eb090" title="Transpose an image over the major or minor diagonal. ">transposeImage()</a> copies the image data, whereas <a class="el" href="group__LinearAlgebraFunctions.html#ga38a88300083908488d85348c0cf4d3ff">MultiArrayView::transpose()</a> just changes the internal mapping from indices to memory locations.</p>
<p><b>Important note:</b> Transposing an array also changes the direction of the StridedScanOrderIterator. Imagine a 3x4- matrix. Scan-order means that we iterate from left to right, row by row. Now, let's transpose the matrix to a 4x3 view. Than, scan-order in the new view is again left to right, row by row. However, in the original matrix this now corresponds to a transposed scan: from top to bottom, column by column. The same applies to the array's index operator with integer argument.</p>
<hr/>
<h2><a class="anchor" id="MultiArray_unstrided"></a>
isUnstrided(k)</h2>
<p>A MultiArray always accesses its elements in consecutive memory order, i.e. <code>&amp;array[i] == &amp;array.data()[i]</code> for all <code>i</code> in the range <code>[0, array.size())</code>. However, this does in general not hold for MultiArrayViews, because changing array access is the whole point of view creation. Sometimes, it is necessary to find out if a view still has consecutive, unstrided memory access, for example when you want to pass on the view's data to an external library that only accepts plain C arrays: When the view happens to be unstrided, you can avoid to create a copy of the data. You can determine this with the function <code>isUnstrided(k)</code> which returns <code>true</code> when the array is unstrided up to dimension <code>k</code> (<code>k</code> defaults to <code>N-1</code>, i.e. the entire array must be unstrided): </p>
<div class="fragment"><div class="line">MultiArray&lt;2, int&gt; array(20,10);</div>
<div class="line">std::cout &lt;&lt; array.isUnstrided() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; array.transpose().isUnstrided() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;  <span class="comment">// prints &quot;true false&quot;</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.1 (Fri May 19 2017)
</i>
</tr>
</table>
</BODY>
</HTML>
