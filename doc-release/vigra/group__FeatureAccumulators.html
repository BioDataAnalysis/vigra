<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Feature Accumulators</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
<script>
var runOnLoad=function(c,o,d,e){function x(){for(e=1;c.length;)c.shift()()}o[d]?(document[d]('DOMContentLoaded',x,0),o[d]('load',x,0)):o.attachEvent('onload',x);return function(t){e?o.setTimeout(t,0):c.push(t)}}([],window,'addEventListener');
</script>
<script type="text/javascript" src="documents/CollapsibleLists.js"></script>
<script type="text/javascript">
    runOnLoad(function(){ CollapsibleLists.apply(); });
</script>
<style type="text/css">
.collapsibleList li.collapsibleListOpen{
  list-style-image:url('documents/pfeil.gif');
  cursor:pointer;
}
.collapsibleList li.collapsibleListClosed{
  list-style-image:url('documents/bullet.gif');
  cursor:pointer;
}
.collapsibleList li.lastItem{
  list-style-image:url('documents/diamond.gif');
}
</style>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://ukoethe.github.io/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">Feature Accumulators
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<p>The namespace <code><a class="el" href="namespacevigra_1_1acc.html">vigra::acc</a></code> provides the function <a class="el" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">vigra::acc::extractFeatures()</a> along with associated statistics functors and accumulator classes. Together, they provide a framework for efficient compution of a wide variety of statistical features, both globally for an entire image, and locally for each region defined by a label array. Many different statistics can be composed out of a small number of fundamental statistics and suitable modifiers. The user simply selects the desired statistics by means of their <em>tags</em> (see below), and a template meta-program automatically generates an efficient functor that computes exactly those statistics.</p>
<p>The function <a class="el" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures()</a> scans the data in as few passes as the selected statstics permit (usually one or two passes are sufficient). Statistics are computed by accurate incremental algorithms, whose internal state is maintained by accumulator objects. The state is updated by passing data to the accumulator one sample at a time. Accumulators are grouped within an accumulator chain. Dependencies between accumulators in the accumulator chain are automatically resolved and missing dependencies are inserted. For example, to compute the mean, you also need to count the number of samples. This allows accumulators to offload some of their computations on other accumulators, making the algorithms more efficient. Each accumulator only sees data in the appropriate pass through the data, called its "working pass".</p>
<p><b>#include</b> &lt;<a class="el" href="accumulator_8hxx_source.html">vigra/accumulator.hxx</a>&gt;</p>
<p><b>Basic statistics:</b></p>
<ul>
<li>PowerSum&lt;N&gt; (computes <img class="formulaInl" alt="$ \sum_i x_i^N $" src="form_0.png"/>)</li>
<li>AbsPowerSum&lt;N&gt; (computes <img class="formulaInl" alt="$ \sum_i |x_i|^N $" src="form_1.png"/>)</li>
<li>Skewness, UnbiasedSkewness</li>
<li>Kurtosis, UnbiasedKurtosis</li>
<li>Minimum, Maximum</li>
<li>FlatScatterMatrix (flattened upper-triangular part of scatter matrix)</li>
<li>4 histogram classes (see <a class="el" href="group__FeatureAccumulators.html#histogram">below</a>)</li>
<li>StandardQuantiles (0%, 10%, 25%, 50%, 75%, 90%, 100%)</li>
<li>ArgMinWeight, ArgMaxWeight (store data or coordinate where weight assumes its minimal or maximal value)</li>
<li>CoordinateSystem (identity matrix of appropriate size)</li>
</ul>
<p><b>Modifiers:</b> (S is the statistc to be modified)</p>
<ul>
<li>Normalization <table  border="0">
<tr>
<td>DivideByCount&lt;S&gt; </td><td>S/Count  </td></tr>
<tr>
<td>RootDivideByCount&lt;S&gt; </td><td>sqrt( S/Count )  </td></tr>
<tr>
<td>DivideUnbiased&lt;S&gt; </td><td>S/(Count-1)  </td></tr>
<tr>
<td>RootDivideUnbiased&lt;S&gt; &#160; &#160; </td><td>sqrt( S/(Count-1) )  </td></tr>
</table>
</li>
<li>Data preparation: <table  border="0">
<tr>
<td>Central&lt;S&gt; </td><td>substract mean before computing S  </td></tr>
<tr>
<td>Principal&lt;S&gt; </td><td>project onto PCA eigenvectors  </td></tr>
<tr>
<td>Whitened&lt;S&gt; &#160; &#160; </td><td>scale to unit variance after PCA  </td></tr>
<tr>
<td>Coord&lt;S&gt; </td><td>compute S from pixel coordinates rather than from pixel values  </td></tr>
<tr>
<td>Weighted&lt;S&gt; </td><td>compute weighted version of S  </td></tr>
<tr>
<td>Global&lt;S&gt; </td><td>compute S globally rather than per region (per region is default if labels are given)  </td></tr>
</table>
</li>
</ul>
<p>Aliases for many important features are implemented (mainly as <code>typedef FullName Alias</code>). The alias names are equivalent to full names. Below are some examples for supported alias names. A full list of all available statistics and alias names can be found in the namespace reference <code><a class="el" href="namespacevigra_1_1acc.html">vigra::acc</a></code>. These examples also show how to compose statistics from the fundamental statistics and modifiers:</p>
<table  border="0">
<tr>
<th>Alias </th><th>Full Name  </th></tr>
<tr>
<td>Count </td><td>PowerSum&lt;0&gt;  </td></tr>
<tr>
<td>Sum </td><td>PowerSum&lt;1&gt;  </td></tr>
<tr>
<td>SumOfSquares </td><td>PowerSum&lt;2&gt;  </td></tr>
<tr>
<td>Mean </td><td>DivideByCount&lt;PowerSum&lt;1&gt;&gt;  </td></tr>
<tr>
<td>RootMeanSquares &#160; </td><td>RootDivideByCount&lt;PowerSum&lt;2&gt;&gt;  </td></tr>
<tr>
<td>Moment&lt;N&gt; </td><td>DivideByCount&lt;PowerSum&lt;N&gt;&gt;  </td></tr>
<tr>
<td>Variance </td><td>DivideByCount&lt;Central&lt;PowerSum&lt;2&gt;&gt;&gt;  </td></tr>
<tr>
<td>StdDev </td><td>RootDivideByCount&lt;Central&lt;PowerSum&lt;2&gt;&gt;&gt;  </td></tr>
<tr>
<td>Covariance </td><td>DivideByCount&lt;FlatScatterMatrix&gt;  </td></tr>
<tr>
<td>RegionCenter </td><td>Coord&lt;Mean&gt;  </td></tr>
<tr>
<td>CenterOfMass </td><td>Weighted&lt;Coord&lt;Mean&gt;&gt;  </td></tr>
</table>
<p>There are a few <b>rules for composing statistics</b>:</p>
<ul>
<li>modifiers can be specified in any order, but are internally transformed to standard order: Global&lt;Weighted&lt;Coord&lt;normalization&lt;data preparation&lt;basic statistic</li>
<li>only one normalization modifier and one data preparation modifier (Central or Principal or Whitened) is permitted</li>
<li>Count ignores all modifiers except Global and Weighted</li>
<li>Sum ignores Central and Principal, because sum would be zero</li>
<li>ArgMinWeight and ArgMaxWeight are automatically Weighted</li>
</ul>
<pre class="fragment">Here is an example how to use \ref acc::AccumulatorChain to compute statistics. (To use Weighted&lt;&gt; or Coord&lt;&gt; modifiers, see below):
</pre><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vigra/multi_array.hxx&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="impex_8hxx.html">vigra/impex.hxx</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vigra/accumulator.hxx&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>vigra::acc;</div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">double</span> DataType;</div>
<div class="line"><span class="keywordtype">int</span> size = 1000;</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, DataType&gt;</a> data(vigra::Shape2(size, size));</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html">AccumulatorChain</a>&lt;DataType,</div>
<div class="line">    <a class="code" href="structvigra_1_1acc_1_1Select.html">Select&lt;Variance, Mean, StdDev, Minimum, Maximum, RootMeanSquares, Skewness, Covariance&gt;</a> &gt;</div>
<div class="line">    a;</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;passes required: &quot;</span> &lt;&lt; a.passesRequired() &lt;&lt; std::endl;</div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin(), data.end(), a);</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Mean: &quot;</span> &lt;&lt; get&lt;Mean&gt;(a) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Variance: &quot;</span> &lt;&lt; get&lt;Variance&gt;(a) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The <a class="el" href="classvigra_1_1acc_1_1AccumulatorChain.html">acc::AccumulatorChain</a> object contains the selected statistics and their dependencies. Statistics have to be wrapped with <a class="el" href="structvigra_1_1acc_1_1Select.html">acc::Select</a>. The statistics are computed with the <a class="el" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">acc::extractFeatures</a> function and the statistics can be accessed with <a class="el" href="namespacevigra_1_1acc.html#ae1dae7352beb92b0f5b64b44d4fca420">acc::get</a> .</p>
<p>Rules and notes:</p>
<ul>
<li>order of statistics in Select&lt;&gt; is arbitrary</li>
<li>up to 20 statistics in Select&lt;&gt;, but Select&lt;&gt; can be nested</li>
<li>dependencies are automatically inserted</li>
<li>duplicates are automatically removed</li>
<li>extractFeatures() does as many passes through the data as necessary</li>
<li>each accumulator only sees data in the appropriate pass (its "working pass")</li>
</ul>
<p>The Accumulators can also be used with vector-valued data (<a class="el" href="classvigra_1_1RGBValue.html" title="Class for a single RGB value. ">vigra::RGBValue</a>, <a class="el" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">vigra::TinyVector</a>, <a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management. ">vigra::MultiArray</a> or <a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray. ">vigra::MultiArrayView</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classvigra_1_1RGBValue.html">vigra::RGBValue&lt;double&gt;</a> DataType;</div>
<div class="line">AccumulatorChain&lt;DataType, Select&lt;...&gt; &gt; a;</div>
<div class="line">...</div>
</div><!-- fragment --><p>To compute <b>weighted statistics</b> (Weighted&lt;&gt;) or <b>statistics over coordinates</b> (Coord&lt;&gt;), the accumulator chain can be used with several coupled arrays, one for the data and another for the weights and/or the labels. "Coupled" means that statistics are computed over the corresponding elements of the involved arrays. This is internally done by means of <a class="el" href="classvigra_1_1CoupledScanOrderIterator.html">CoupledScanOrderIterator</a> and <a class="el" href="classvigra_1_1CoupledHandle.html">vigra::CoupledHandle</a> which provide simultaneous access to several arrays (e.g. weight and data) and corresponding coordinates. The types of the coupled arrays are best specified by means of the helper class <a class="el" href="structvigra_1_1CoupledArrays.html">vigra::CoupledArrays</a> :</p>
<div class="fragment"><div class="line"><a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;3, RGBValue&lt;unsigned char&gt;</a> &gt; data(...);</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;3, double&gt;</a>                   weights(...);</div>
<div class="line"></div>
<div class="line">AccumulatorChain&lt;CoupledArrays&lt;3, RGBValue&lt;unsigned char&gt;, <span class="keywordtype">double</span>&gt;,</div>
<div class="line">                 Select&lt;...&gt; &gt; a;</div>
</div><!-- fragment --><p>This works likewise for label images which are needed for region statistics (see below). The indxx of the array holding data, weights, or labels respectively can be specified inside the Select wrapper. These <b>index specifiers</b> are: (INDEX is of type int)</p>
<ul>
<li>DataArg&lt;INDEX&gt;: data are in array 'INDEX' (default INDEX=1)</li>
<li>LabelArg&lt;INDEX&gt;: labels are in array 'INDEX' (default INDEX=2)</li>
<li>WeightArg&lt;INDEX&gt;: weights are in array 'INDEX' (default INDEX=rightmost index)</li>
</ul>
<p>Pixel coordinates are always at index 0. To collect statistics, you simply pass all arrays to the <code>extractFeatures()</code> function: </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::acc;</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;3, double&gt;</a> data(...), weights(...);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html">AccumulatorChain&lt;CoupledArrays&lt;3, double, double&gt;</a>, <span class="comment">// two 3D arrays for data and weights</span></div>
<div class="line">    <a class="code" href="structvigra_1_1acc_1_1Select.html">Select&lt;DataArg&lt;1&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1WeightArg.html">WeightArg&lt;2&gt;</a>,           <span class="comment">// in which array to look (coordinates are always arg 0)</span></div>
<div class="line">           <a class="code" href="namespacevigra_1_1acc.html#ac0f533874b6415005dcf8974478c4b8e">Mean</a>, <a class="code" href="namespacevigra_1_1acc.html#af99d27303660e2b6e547d726f2ca8091">Variance</a>,                     <span class="comment">//statistics over values</span></div>
<div class="line">           <a class="code" href="classvigra_1_1acc_1_1Coord.html">Coord&lt;Mean&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1Coord.html">Coord&lt;Variance&gt;</a>,       <span class="comment">//statistics over coordinates,</span></div>
<div class="line">           <a class="code" href="classvigra_1_1acc_1_1Weighted.html">Weighted&lt;Mean&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1Weighted.html">Weighted&lt;Variance&gt;</a>, <span class="comment">//weighted values,</span></div>
<div class="line">           <a class="code" href="classvigra_1_1acc_1_1Weighted.html">Weighted&lt;Coord&lt;Mean&gt;</a> &gt; &gt; &gt;          <span class="comment">//weighted coordinates.</span></div>
<div class="line">    a;</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data, weights, a);</div>
</div><!-- fragment --><p>This even works for a single array, which is useful if you want to combine values with coordinates. For example, to find the location of the minimum element in an array, you interpret the data as weights and select the <code>Coord&lt;ArgMinWeight&gt;</code> statistic (note that the version of <code>extractFeatures()</code> below only works in conjunction with <code><a class="el" href="structvigra_1_1CoupledArrays.html">CoupledArrays</a></code>, despite the fact that there is only one array involved): </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::acc;</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;3, double&gt;</a> data(...);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html">AccumulatorChain&lt;CoupledArrays&lt;3, double&gt;</a>,</div>
<div class="line">                 <a class="code" href="structvigra_1_1acc_1_1Select.html">Select&lt;WeightArg&lt;1&gt;</a>,           <span class="comment">// we interprete the data as weights</span></div>
<div class="line">                        <a class="code" href="classvigra_1_1acc_1_1Coord.html">Coord&lt;ArgMinWeight&gt;</a> &gt; &gt; <span class="comment">// and look for the coordinate with minimal weight</span></div>
<div class="line">    a;</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data, a);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;minimum is at &quot;</span> &lt;&lt; get&lt;Coord&lt;ArgMinWeight&gt; &gt;(a) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>To compute <b>region statistics</b>, you use <a class="el" href="classvigra_1_1acc_1_1AccumulatorChainArray.html">acc::AccumulatorChainArray</a>. Regions are defined by means of a label array whose elements specify the region ID of the corresponding point. Therefore, you will always need at least two arrays here, which are again best specified using the <code><a class="el" href="structvigra_1_1CoupledArrays.html">CoupledArrays</a></code> helper:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::acc;</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;3, double&gt;</a> data(...);</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;3, int&gt;</a> labels(...);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html">AccumulatorChainArray&lt;CoupledArrays&lt;3, double, int&gt;</a>,</div>
<div class="line">    <a class="code" href="structvigra_1_1acc_1_1Select.html">Select&lt;DataArg&lt;1&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1LabelArg.html">LabelArg&lt;2&gt;</a>,       <span class="comment">// in which array to look (coordinates are always arg 0)</span></div>
<div class="line">           <a class="code" href="namespacevigra_1_1acc.html#ac0f533874b6415005dcf8974478c4b8e">Mean</a>, <a class="code" href="namespacevigra_1_1acc.html#af99d27303660e2b6e547d726f2ca8091">Variance</a>,                    <span class="comment">//per-region statistics over values</span></div>
<div class="line">           <a class="code" href="classvigra_1_1acc_1_1Coord.html">Coord&lt;Mean&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1Coord.html">Coord&lt;Variance&gt;</a>,      <span class="comment">//per-region statistics over coordinates</span></div>
<div class="line">           <a class="code" href="classvigra_1_1acc_1_1Global.html">Global&lt;Mean&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1Global.html">Global&lt;Variance&gt;</a> &gt; &gt; <span class="comment">//global statistics</span></div>
<div class="line">a;</div>
<div class="line"></div>
<div class="line">a.ignoreLabel(0); <span class="comment">//statistics will not be computed for region 0 (e.g. background)</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data, labels, a);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> regionlabel = ...;</div>
<div class="line">std::cout &lt;&lt; get&lt;Mean&gt;(a, regionlabel) &lt;&lt; std::endl; <span class="comment">//get Mean of region with label &#39;regionlabel&#39;</span></div>
</div><!-- fragment --><pre class="fragment">In some application it will be known only at run-time which statistics have to be computed. An Accumulator with &lt;b&gt;run-time activation&lt;/b&gt; is provided by the \ref acc::DynamicAccumulatorChain class. One specifies a set of statistics at compile-time and from this set one can activate the needed statistics at run-time:
</pre><div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::acc;</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, double&gt;</a> data(...);</div>
<div class="line"><a class="code" href="classvigra_1_1acc_1_1DynamicAccumulatorChain.html">DynamicAccumulatorChain</a>&lt;double,</div>
<div class="line">    <a class="code" href="structvigra_1_1acc_1_1Select.html">Select&lt;Mean, Minimum, Maximum, Variance, StdDev&gt;</a> &gt; a; <span class="comment">// at compile-time</span></div>
<div class="line">activate&lt;Mean&gt;(a);      <span class="comment">//at run-time</span></div>
<div class="line">a.activate(<span class="stringliteral">&quot;Minimum&quot;</span>);  <span class="comment">//same as activate&lt;Minimum&gt;(a) (alias names are not recognized)</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin(), data.end(), a);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Mean: &quot;</span> &lt;&lt; get&lt;Mean&gt;(a) &lt;&lt; std::endl;       <span class="comment">//ok</span></div>
<div class="line"><span class="comment">//std::cout &lt;&lt; &quot;Maximum: &quot; &lt;&lt; get&lt;Maximum&gt;(a) &lt;&lt; std::endl; // run-time error because Maximum not activated</span></div>
</div><!-- fragment --><p>Likewise, for run-time activation of region statistics, use <a class="el" href="classvigra_1_1acc_1_1DynamicAccumulatorChainArray.html">acc::DynamicAccumulatorChainArray</a>.</p>
<p><b>Accumulator merging</b> (e.g. for parallelization or hierarchical segmentation) is possible for many accumulators:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::acc;</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, double&gt;</a> data(...);</div>
<div class="line"><a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html">AccumulatorChain&lt;double, Select&lt;Mean, Variance, Skewness&gt;</a> &gt; a, a1, a2;</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin(), data.end(), a); <span class="comment">//process entire data set at once</span></div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin(), data.begin()+data.size()/2, a1); <span class="comment">//process first half</span></div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin()+data.size()/2, data.end(), a2); <span class="comment">//process second half</span></div>
<div class="line">a1 += a2; <span class="comment">// merge: a1 now equals a0 (within numerical tolerances)</span></div>
</div><!-- fragment --><p>Not all statistics can be merged (e.g. Principal usually cannot, except for some important specializations). A statistic can be merged if the "+=" operator is supported (see the documentation of that particular statistic). If the accumulator chain only requires one pass to collect the data, it is also possible to just apply the extractFeatures() function repeatedly:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::acc;</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, double&gt;</a> data(...);</div>
<div class="line"><a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html">AccumulatorChain&lt;double, Select&lt;Mean, Variance&gt;</a> &gt; a;</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin(), data.begin()+data.size()/2, a); <span class="comment">// this works because</span></div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin()+data.size()/2, data.end(), a);   <span class="comment">// all statistics only need pass 1</span></div>
</div><!-- fragment --><p>More care is needed to merge coordinate-based statistics. By default, all coordinate statistics are computed in the local coordinate system of the current region of interest. That is, the upper left corner of the ROI has the coordinate (0, 0) by default. This behavior is not desirable when you want to merge coordinate statistics from different ROIs: then, all accumulators should use the same coordinate system, usually the global system of the entire dataset. This can be achieved by the <code>setCoordinateOffset()</code> function. The following code demonstrates this for the <code>RegionCenter</code> statistic:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra;</div>
<div class="line"><span class="keyword">using namespace </span>vigra::acc;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">MultiArray&lt;2, double&gt;</a> data(width, height);</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">MultiArray&lt;2, int&gt;</a>    labels(width, height);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1acc_1_1AccumulatorChainArray.html">AccumulatorChainArray&lt;CoupledArrays&lt;2, double, int&gt;</a>,</div>
<div class="line">                      <a class="code" href="structvigra_1_1acc_1_1Select.html">Select&lt;DataArg&lt;1&gt;</a>, <a class="code" href="classvigra_1_1acc_1_1LabelArg.html">LabelArg&lt;2&gt;</a>,</div>
<div class="line">                             <a class="code" href="classvigra_1_1acc_1_1Coord.html">RegionCenter</a>&gt; &gt;</div>
<div class="line">a1, a2;</div>
<div class="line"></div>
<div class="line"><span class="comment">// a1 is responsible for the left half of the image. The local coordinate system of this ROI</span></div>
<div class="line"><span class="comment">// happens to be identical to the global coordinate system, so the offset is zero.</span></div>
<div class="line">Shape2 origin(0,0);</div>
<div class="line">a1.setCoordinateOffset(origin);</div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.subarray(origin, Shape2(width/2, height)),</div>
<div class="line">                labels.subarray(origin, Shape2(width/2, height)),</div>
<div class="line">                a1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// a2 is responsible for the right half, so the offset of the local coordinate system is (width/2, 0)</span></div>
<div class="line">origin = Shape2(width/2, 0);</div>
<div class="line">a2.setCoordinateOffset(origin);</div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.subarray(origin, Shape2(width, height)),</div>
<div class="line">                labels.subarray(origin, Shape2(width, height)),</div>
<div class="line">                a2);</div>
<div class="line"></div>
<div class="line"><span class="comment">// since both accumulators worked in the same global coordinate system, we can safely merge them</span></div>
<div class="line">a1.merge(a2);</div>
</div><!-- fragment --><p>When you compute region statistics in ROIs, it is sometimes desirable to use a local region labeling in each ROI. In this way, the labels of each ROI cover a consecutive range of numbers starting with 0. This can save a lot of memory, because <code>AccumulatorChainArray</code> internally uses dense arrays &ndash; accumulators will be allocated for all labels from 0 to the maxmimum label, even when many of them are unused. This is avoided by a local labeling. However, this means that label 1 (say) may refer to two different regions in different ROIs. To adjust for this mismatch, you can pass a label mapping to <code>merge()</code> that provides a global label for each label of the accumulator to be merged. Thus, each region on the right hand side will be merged into the left-hand-side accumulator with the given <em>global</em> label. For example, let us assume that the left and right half of the image contain just one region and background. Then, the accumulators of both ROIs have the label 0 (background) and 1 (the region). Upon merging, the region from the right ROI should be given the global label 2, whereas the background should keep its label 0. This is achieved like this:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; labelMapping(2);</div>
<div class="line">labelMapping[0] = 0;   <span class="comment">// background keeps label 0</span></div>
<div class="line">labelMapping[1] = 2;   <span class="comment">// local region 1 becomes global region 2</span></div>
<div class="line"></div>
<div class="line">a1.merge(a2, labelMapping);</div>
</div><!-- fragment --><p><a class="anchor" id="histogram"></a> Four kinds of <b>histograms</b> are currently implemented:</p>
<table  border="0">
<tr>
<td>IntegerHistogram </td><td>Data values are equal to bin indices  </td></tr>
<tr>
<td>UserRangeHistogram </td><td>User provides lower and upper bounds for linear range mapping from values to indices.  </td></tr>
<tr>
<td>AutoRangeHistogram </td><td>Range mapping bounds are defiend by minimum and maximum of the data (2 passes needed!)  </td></tr>
<tr>
<td>GlobalRangeHistogram &#160; </td><td>Likewise, but use global min/max rather than region min/max as AutoRangeHistogram will  </td></tr>
</table>
<pre class="fragment">- The number of bins is specified at compile time (as template parameter int BinCount) or at run-time (if BinCount is zero at compile time). In the first case the return type of the accumulator is TinyVector&lt;double, BinCount&gt; (number of bins cannot be changed). In the second case, the return type is MultiArray&lt;1, double&gt; and the number of bins must be set before seeing data (see example below).
- If UserRangeHistogram is used, the bounds for the linear range mapping from values to indices must be set before seeing data (see below).
- Options can be set by passing an instance of HistogramOptions to the accumulator chain (same options for all histograms in the chain) or by directly calling the appropriate member functions of the accumulators.
- Merging is supported if the range mapping of the histograms is the same.
- Histogram accumulators have two members for outliers (left_outliers, right_outliers).

With the StandardQuantiles class, &lt;b&gt;histogram quantiles&lt;/b&gt; (0%, 10%, 25%, 50%, 75%, 90%, 100%) are computed from a given histgram using linear interpolation. The return type is TinyVector&lt;double, 7&gt; .
</pre><p><a class="anchor" id="acc_hist_options"></a>Usage: </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::acc;</div>
<div class="line"><span class="keyword">typedef</span> <span class="keywordtype">double</span> DataType;</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;2, DataType&gt;</a> data(...);</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1UserRangeHistogram.html">UserRangeHistogram&lt;40&gt;</a> SomeHistogram;   <span class="comment">//binCount set at compile time</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1UserRangeHistogram.html">UserRangeHistogram&lt;0&gt;</a> SomeHistogram2; <span class="comment">// binCount must be set at run-time</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1AutoRangeHistogram.html">AutoRangeHistogram&lt;0&gt;</a> SomeHistogram3;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classvigra_1_1acc_1_1StandardQuantiles.html">StandardQuantiles&lt;SomeHistogram3&gt;</a> Quantiles3;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1acc_1_1AccumulatorChain.html">AccumulatorChain&lt;DataType, Select&lt;SomeHistogram, SomeHistogram2, SomeHistogram3, Quantiles3&gt;</a> &gt; a;</div>
<div class="line"></div>
<div class="line"><span class="comment">//set options for all histograms in the accumulator chain:</span></div>
<div class="line"><a class="code" href="classvigra_1_1HistogramOptions.html">vigra::HistogramOptions</a> histogram_opt;</div>
<div class="line">histogram_opt = histogram_opt.<a class="code" href="classvigra_1_1HistogramOptions.html#adbbd8c327b126c15338d3f37709faa6e">setBinCount</a>(50);</div>
<div class="line"><span class="comment">//histogram_opt = histogram_opt.setMinMax(0.1, 0.9); // this would set min/max for all three histograms, but range bounds</span></div>
<div class="line">                                                     <span class="comment">// shall be set automatically by min/max of data for SomeHistogram3</span></div>
<div class="line">a.setHistogramOptions(histogram_opt);</div>
<div class="line"></div>
<div class="line"><span class="comment">// set options for a specific histogram in the accumulator chain:</span></div>
<div class="line">getAccumulator&lt;SomeHistogram&gt;(a).setMinMax(0.1, 0.9); <span class="comment">// number of bins must be set before setting min/max</span></div>
<div class="line">getAccumulator&lt;SomeHistogram2&gt;(a).setMinMax(0.0, 1.0);</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(data.begin(), data.end(), a);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1TinyVector.html">vigra::TinyVector&lt;double, 40&gt;</a> hist = get&lt;SomeHistogram&gt;(a);</div>
<div class="line"><a class="code" href="classvigra_1_1MultiArray.html">vigra::MultiArray&lt;1, double&gt;</a> hist2 = get&lt;SomeHistogram2&gt;(a);</div>
<div class="line"><a class="code" href="classvigra_1_1TinyVector.html">vigra::TinyVector&lt;double, 7&gt;</a> quant = get&lt;Quantiles3&gt;(a);</div>
<div class="line"><span class="keywordtype">double</span> right_outliers = getAccumulator&lt;SomeHistogram&gt;(a).right_outliers;</div>
</div><!-- fragment --> </div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.0 (Thu Mar 17 2016)
</i>
</tr>
</table>
</BODY>
</HTML>
