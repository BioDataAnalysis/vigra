<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Convolution Filters</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
<script>
var runOnLoad=function(c,o,d,e){function x(){for(e=1;c.length;)c.shift()()}o[d]?(document[d]('DOMContentLoaded',x,0),o[d]('load',x,0)):o.attachEvent('onload',x);return function(t){e?o.setTimeout(t,0):c.push(t)}}([],window,'addEventListener');
</script>
<script type="text/javascript" src="documents/CollapsibleLists.js"></script>
<script type="text/javascript">
    runOnLoad(function(){ CollapsibleLists.apply(); });
</script>
<style type="text/css">
.collapsibleList li.collapsibleListOpen{
  list-style-image:url('documents/pfeil.gif');
  cursor:pointer;
}
.collapsibleList li.collapsibleListClosed{
  list-style-image:url('documents/bullet.gif');
  cursor:pointer;
}
.collapsibleList li.lastItem{
  list-style-image:url('documents/diamond.gif');
}
</style>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://ukoethe.github.io/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Convolution Filters
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__ParallelProcessing"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelProcessing.html">Parallel Processing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf819a613a16ee9807d69ecb2d91b2ae"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gaaf819a613a16ee9807d69ecb2d91b2ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT</a> (...)</td></tr>
<tr class="memdesc:gaaf819a613a16ee9807d69ecb2d91b2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve an array with a kernel by means of the Fourier transform.  <a href="#gaaf819a613a16ee9807d69ecb2d91b2ae">More...</a><br/></td></tr>
<tr class="separator:gaaf819a613a16ee9807d69ecb2d91b2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014b4e7d6d5154d5ad83170c6cb547f6"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga014b4e7d6d5154d5ad83170c6cb547f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga014b4e7d6d5154d5ad83170c6cb547f6">convolveFFTComplex</a> (...)</td></tr>
<tr class="memdesc:ga014b4e7d6d5154d5ad83170c6cb547f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a complex-valued array by means of the Fourier transform.  <a href="#ga014b4e7d6d5154d5ad83170c6cb547f6">More...</a><br/></td></tr>
<tr class="separator:ga014b4e7d6d5154d5ad83170c6cb547f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf555ec81ad059261e2bb8b5d03a0aa83"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gaf555ec81ad059261e2bb8b5d03a0aa83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#gaf555ec81ad059261e2bb8b5d03a0aa83">convolveFFTComplexMany</a> (...)</td></tr>
<tr class="memdesc:gaf555ec81ad059261e2bb8b5d03a0aa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a complex-valued array with a sequence of kernels by means of the Fourier transform.  <a href="#gaf555ec81ad059261e2bb8b5d03a0aa83">More...</a><br/></td></tr>
<tr class="separator:gaf555ec81ad059261e2bb8b5d03a0aa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2598869b328eae9ff709387e0b758a0"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gae2598869b328eae9ff709387e0b758a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#gae2598869b328eae9ff709387e0b758a0">convolveFFTMany</a> (...)</td></tr>
<tr class="memdesc:gae2598869b328eae9ff709387e0b758a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a real-valued array with a sequence of kernels by means of the Fourier transform.  <a href="#gae2598869b328eae9ff709387e0b758a0">More...</a><br/></td></tr>
<tr class="separator:gae2598869b328eae9ff709387e0b758a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90659f4fa8421e82e3082f65e1ca23c2"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga90659f4fa8421e82e3082f65e1ca23c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a> (...)</td></tr>
<tr class="memdesc:ga90659f4fa8421e82e3082f65e1ca23c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve an image with the given kernel(s).  <a href="#ga90659f4fa8421e82e3082f65e1ca23c2">More...</a><br/></td></tr>
<tr class="separator:ga90659f4fa8421e82e3082f65e1ca23c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1698618c44d0d5d5e0559212519b562"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gaa1698618c44d0d5d5e0559212519b562"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#gaa1698618c44d0d5d5e0559212519b562">convolveImageWithMask</a> (...)</td></tr>
<tr class="memdesc:gaa1698618c44d0d5d5e0559212519b562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated name of 2-dimensional normalized convolution, i.e. convolution with a mask image.  <a href="#gaa1698618c44d0d5d5e0559212519b562">More...</a><br/></td></tr>
<tr class="separator:gaa1698618c44d0d5d5e0559212519b562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac82f89797cb83810e5a9ebddac36259b"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gac82f89797cb83810e5a9ebddac36259b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a> (...)</td></tr>
<tr class="memdesc:gac82f89797cb83810e5a9ebddac36259b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution along a single dimension of a multi-dimensional arrays.  <a href="#gac82f89797cb83810e5a9ebddac36259b">More...</a><br/></td></tr>
<tr class="separator:gac82f89797cb83810e5a9ebddac36259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b019af5eba5f0654edde1fe6a0e2c2b"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga3b019af5eba5f0654edde1fe6a0e2c2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga3b019af5eba5f0654edde1fe6a0e2c2b">correlateFFT</a> (...)</td></tr>
<tr class="memdesc:ga3b019af5eba5f0654edde1fe6a0e2c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlate an array with a kernel by means of the Fourier transform.  <a href="#ga3b019af5eba5f0654edde1fe6a0e2c2b">More...</a><br/></td></tr>
<tr class="separator:ga3b019af5eba5f0654edde1fe6a0e2c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e603a8303c5af14dd8e709a63141fe"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga63e603a8303c5af14dd8e709a63141fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a> (...)</td></tr>
<tr class="memdesc:ga63e603a8303c5af14dd8e709a63141fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the divergence of a vector field using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters.  <a href="#ga63e603a8303c5af14dd8e709a63141fe">More...</a><br/></td></tr>
<tr class="separator:ga63e603a8303c5af14dd8e709a63141fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eedd3703e4ab90a2f8926a453fe6a8f"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga1eedd3703e4ab90a2f8926a453fe6a8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga1eedd3703e4ab90a2f8926a453fe6a8f">gaussianGradient</a> (...)</td></tr>
<tr class="memdesc:ga1eedd3703e4ab90a2f8926a453fe6a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the gradient vector by means of a 1st derivatives of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter.  <a href="#ga1eedd3703e4ab90a2f8926a453fe6a8f">More...</a><br/></td></tr>
<tr class="separator:ga1eedd3703e4ab90a2f8926a453fe6a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab80e356fa487f97d718ed815a3cf4855"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gab80e356fa487f97d718ed815a3cf4855"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a> (...)</td></tr>
<tr class="memdesc:gab80e356fa487f97d718ed815a3cf4855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the gradient magnitude by means of a 1st derivatives of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter.  <a href="#gab80e356fa487f97d718ed815a3cf4855">More...</a><br/></td></tr>
<tr class="separator:gab80e356fa487f97d718ed815a3cf4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d5e9021732f13248ca3a0fe1b7c0552"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga4d5e9021732f13248ca3a0fe1b7c0552"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a> (...)</td></tr>
<tr class="memdesc:ga4d5e9021732f13248ca3a0fe1b7c0552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of a multi-dimensional arrays.  <a href="#ga4d5e9021732f13248ca3a0fe1b7c0552">More...</a><br/></td></tr>
<tr class="separator:ga4d5e9021732f13248ca3a0fe1b7c0552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca082340d8a747dd9784e2b896db9a30"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gaca082340d8a747dd9784e2b896db9a30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#gaca082340d8a747dd9784e2b896db9a30">gaussianSharpening</a> (...)</td></tr>
<tr class="memdesc:gaca082340d8a747dd9784e2b896db9a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sharpening function with gaussian filter.  <a href="#gaca082340d8a747dd9784e2b896db9a30">More...</a><br/></td></tr>
<tr class="separator:gaca082340d8a747dd9784e2b896db9a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga187dd5c94b6113dbd3578001fee70113"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga187dd5c94b6113dbd3578001fee70113"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113">gaussianSmoothing</a> (...)</td></tr>
<tr class="memdesc:ga187dd5c94b6113dbd3578001fee70113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform isotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> convolution.  <a href="#ga187dd5c94b6113dbd3578001fee70113">More...</a><br/></td></tr>
<tr class="separator:ga187dd5c94b6113dbd3578001fee70113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d81ef630205d44b8517c464217207d"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga11d81ef630205d44b8517c464217207d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a> (...)</td></tr>
<tr class="memdesc:ga11d81ef630205d44b8517c464217207d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Isotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing of a multi-dimensional arrays.  <a href="#ga11d81ef630205d44b8517c464217207d">More...</a><br/></td></tr>
<tr class="separator:ga11d81ef630205d44b8517c464217207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2a320ba52c347f03c02ef173e346cd"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gada2a320ba52c347f03c02ef173e346cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#gada2a320ba52c347f03c02ef173e346cd">hessianMatrixOfGaussian</a> (...)</td></tr>
<tr class="memdesc:gada2a320ba52c347f03c02ef173e346cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter image with the 2nd derivatives of the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> at the given scale to get the Hessian matrix.  <a href="#gada2a320ba52c347f03c02ef173e346cd">More...</a><br/></td></tr>
<tr class="separator:gada2a320ba52c347f03c02ef173e346cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae419814e55fb3191a87e7b75f505d4da"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gae419814e55fb3191a87e7b75f505d4da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a> (...)</td></tr>
<tr class="memdesc:gae419814e55fb3191a87e7b75f505d4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Hessian matrix of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters.  <a href="#gae419814e55fb3191a87e7b75f505d4da">More...</a><br/></td></tr>
<tr class="separator:gae419814e55fb3191a87e7b75f505d4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf286ebb8c18843d9989f624b187ec30"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gabf286ebb8c18843d9989f624b187ec30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#gabf286ebb8c18843d9989f624b187ec30">laplacianOfGaussian</a> (...)</td></tr>
<tr class="memdesc:gabf286ebb8c18843d9989f624b187ec30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter image with the Laplacian of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> operator at the given scale.  <a href="#gabf286ebb8c18843d9989f624b187ec30">More...</a><br/></td></tr>
<tr class="separator:gabf286ebb8c18843d9989f624b187ec30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac165234c3bca25d3162cac15ceb2b970"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gac165234c3bca25d3162cac15ceb2b970"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a> (...)</td></tr>
<tr class="memdesc:gac165234c3bca25d3162cac15ceb2b970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Laplacian of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters.  <a href="#gac165234c3bca25d3162cac15ceb2b970">More...</a><br/></td></tr>
<tr class="separator:gac165234c3bca25d3162cac15ceb2b970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69ac94967f6044203ebb85d84cc51b84"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga69ac94967f6044203ebb85d84cc51b84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga69ac94967f6044203ebb85d84cc51b84">normalizedConvolveImage</a> (...)</td></tr>
<tr class="memdesc:ga69ac94967f6044203ebb85d84cc51b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a 2-dimensional normalized convolution, i.e. convolution with a mask image.  <a href="#ga69ac94967f6044203ebb85d84cc51b84">More...</a><br/></td></tr>
<tr class="separator:ga69ac94967f6044203ebb85d84cc51b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1725cf1cffa836093e343d85ed6cc684"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga1725cf1cffa836093e343d85ed6cc684"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga1725cf1cffa836093e343d85ed6cc684">rieszTransformOfLOG</a> (...)</td></tr>
<tr class="memdesc:ga1725cf1cffa836093e343d85ed6cc684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Riesz transforms of the Laplacian of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a>.  <a href="#ga1725cf1cffa836093e343d85ed6cc684">More...</a><br/></td></tr>
<tr class="separator:ga1725cf1cffa836093e343d85ed6cc684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c43f1c6fd2f6391c7a26de88545b8db"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga1c43f1c6fd2f6391c7a26de88545b8db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a> (...)</td></tr>
<tr class="memdesc:ga1c43f1c6fd2f6391c7a26de88545b8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separated convolution on multi-dimensional arrays.  <a href="#ga1c43f1c6fd2f6391c7a26de88545b8db">More...</a><br/></td></tr>
<tr class="separator:ga1c43f1c6fd2f6391c7a26de88545b8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga036bfcbd28303db0c41d32d292af3bb3"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga036bfcbd28303db0c41d32d292af3bb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga036bfcbd28303db0c41d32d292af3bb3">simpleSharpening</a> (...)</td></tr>
<tr class="memdesc:ga036bfcbd28303db0c41d32d292af3bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform simple sharpening function.  <a href="#ga036bfcbd28303db0c41d32d292af3bb3">More...</a><br/></td></tr>
<tr class="separator:ga036bfcbd28303db0c41d32d292af3bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa5263dd0a2d0d152e67e7bb31f1d66"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga1fa5263dd0a2d0d152e67e7bb31f1d66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga1fa5263dd0a2d0d152e67e7bb31f1d66">structureTensor</a> (...)</td></tr>
<tr class="memdesc:ga1fa5263dd0a2d0d152e67e7bb31f1d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Structure Tensor for each pixel of and image, using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> (derivative) filters.  <a href="#ga1fa5263dd0a2d0d152e67e7bb31f1d66">More...</a><br/></td></tr>
<tr class="separator:ga1fa5263dd0a2d0d152e67e7bb31f1d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6be0fb8e178b6b589e2441cc4ae0f54d"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga6be0fb8e178b6b589e2441cc4ae0f54d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a> (...)</td></tr>
<tr class="memdesc:ga6be0fb8e178b6b589e2441cc4ae0f54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the structure tensor of a multi-dimensional arrays.  <a href="#ga6be0fb8e178b6b589e2441cc4ae0f54d">More...</a><br/></td></tr>
<tr class="separator:ga6be0fb8e178b6b589e2441cc4ae0f54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99cfc937dc06355aaf71b551a7c31faa"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga99cfc937dc06355aaf71b551a7c31faa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a> (...)</td></tr>
<tr class="memdesc:ga99cfc937dc06355aaf71b551a7c31faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate gradient of a multi-dimensional arrays using symmetric difference filters.  <a href="#ga99cfc937dc06355aaf71b551a7c31faa">More...</a><br/></td></tr>
<tr class="separator:ga99cfc937dc06355aaf71b551a7c31faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<p>The functions in this group implement separable convolutions (e.g. smoothing and sharpening, <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivatives) and related filters (like the gradient magnitude) on arbitrary-dimensional arrays. In addition, non-separable filters are supported for 2D images. All functions accept the <a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a> API (which can be wrapped around a wide variety of data structures) as well as a number of deprecated APIs such as <a class="el" href="group__ImageIterators.html">Image Iterators</a>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1725cf1cffa836093e343d85ed6cc684"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::rieszTransformOfLOG </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate Riesz transforms of the Laplacian of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a>. </p>
<p>The Riesz transforms of the Laplacian of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> have the following transfer functions (defined in a polar coordinate representation of the frequency domain):</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ F_{\sigma}(r, \phi)=(i \cos \phi)^n (i \sin \phi)^m r^2 e^{-r^2 \sigma^2 / 2} \]" src="form_4.png"/>
</p>
<p>where <em>n</em> = <code>xorder</code> and <em>m</em> = <code>yorder</code> determine th e order of the transform, and <code>sigma &gt; 0</code> is the scale of the Laplacian of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a>. This function computes a good spatial domain approximation of these transforms for <code>xorder + yorder &lt;= 2</code>. The filter responses may be used to calculate the monogenic signal or the boundary tensor.</p>
<p><b> Declarations:</b></p>
<p>pass 2D array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1725cf1cffa836093e343d85ed6cc684">rieszTransformOfLOG</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                        MultiArrayView&lt;2, T2, S2&gt; dest,</div>
<div class="line">                        <span class="keywordtype">double</span> scale, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xorder, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yorder);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="rieszTransformOfLOG_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;rieszTransformOfLOG_OldAPI&apos;, &apos;rieszTransformOfLOG_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="rieszTransformOfLOG_OldAPI" style="display:none"> pass <a class="el" href="group__ImageIterators.html">Image Iterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">            <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga1725cf1cffa836093e343d85ed6cc684">rieszTransformOfLOG</a>(SrcIterator supperleft, SrcIterator slowerright, SrcAccessor src,</div>
<div class="line">                             DestIterator dupperleft, DestAccessor dest,</div>
<div class="line">                             <span class="keywordtype">double</span> scale, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xorder, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yorder);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">            <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga1725cf1cffa836093e343d85ed6cc684">rieszTransformOfLOG</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                             pair&lt;DestIterator, DestAccessor&gt; dest,</div>
<div class="line">                             <span class="keywordtype">double</span> scale, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xorder, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yorder);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="boundarytensor_8hxx_source.html">vigra/boundarytensor.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArrayView&lt;2, double&gt; impulse(17,17), res(17, 17);</div>
<div class="line">impulse(8,8) = 1.0;</div>
<div class="line"></div>
<div class="line"><span class="comment">// calculate the impulse response of the first order Riesz transform in x-direction</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga1725cf1cffa836093e343d85ed6cc684">rieszTransformOfLOG</a>(impulse, res, 2.0, 1, 0);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga90659f4fa8421e82e3082f65e1ca23c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convolveImage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve an image with the given kernel(s). </p>
<p>If you pass <a class="el" href="classvigra_1_1Kernel2D.html">vigra::Kernel2D</a> to this function, it will perform an explicit 2-dimensional convolution. If you pass a single <a class="el" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D</a>, it performs a separable convolution, i.e. it concatenates two 1D convolutions (along the x-axis and along the y-axis) with the same kernel via internal calls to <a class="el" href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848">separableConvolveX()</a> and <a class="el" href="group__SeparableConvolution.html#gaee4f7ee32121e37112a20f5fb8ad4610">separableConvolveY()</a>. If two 1D kernels are specified, separable convolution uses different kernels for the x- and y-axis.</p>
<p>All <a class="el" href="BorderTreatmentMode.html">border treatment modes</a> are supported.</p>
<p>The input pixel type <code>T1</code> must be a <a class="el" href="AlgebraicConcepts.html#LinearSpace">linear space</a> over the kernel's value_type <code>T</code>, i.e. addition of source values, multiplication with kernel values, and NumericTraits must be defined. The kernel's value_type must be an <a class="el" href="AlgebraicConcepts.html#AlgebraicField">algebraic field</a>, i.e. the arithmetic operations (+, -, *, /) and NumericTraits must be defined. Typically, you will use <code>double</code> for the kernel type.</p>
<p><b> Declarations:</b></p>
<p>pass 2D array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// use the same 1D kernel for all axes</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,</div>
<div class="line">              <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                  MultiArrayView&lt;2, T2, S2&gt; dest,</div>
<div class="line">                  Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; k);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// use a different kernel for each axis</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,</div>
<div class="line">              <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                  MultiArrayView&lt;2, T2, S2&gt; dest,</div>
<div class="line">                  Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kx, Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; ky);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// use a non-separable 2D kernel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,</div>
<div class="line">              <span class="keyword">class </span>T3&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                  MultiArrayView&lt;2, T2, S2&gt; dest,</div>
<div class="line">                  Kernel2D&lt;T3&gt; <span class="keyword">const</span> &amp; kernel);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="convolveImage_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;convolveImage_OldAPI&apos;, &apos;convolveImage_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="convolveImage_OldAPI" style="display:none"> pass <a class="el" href="group__ImageIterators.html">Image Iterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// use a different kernel for each axis</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,</div>
<div class="line">              <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(SrcIterator supperleft,</div>
<div class="line">                       SrcIterator slowerright, SrcAccessor sa,</div>
<div class="line">                       DestIterator dupperleft, DestAccessor da,</div>
<div class="line">                       Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kx, Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; ky);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// use a non-separable 2D kernel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,</div>
<div class="line">              <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(SrcIterator src_ul, SrcIterator src_lr, SrcAccessor src_acc,</div>
<div class="line">                       DestIterator dest_ul, DestAccessor dest_acc,</div>
<div class="line">                       KernelIterator ki, KernelAccessor ak,</div>
<div class="line">                       Diff2D kul, Diff2D klr, BorderTreatmentMode border);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// use a different kernel for each axis</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,</div>
<div class="line">              <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                  pair&lt;DestIterator, DestAccessor&gt; dest,</div>
<div class="line">                  Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kx, Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; ky);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// use a non-separable 2D kernel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,</div>
<div class="line">              <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                       pair&lt;DestIterator, DestAccessor&gt; dest,</div>
<div class="line">                       tuple5&lt;KernelIterator, KernelAccessor, Diff2D, Diff2D,</div>
<div class="line">                       BorderTreatmentMode&gt; kernel);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="convolution_8hxx_source.html">vigra/convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArray&lt;2, float&gt; src(w,h), dest1(w,h), dest2(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// create horizontal sobel filter (symmetric difference in x-direction, smoothing in y direction)</span></div>
<div class="line">Kernel1D&lt;<span class="keywordtype">double</span>&gt; kx, ky;</div>
<div class="line">kx.initSymmetricDifference();</div>
<div class="line">ky.initBinomial(1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// calls separable convolution with the two 1D kernels</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(src, dest1, kx, ky);</div>
<div class="line"></div>
<div class="line"><span class="comment">// create a 3x3 Laplacian filter</span></div>
<div class="line">Kernel2D&lt;double&gt; laplace;</div>
<div class="line">laplace.initExplicitly(Diff2D(-1,-1), Diff2D(1,1)) =</div>
<div class="line">        0.375,  0.25, 0.375,</div>
<div class="line">        0.25,  -2.5,  0.25,</div>
<div class="line">        0.375,  0.25, 0.375;</div>
<div class="line"></div>
<div class="line"><span class="comment">// calls 2D convolution</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage</a>(src, dest2, laplace);</div>
</div><!-- fragment --><p><a href="#" id="convolveImage_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;convolveImage_OldUsage&apos;, &apos;convolveImage_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="convolveImage_OldUsage" style="display:none"> <div class="fragment"><div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h), dest(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// create horizontal sobel filter (symmetric difference in x-direction, smoothing in y direction)</span></div>
<div class="line">Kernel1D&lt;<span class="keywordtype">double</span>&gt; kx, ky;</div>
<div class="line">kx.initSymmetricDifference();</div>
<div class="line">ky.initBinomial(1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// calls separable convolution with the two 1D kernels</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">vigra::convolveImage</a>(srcImageRange(src), destImage(dest), kx, ky);</div>
<div class="line"></div>
<div class="line"><span class="comment">// create a 3x3 Laplacian filter</span></div>
<div class="line">Kernel2D&lt;double&gt; laplace;</div>
<div class="line">laplace.initExplicitly(Diff2D(-1,-1), Diff2D(1,1)) =</div>
<div class="line">        0.375,  0.25, 0.375,</div>
<div class="line">        0.25,  -2.5,  0.25,</div>
<div class="line">        0.375,  0.25, 0.375;</div>
<div class="line"></div>
<div class="line"><span class="comment">// calls 2D convolution</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">vigra::convolveImage</a>(srcImageRange(src), destImage(dest), kernel2d(laplace));</div>
</div><!-- fragment --> </div><p><b> Preconditions:</b></p>
<p>The image must be larger than the kernel radius. </p>
<ul>
<li>
For 1D kernels, <code>w &gt; std::max(xkernel.right(), -xkernel.keft())</code> and <code>h &gt; std::max(ykernel.right(), -ykernel.left())</code> are required. </li>
<li>
For 2D kernels, <code>w &gt; std::max(kernel.lowerRight().x, -kernel.upperLeft().x)</code> and <code>h &gt; std::max(kernel.lowerRight().y, -kernel.upperLeft().y)</code> are required. </li>
</ul>
<p>If <code>BORDER_TREATMENT_CLIP</code> is requested: the sum of kernel elements must be != 0. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="smooth_convolve_8cxx-example.html#a13">smooth_convolve.cxx</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga036bfcbd28303db0c41d32d292af3bb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::simpleSharpening </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform simple sharpening function. </p>
<p>This function uses <a class="el" href="group__ConvolutionFilters.html#ga90659f4fa8421e82e3082f65e1ca23c2">convolveImage()</a> with the following 3x3 filter:</p>
<div class="fragment"><div class="line">-sharpening_factor/16.0,    -sharpening_factor/8.0,    -sharpening_factor/16.0,</div>
<div class="line">-sharpening_factor/8.0,   1.0+sharpening_factor*0.75,  -sharpening_factor/8.0,</div>
<div class="line">-sharpening_factor/16.0,    -sharpening_factor/8.0,    -sharpening_factor/16.0;</div>
</div><!-- fragment --><p>and uses <code>BORDER_TREATMENT_REFLECT</code> as border treatment mode.</p>
<p><b> Preconditions:</b> </p>
<div class="fragment"><div class="line">1. sharpening_factor &gt;= 0</div>
<div class="line">2. scale &gt;= 0</div>
</div><!-- fragment --><p><b> Declarations:</b></p>
<p>pass 2D array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga036bfcbd28303db0c41d32d292af3bb3">simpleSharpening</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                     MultiArrayView&lt;2, T2, S2&gt; dest,</div>
<div class="line">                     <span class="keywordtype">double</span> sharpening_factor);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="simpleSharpening_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;simpleSharpening_OldAPI&apos;, &apos;simpleSharpening_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="simpleSharpening_OldAPI" style="display:none"> pass <a class="el" href="group__ImageIterators.html">Image Iterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga036bfcbd28303db0c41d32d292af3bb3">simpleSharpening</a>(SrcIterator src_ul, SrcIterator src_lr, SrcAccessor src_acc,</div>
<div class="line">                          DestIterator dest_ul, DestAccessor dest_acc, <span class="keywordtype">double</span> sharpening_factor);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga036bfcbd28303db0c41d32d292af3bb3">simpleSharpening</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                          pair&lt;DestIterator, DestAccessor&gt; dest, <span class="keywordtype">double</span> sharpening_factor);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="convolution_8hxx_source.html">vigra/convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArray&lt;2, float&gt; src(w,h), dest(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// sharpening with sharpening_factor = 0.1</span></div>
<div class="line">vigra::simpleSharpening(src, dest, 0.1);</div>
</div><!-- fragment --><p><a href="#" id="simpleSharpening_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;simpleSharpening_OldUsage&apos;, &apos;simpleSharpening_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="simpleSharpening_OldUsage" style="display:none"> <div class="fragment"><div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h), dest(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// sharpening with sharpening_factor = 0.1</span></div>
<div class="line">vigra::simpleSharpening(srcImageRange(src), destImage(dest), 0.1);</div>
</div><!-- fragment --> </div> 
</div>
</div>
<a class="anchor" id="gaca082340d8a747dd9784e2b896db9a30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::gaussianSharpening </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform sharpening function with gaussian filter. </p>
<p>This function uses <a class="el" href="group__ConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113">gaussianSmoothing()</a> at the given scale to create a temporary image 'smooth' and than blends the original and smoothed image according to the formula</p>
<div class="fragment"><div class="line">dest = (1 + sharpening_factor)*src - sharpening_factor*smooth</div>
</div><!-- fragment --><p><b> Preconditions:</b> </p>
<div class="fragment"><div class="line">1. sharpening_factor &gt;= 0</div>
<div class="line">2. scale &gt;= 0</div>
</div><!-- fragment --><p><b> Declarations:</b></p>
<p>pass 2D array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gaca082340d8a747dd9784e2b896db9a30">gaussianSharpening</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                       MultiArrayView&lt;2, T2, S2&gt; dest,</div>
<div class="line">                       <span class="keywordtype">double</span> sharpening_factor,</div>
<div class="line">                       <span class="keywordtype">double</span> scale);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="gaussianSharpening_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianSharpening_OldAPI&apos;, &apos;gaussianSharpening_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="gaussianSharpening_OldAPI" style="display:none"> pass <a class="el" href="group__ImageIterators.html">Image Iterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">            <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#gaca082340d8a747dd9784e2b896db9a30">gaussianSharpening</a>(SrcIterator src_ul, SrcIterator src_lr, SrcAccessor src_acc,</div>
<div class="line">                          DestIterator dest_ul, DestAccessor dest_acc,</div>
<div class="line">                          <span class="keywordtype">double</span> sharpening_factor, <span class="keywordtype">double</span> scale)</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">            <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#gaca082340d8a747dd9784e2b896db9a30">gaussianSharpening</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                           pair&lt;DestIterator, DestAccessor&gt; dest,</div>
<div class="line">                           <span class="keywordtype">double</span> sharpening_factor, <span class="keywordtype">double</span> scale)</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="convolution_8hxx_source.html">vigra/convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArray&lt;2, float&gt; src(w,h), dest(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// sharpening with sharpening_factor = 3.0</span></div>
<div class="line"><span class="comment">// smoothing with scale = 0.5</span></div>
<div class="line">gaussianSharpening(src, dest, 3.0, 0.5);</div>
</div><!-- fragment --><p><a href="#" id="gaussianSharpening_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianSharpening_OldUsage&apos;, &apos;gaussianSharpening_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="gaussianSharpening_OldUsage" style="display:none"> <div class="fragment"><div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h), dest(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// sharpening with sharpening_factor = 3.0</span></div>
<div class="line"><span class="comment">// smoothing with scale = 0.5</span></div>
<div class="line">vigra::gaussianSharpening(srcImageRange(src), destImage(dest), 3.0, 0.5);</div>
</div><!-- fragment --> </div> 
</div>
</div>
<a class="anchor" id="ga187dd5c94b6113dbd3578001fee70113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::gaussianSmoothing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform isotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> convolution. </p>
<p>This function is a shorthand for the concatenation of a call to <a class="el" href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848">separableConvolveX()</a> and <a class="el" href="group__SeparableConvolution.html#gaee4f7ee32121e37112a20f5fb8ad4610">separableConvolveY()</a> with a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> kernel of the given scale. If two scales are provided, smoothing in x and y direction will have different strength. The function uses <code>BORDER_TREATMENT_REFLECT</code>.</p>
<p>Function <a class="el" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray()</a> performs the same filter operation on arbitrary dimensional arrays.</p>
<p><b> Declarations:</b></p>
<p>pass 2D array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113">gaussianSmoothing</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                      MultiArrayView&lt;2, T2, S2&gt; dest,</div>
<div class="line">                      <span class="keywordtype">double</span> scale_x, <span class="keywordtype">double</span> scale_y = scale_x);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="gaussianSmoothing_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianSmoothing_OldAPI&apos;, &apos;gaussianSmoothing_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="gaussianSmoothing_OldAPI" style="display:none"> pass <a class="el" href="group__ImageIterators.html">Image Iterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113">gaussianSmoothing</a>(SrcIterator supperleft,</div>
<div class="line">                            SrcIterator slowerright, SrcAccessor sa,</div>
<div class="line">                            DestIterator dupperleft, DestAccessor da,</div>
<div class="line">                            <span class="keywordtype">double</span> scale_x, <span class="keywordtype">double</span> scale_y = scale_x);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga187dd5c94b6113dbd3578001fee70113">gaussianSmoothing</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                      pair&lt;DestIterator, DestAccessor&gt; dest,</div>
<div class="line">                      <span class="keywordtype">double</span> scale_x, <span class="keywordtype">double</span> scale_y = scale_x);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="convolution_8hxx_source.html">vigra/convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArray&lt;2, float&gt; src(w,h), dest(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// smooth with scale = 3.0</span></div>
<div class="line">gaussianSmoothing(src, dest, 3.0);</div>
</div><!-- fragment --><p><a href="#" id="gaussianSmoothing_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianSmoothing_OldUsage&apos;, &apos;gaussianSmoothing_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="gaussianSmoothing_OldUsage" style="display:none"> <div class="fragment"><div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h), dest(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// smooth with scale = 3.0</span></div>
<div class="line">vigra::gaussianSmoothing(srcImageRange(src), destImage(dest), 3.0);</div>
</div><!-- fragment --> </div> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="smooth_8cxx-example.html#a11">smooth.cxx</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga1eedd3703e4ab90a2f8926a453fe6a8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::gaussianGradient </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the gradient vector by means of a 1st derivatives of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter. </p>
<p>This function is a shorthand for the concatenation of a call to <a class="el" href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848">separableConvolveX()</a> and <a class="el" href="group__SeparableConvolution.html#gaee4f7ee32121e37112a20f5fb8ad4610">separableConvolveY()</a> with the appropriate kernels at the given scale. Note that this function can either produce two separate result images for the x- and y-components of the gradient, or write into a vector valued image (with at least two components).</p>
<p>Function <a class="el" href="group__ConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray()</a> performs the same filter operation on arbitrary dimensional arrays.</p>
<p><b> Declarations:</b></p>
<p>pass 2D array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// write x and y component of the gradient into separate images</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2X, <span class="keyword">class </span>S2X,</div>
<div class="line">              <span class="keyword">class </span>T2Y, <span class="keyword">class </span>S2Y&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1eedd3703e4ab90a2f8926a453fe6a8f">gaussianGradient</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                     MultiArrayView&lt;2, T2X, S2X&gt; destx,</div>
<div class="line">                     MultiArrayView&lt;2, T2Y, S2Y&gt; desty,</div>
<div class="line">                     <span class="keywordtype">double</span> scale);</div>
<div class="line"></div>
<div class="line">   <span class="comment">// write x and y component of the gradient into a vector-valued image</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1eedd3703e4ab90a2f8926a453fe6a8f">gaussianGradient</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                     MultiArrayView&lt;2, TinyVector&lt;T2, 2&gt;, S2&gt; dest,</div>
<div class="line">                     <span class="keywordtype">double</span> scale);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="gaussianGradient_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianGradient_OldAPI&apos;, &apos;gaussianGradient_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="gaussianGradient_OldAPI" style="display:none"> pass <a class="el" href="group__ImageIterators.html">Image Iterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// write x and y component of the gradient into separate images</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorX, <span class="keyword">class </span>DestAccessorX,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorY, <span class="keyword">class </span>DestAccessorY&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga1eedd3703e4ab90a2f8926a453fe6a8f">gaussianGradient</a>(SrcIterator supperleft,</div>
<div class="line">                          SrcIterator slowerright, SrcAccessor sa,</div>
<div class="line">                          DestIteratorX dupperleftx, DestAccessorX dax,</div>
<div class="line">                          DestIteratorY dupperlefty, DestAccessorY day,</div>
<div class="line">                          <span class="keywordtype">double</span> scale);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// write x and y component of the gradient into a vector-valued image</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">             <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga1eedd3703e4ab90a2f8926a453fe6a8f">gaussianGradient</a>(SrcIterator supperleft,</div>
<div class="line">                          SrcIterator slowerright, SrcAccessor src,</div>
<div class="line">                          DestIterator dupperleft, DestAccessor dest,</div>
<div class="line">                          <span class="keywordtype">double</span> scale);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// write x and y component of the gradient into separate images</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorX, <span class="keyword">class </span>DestAccessorX,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorY, <span class="keyword">class </span>DestAccessorY&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1eedd3703e4ab90a2f8926a453fe6a8f">gaussianGradient</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                     pair&lt;DestIteratorX, DestAccessorX&gt; destx,</div>
<div class="line">                     pair&lt;DestIteratorY, DestAccessorY&gt; desty,</div>
<div class="line">                     <span class="keywordtype">double</span> scale);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// write x and y component of the gradient into a vector-valued image</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">             <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1eedd3703e4ab90a2f8926a453fe6a8f">gaussianGradient</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                     pair&lt;DestIterator, DestAccessor&gt; dest,</div>
<div class="line">                     <span class="keywordtype">double</span> scale);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="convolution_8hxx_source.html">vigra/convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArray&lt;2, float&gt; src(w,h), gradx(w,h), grady(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// calculate gradient vector at scale = 3.0</span></div>
<div class="line">gaussianGradient(src, gradx, grady, 3.0);</div>
<div class="line"></div>
<div class="line"><span class="comment">// likewise, but use a vector image to store the gradient</span></div>
<div class="line">MultiArray&lt;2, TinyVector&lt;float, 2&gt; &gt; dest(w,h);</div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga1eedd3703e4ab90a2f8926a453fe6a8f">gaussianGradient</a>(src, dest, 3.0);</div>
</div><!-- fragment --><p><a href="#" id="gaussianGradient_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianGradient_OldUsage&apos;, &apos;gaussianGradient_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="gaussianGradient_OldUsage" style="display:none"> <div class="fragment"><div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h), gradx(w,h), grady(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// calculate gradient vector at scale = 3.0</span></div>
<div class="line">vigra::gaussianGradient(srcImageRange(src),</div>
<div class="line">                         destImage(gradx), destImage(grady), 3.0);</div>
</div><!-- fragment --> </div> 
</div>
</div>
<a class="anchor" id="gab80e356fa487f97d718ed815a3cf4855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::gaussianGradientMagnitude </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the gradient magnitude by means of a 1st derivatives of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter. </p>
<p>This function calls <a class="el" href="group__ConvolutionFilters.html#ga1eedd3703e4ab90a2f8926a453fe6a8f" title="Calculate the gradient vector by means of a 1st derivatives of Gaussian filter. ">gaussianGradient()</a> and returns the pixel-wise magnitude of the resulting gradient vectors. If the original image has multiple bands, the squared gradient magnitude is computed for each band separately, and the return value is the square root of the sum of these squared magnitudes.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>use arbitrary-dimensional arrays: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// pass filter scale explicitly</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                              MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                              <span class="keywordtype">double</span> sigma,</div>
<div class="line">                              ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// likewise, but sum the contributions of each band</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>MT, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a>(MultiArrayView&lt;N+1, Multiband&lt;MT&gt;, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                              MultiArrayView&lt;N,   T2, S2&gt; dest,</div>
<div class="line">                              <span class="keywordtype">double</span> sigma,</div>
<div class="line">                              ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass filter scale(s) in option object</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                              MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                              ConvolutionOptions&lt;N&gt; <span class="keyword">const</span> &amp; opt);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// likewise, but execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                              MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                              BlockwiseConvolutionOptions&lt;N&gt; <span class="keyword">const</span> &amp; opt);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass filter scale(s) in option object and sum the contributions of each band</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>MT, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a>(MultiArrayView&lt;N+1, Multiband&lt;MT&gt;, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                              MultiArrayView&lt;N,   T2, S2&gt; dest,</div>
<div class="line">                              ConvolutionOptions&lt;N&gt; <span class="keyword">const</span> &amp; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here, the input element types <code>T1</code> and <code>MT</code> can be arbitrary scalar types, and <code>T1</code> may also be <code><a class="el" href="classvigra_1_1TinyVector.html" title="Class for fixed size vectors.This class contains an array of size SIZE of the specified VALUETYPE...">TinyVector</a></code> or <code><a class="el" href="classvigra_1_1RGBValue.html" title="Class for a single RGB value. ">RGBValue</a></code>. The output element type <code>T2</code> should be the corresponding norm type (see <a class="el" href="NormTraits.html">NormTraits</a>). In the <code>Multiband&lt;MT&gt;</code>-version, the input array's right-most dimension is interpreted as a channel axis, therefore it must have one dimension more than the output array.</p>
<p><a href="#" id="gaussianGradientMagnitude_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianGradientMagnitude_OldAPI&apos;, &apos;gaussianGradientMagnitude_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="gaussianGradientMagnitude_OldAPI" style="display:none"> pass <a class="el" href="group__ImageIterators.html">Image Iterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a>(SrcIterator sul,</div>
<div class="line">                                   SrcIterator slr, SrcAccessor src,</div>
<div class="line">                                   DestIterator dupperleft, DestAccessor dest,</div>
<div class="line">                                   <span class="keywordtype">double</span> scale);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                              pair&lt;DestIterator, DestAccessor&gt; dest,</div>
<div class="line">                              <span class="keywordtype">double</span> scale);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 <b>#include</b> &lt;<a class="el" href="convolution_8hxx_source.html">vigra/convolution.hxx</a>&gt; (deprecated API version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><span class="comment">// example 1</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// use a 3-dimensional float array</span></div>
<div class="line">    MultiArray&lt;3, float&gt; volume(Shape3(w, h, d)), grad(volume.shape());</div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// calculate gradient magnitude at scale = 3.0</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a>(volume, grad, 3.0);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// example 2</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// use a 2-dimensional RGB array</span></div>
<div class="line">    MultiArray&lt;2, RGBValue&lt;float&gt; &gt; rgb(Shape2(w, h));</div>
<div class="line">    MultiArray&lt;2, float&gt; grad(rgb.shape());</div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// calculate the color gradient magnitude at scale = 3.0</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a>(rgb, grad, 3.0);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// example 3</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// use a 3-dimensional array whose right-most axis is interpreted as</span></div>
<div class="line">    <span class="comment">// a multi-spectral axis with arbitrary many channels</span></div>
<div class="line">    MultiArray&lt;3, Multiband&lt;float&gt; &gt; spectral(Shape3(w, h, channelCount));</div>
<div class="line">    MultiArray&lt;2, float&gt; grad(Shape2(w, h));</div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// calculate the multi-channel gradient magnitude at scale = 3.0</span></div>
<div class="line">    <span class="comment">// (note that the template parameter N (number of spatial dimensions)</span></div>
<div class="line">    <span class="comment">//  must be provided explicitly as gaussianGradientMagnitude&lt;2&gt;(...) )</span></div>
<div class="line">    MultiArrayView&lt;3, Multiband&lt;float&gt; &gt; view(spectral);</div>
<div class="line">    gaussianGradientMagnitude&lt;2&gt;(view, grad, 3.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="gaussianGradientMagnitude_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianGradientMagnitude_OldUsage&apos;, &apos;gaussianGradientMagnitude_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="gaussianGradientMagnitude_OldUsage" style="display:none"> <div class="fragment"><div class="line"><span class="comment">// use a traditional float or RGB image</span></div>
<div class="line"><a class="code" href="group__StandardImageTypes.html#ga1170a9252f2ce52a075238e327ec78f0">FImage</a> image(w, h), grad(w, h);</div>
<div class="line"><a class="code" href="group__StandardImageTypes.html#ga0217ae4add549fefbc1fe4a1f6d5136a">FRGBImage</a> rgb(w, h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// calculate gradient magnitude at scale = 3.0</span></div>
<div class="line">gaussianGradientMagnitude(srcImageRange(image), destImage(grad), 3.0);</div>
<div class="line"></div>
<div class="line"><span class="comment">// calculate color gradient magnitude at scale = 3.0</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a>(srcImageRange(rgb), destImage(grad), 3.0);</div>
</div><!-- fragment --> </div> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="graph_agglomerative_clustering_8cxx-example.html#a8">graph_agglomerative_clustering.cxx</a>, and <a class="el" href="watershed_8cxx-example.html#a1">watershed.cxx</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gabf286ebb8c18843d9989f624b187ec30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::laplacianOfGaussian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter image with the Laplacian of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> operator at the given scale. </p>
<p>This function calls <a class="el" href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848">separableConvolveX()</a> and <a class="el" href="group__SeparableConvolution.html#gaee4f7ee32121e37112a20f5fb8ad4610">separableConvolveY()</a> with the appropriate 2nd derivative of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> kernels in x- and y-direction and then sums the results to get the Laplacian.</p>
<p>Function <a class="el" href="group__ConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray()</a> performs the same filter operation on arbitrary dimensional arrays.</p>
<p><b> Declarations:</b></p>
<p>pass 2D array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gabf286ebb8c18843d9989f624b187ec30">laplacianOfGaussian</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                        MultiArrayView&lt;2, T2, S2&gt; dest,</div>
<div class="line">                        <span class="keywordtype">double</span> scale);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="laplacianOfGaussian_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;laplacianOfGaussian_OldAPI&apos;, &apos;laplacianOfGaussian_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="laplacianOfGaussian_OldAPI" style="display:none"> pass <a class="el" href="group__ImageIterators.html">Image Iterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#gabf286ebb8c18843d9989f624b187ec30">laplacianOfGaussian</a>(SrcIterator supperleft,</div>
<div class="line">                            SrcIterator slowerright, SrcAccessor sa,</div>
<div class="line">                            DestIterator dupperleft, DestAccessor da,</div>
<div class="line">                            <span class="keywordtype">double</span> scale);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gabf286ebb8c18843d9989f624b187ec30">laplacianOfGaussian</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                      pair&lt;DestIterator, DestAccessor&gt; dest,</div>
<div class="line">                      <span class="keywordtype">double</span> scale);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="convolution_8hxx_source.html">vigra/convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArray&lt;2, float&gt; src(w,h), dest(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// calculate Laplacian of Gaussian at scale = 3.0</span></div>
<div class="line">laplacianOfGaussian(src, dest, 3.0);</div>
</div><!-- fragment --><p><a href="#" id="laplacianOfGaussian_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;laplacianOfGaussian_OldUsage&apos;, &apos;laplacianOfGaussian_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="laplacianOfGaussian_OldUsage" style="display:none"> <div class="fragment"><div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h), dest(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// calculate Laplacian of Gaussian at scale = 3.0</span></div>
<div class="line">vigra::laplacianOfGaussian(srcImageRange(src), destImage(dest), 3.0);</div>
</div><!-- fragment --> </div> 
</div>
</div>
<a class="anchor" id="gada2a320ba52c347f03c02ef173e346cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::hessianMatrixOfGaussian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter image with the 2nd derivatives of the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> at the given scale to get the Hessian matrix. </p>
<p>The Hessian matrix is a symmetric matrix defined as:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\rm Hessian}(I) = \left( \begin{array}{cc} G_{xx} \ast I &amp; G_{xy} \ast I \\ G_{xy} \ast I &amp; G_{yy} \ast I \end{array} \right) \]" src="form_44.png"/>
</p>
<p>where <img class="formulaInl" alt="$G_{xx}, G_{xy}, G_{yy}$" src="form_45.png"/> denote 2nd derivatives of Gaussians at the given scale, and <img class="formulaInl" alt="$\ast$" src="form_46.png"/> is the convolution symbol. This function calls <a class="el" href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848">separableConvolveX()</a> and <a class="el" href="group__SeparableConvolution.html#gaee4f7ee32121e37112a20f5fb8ad4610">separableConvolveY()</a> with the appropriate 2nd derivative of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> kernels and puts the results in the three destination images. The first destination image will contain the second derivative in x-direction, the second one the mixed derivative, and the third one holds the derivative in y-direction.</p>
<p>Function <a class="el" href="group__ConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray()</a> performs the same filter operation on arbitrary dimensional arrays.</p>
<p><b> Declarations:</b></p>
<p>pass 2D array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gada2a320ba52c347f03c02ef173e346cd">hessianMatrixOfGaussian</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                            MultiArrayView&lt;2, TinyVector&lt;T2, 3&gt;, S2&gt; dest,</div>
<div class="line">                            <span class="keywordtype">double</span> scale);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="hessianMatrixOfGaussian_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;hessianMatrixOfGaussian_OldAPI&apos;, &apos;hessianMatrixOfGaussian_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="hessianMatrixOfGaussian_OldAPI" style="display:none"> pass <a class="el" href="group__ImageIterators.html">Image Iterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorX, <span class="keyword">class </span>DestAccessorX,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorXY, <span class="keyword">class </span>DestAccessorXY,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorY, <span class="keyword">class </span>DestAccessorY&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#gada2a320ba52c347f03c02ef173e346cd">hessianMatrixOfGaussian</a>(SrcIterator supperleft,</div>
<div class="line">                            SrcIterator slowerright, SrcAccessor sa,</div>
<div class="line">                            DestIteratorX dupperleftx, DestAccessorX dax,</div>
<div class="line">                            DestIteratorXY dupperleftxy, DestAccessorXY daxy,</div>
<div class="line">                            DestIteratorY dupperlefty, DestAccessorY day,</div>
<div class="line">                            <span class="keywordtype">double</span> scale);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorX, <span class="keyword">class </span>DestAccessorX,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorXY, <span class="keyword">class </span>DestAccessorXY,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorY, <span class="keyword">class </span>DestAccessorY&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gada2a320ba52c347f03c02ef173e346cd">hessianMatrixOfGaussian</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                      pair&lt;DestIteratorX, DestAccessorX&gt; destx,</div>
<div class="line">                      pair&lt;DestIteratorXY, DestAccessorXY&gt; destxy,</div>
<div class="line">                      pair&lt;DestIteratorY, DestAccessorY&gt; desty,</div>
<div class="line">                      <span class="keywordtype">double</span> scale);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="convolution_8hxx_source.html">vigra/convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArray&lt;2, float&gt;                  src(w,h);</div>
<div class="line">MultiArray&lt;2, TinyVector&lt;float, 3&gt; &gt;  hessian(w,h);  <span class="comment">// will hold the three components of the Hessian</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// calculate Hessian of Gaussian at scale = 3.0, use a 3-band output image</span></div>
<div class="line">hessianMatrixOfGaussian(src, hessian, 3.0);</div>
</div><!-- fragment --><p><a href="#" id="hessianMatrixOfGaussian_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;hessianMatrixOfGaussian_OldUsage&apos;, &apos;hessianMatrixOfGaussian_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="hessianMatrixOfGaussian_OldUsage" style="display:none"> <div class="fragment"><div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h),</div>
<div class="line">              hxx(w,h), hxy(w,h), hyy(w,h); <span class="comment">// use a separate image for each component of the Hessian</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// calculate Hessian of Gaussian at scale = 3.0, use 3 single.band output images</span></div>
<div class="line">vigra::hessianMatrixOfGaussian(srcImageRange(src),</div>
<div class="line">                               destImage(hxx), destImage(hxy), destImage(hyy), 3.0);</div>
</div><!-- fragment --> </div> 
</div>
</div>
<a class="anchor" id="ga1fa5263dd0a2d0d152e67e7bb31f1d66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::structureTensor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the Structure Tensor for each pixel of and image, using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> (derivative) filters. </p>
<p>The Structure Tensor is is a smoothed version of the Euclidean product of the gradient vector with itself. I.e. it's a symmetric matrix defined as:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{\rm StructurTensor}(I) = \left( \begin{array}{cc} G \ast (I_x I_x) &amp; G \ast (I_x I_y) \\ G \ast (I_x I_y) &amp; G \ast (I_y I_y) \end{array} \right) = \left( \begin{array}{cc} A &amp; C \\ C &amp; B \end{array} \right) \]" src="form_47.png"/>
</p>
<p>where <img class="formulaInl" alt="$G$" src="form_48.png"/> denotes <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing at the <em>outer scale</em>, <img class="formulaInl" alt="$I_x, I_y$" src="form_49.png"/> are the gradient components taken at the <em>inner scale</em>, <img class="formulaInl" alt="$\ast$" src="form_46.png"/> is the convolution symbol, and <img class="formulaInl" alt="$I_x I_x$" src="form_50.png"/> etc. are pixelwise products of the 1st derivative images. This function calls <a class="el" href="group__SeparableConvolution.html#ga34459275af4134198dfc1a75c9993848">separableConvolveX()</a> and <a class="el" href="group__SeparableConvolution.html#gaee4f7ee32121e37112a20f5fb8ad4610">separableConvolveY()</a> with the appropriate <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> kernels and puts the results in the three separate destination images (where the first one will contain <img class="formulaInl" alt="$G \ast (I_x I_x)$" src="form_51.png"/>, the second one <img class="formulaInl" alt="$G \ast (I_x I_y)$" src="form_52.png"/>, and the third one holds <img class="formulaInl" alt="$G \ast (I_y I_y)$" src="form_53.png"/>), or into a single 3-band image (where the bands hold the result in the same order as above). The latter form is also applicable when the source image is a multi-band image (e.g. RGB). In this case, tensors are first computed for each band separately, and then summed up to get a single result tensor.</p>
<p>Function <a class="el" href="group__ConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray()</a> performs the same filter operation on arbitrary dimensional arrays.</p>
<p><b> Declarations:</b></p>
<p>pass 2D array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// create three separate destination images</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keyword">class </span>S,</div>
<div class="line">              <span class="keyword">class </span>TX, <span class="keyword">class </span>SX,</div>
<div class="line">              <span class="keyword">class </span>TXY, <span class="keyword">class </span>SXY,</div>
<div class="line">              <span class="keyword">class </span>TY, <span class="keyword">class </span>SY&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1fa5263dd0a2d0d152e67e7bb31f1d66">structureTensor</a>(MultiArrayView&lt;2, S, T&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                    MultiArrayView&lt;2, TX, SX&gt;       destx,</div>
<div class="line">                    MultiArrayView&lt;2, TXY, SXY&gt;     destxy,</div>
<div class="line">                    MultiArrayView&lt;2, TY, SY&gt;       desty,</div>
<div class="line">                    <span class="keywordtype">double</span> inner_scale, <span class="keywordtype">double</span> outer_scale);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// create a single 3-band destination image</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1fa5263dd0a2d0d152e67e7bb31f1d66">structureTensor</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                    MultiArrayView&lt;2, TinyVector&lt;T2, 3&gt;, S2&gt; dest,</div>
<div class="line">                    <span class="keywordtype">double</span> inner_scale, <span class="keywordtype">double</span> outer_scale);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="structureTensor_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;structureTensor_OldAPI&apos;, &apos;structureTensor_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="structureTensor_OldAPI" style="display:none"> pass <a class="el" href="group__ImageIterators.html">Image Iterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// create three separate destination images</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorX, <span class="keyword">class </span>DestAccessorX,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorXY, <span class="keyword">class </span>DestAccessorXY,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorY, <span class="keyword">class </span>DestAccessorY&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga1fa5263dd0a2d0d152e67e7bb31f1d66">structureTensor</a>(SrcIterator supperleft,</div>
<div class="line">                            SrcIterator slowerright, SrcAccessor sa,</div>
<div class="line">                            DestIteratorX dupperleftx, DestAccessorX dax,</div>
<div class="line">                            DestIteratorXY dupperleftxy, DestAccessorXY daxy,</div>
<div class="line">                            DestIteratorY dupperlefty, DestAccessorY day,</div>
<div class="line">                            <span class="keywordtype">double</span> inner_scale, <span class="keywordtype">double</span> outer_scale);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// create a single 3-band destination image</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga1fa5263dd0a2d0d152e67e7bb31f1d66">structureTensor</a>(SrcIterator supperleft,</div>
<div class="line">                            SrcIterator slowerright, SrcAccessor sa,</div>
<div class="line">                            DestIterator dupperleft, DestAccessor da,</div>
<div class="line">                            <span class="keywordtype">double</span> inner_scale, <span class="keywordtype">double</span> outer_scale);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// create three separate destination images</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorX, <span class="keyword">class </span>DestAccessorX,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorXY, <span class="keyword">class </span>DestAccessorXY,</div>
<div class="line">              <span class="keyword">class </span>DestIteratorY, <span class="keyword">class </span>DestAccessorY&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1fa5263dd0a2d0d152e67e7bb31f1d66">structureTensor</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                      pair&lt;DestIteratorX, DestAccessorX&gt; destx,</div>
<div class="line">                      pair&lt;DestIteratorXY, DestAccessorXY&gt; destxy,</div>
<div class="line">                      pair&lt;DestIteratorY, DestAccessorY&gt; desty,</div>
<div class="line">                      <span class="keywordtype">double</span> nner_scale, <span class="keywordtype">double</span> outer_scale);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// create a single 3-band destination image</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1fa5263dd0a2d0d152e67e7bb31f1d66">structureTensor</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                      pair&lt;DestIterator, DestAccessor&gt; dest,</div>
<div class="line">                      <span class="keywordtype">double</span> nner_scale, <span class="keywordtype">double</span> outer_scale);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="convolution_8hxx_source.html">vigra/convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArray&lt;2, flost&gt; src(w,h),</div>
<div class="line">                     stxx(w,h), stxy(w,h), styy(w,h);  <span class="comment">// use a separate image for each component</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// calculate Structure Tensor at inner scale = 1.0 and outer scale = 3.0</span></div>
<div class="line">structureTensor(src, stxx, stxy, styy, 1.0, 3.0);</div>
<div class="line"></div>
<div class="line"><span class="comment">// likwise with a single 3-band destination image</span></div>
<div class="line">MultiArray&lt;2, TinyVector&lt;float, 3&gt; &gt; st(w,h);</div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga1fa5263dd0a2d0d152e67e7bb31f1d66">structureTensor</a>(src, st, 1.0, 3.0);</div>
</div><!-- fragment --><p><a href="#" id="structureTensor_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;structureTensor_OldUsage&apos;, &apos;structureTensor_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="structureTensor_OldUsage" style="display:none"> <div class="fragment"><div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h),</div>
<div class="line">              stxx(w,h), stxy(w,h), styy(w,h);</div>
<div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::BasicImage&lt;TinyVector&lt;float, 3&gt;</a> &gt; st(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">vigra::structureTensor(srcImageRange(src),</div>
<div class="line">                       destImage(stxx), destImage(stxy), destImage(styy), 1.0, 3.0);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga1fa5263dd0a2d0d152e67e7bb31f1d66">vigra::structureTensor</a>(srcImageRange(src), destImage(st), 1.0, 3.0);</div>
</div><!-- fragment --> </div> 
</div>
</div>
<a class="anchor" id="ga1c43f1c6fd2f6391c7a26de88545b8db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::separableConvolveMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separated convolution on multi-dimensional arrays. </p>
<p>This function computes a separated convolution on all dimensions of the given multi-dimensional array. Both source and destination arrays are represented by iterators, shape objects and accessors. The destination array is required to already have the correct size.</p>
<p>There are two variants of this functions: one takes a single kernel of type <a class="el" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D</a> which is then applied to all dimensions, whereas the other requires an iterator referencing a sequence of <a class="el" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D</a> objects, one for every dimension of the data. Then the first kernel in this sequence is applied to the innermost dimension (e.g. the x-axis of an image), while the last is applied to the outermost dimension (e.g. the z-axis in a 3D image).</p>
<p>This function may work in-place, which means that <code>source.data() == dest.data()</code> is allowed. A full-sized internal array is only allocated if working on the destination array directly would cause round-off errors (i.e. if <code>typeid(typename NumericTraits&lt;T2&gt;::RealPromote) != typeid(T2)</code>).</p>
<p>If <code>start</code> and <code>stop</code> have non-default values, they must represent a valid subarray of the input array. The convolution is then restricted to that subarray, and it is assumed that the output array only refers to the subarray (i.e. <code>dest.shape() == stop - start</code>). Negative ROI boundaries are interpreted relative to the end of the respective dimension (i.e. <code>if(stop[k] &lt; 0) stop[k] += source.shape(k);</code>).</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// apply each kernel from the sequence &#39;kernels&#39; in turn</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,</div>
<div class="line">              <span class="keyword">class </span>KernelIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>,</div>
<div class="line">                                MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                                KernelIterator kernels,</div>
<div class="line">                                <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type start = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type(),</div>
<div class="line">                                <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type stop  = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// apply the same kernel to all dimensions</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,</div>
<div class="line">              <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                                Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel,</div>
<div class="line">                                <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type <span class="keyword">const</span> &amp; start = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type(),</div>
<div class="line">                                <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type <span class="keyword">const</span> &amp; stop = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type());</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="separableConvolveMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;separableConvolveMultiArray_OldAPI&apos;, &apos;separableConvolveMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="separableConvolveMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// apply the same kernel to all dimensions</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                                DestIterator diter, DestAccessor dest,</div>
<div class="line">                                Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel,</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// apply each kernel from the sequence &#39;kernels&#39; in turn</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>KernelIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                                DestIterator diter, DestAccessor dest,</div>
<div class="line">                                KernelIterator kernels,</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// apply the same kernel to all dimensions</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                                Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel,</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// apply each kernel from the sequence &#39;kernels&#39; in turn</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>KernelIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                                KernelIterator kernels,</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">Shape3 shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt;         dest(shape);</div>
<div class="line">...</div>
<div class="line">Kernel1D&lt;<span class="keywordtype">float</span>&gt; gauss;</div>
<div class="line">gauss.initGaussian(sigma);</div>
<div class="line"></div>
<div class="line"><span class="comment">// smooth all dimensions with the same kernel</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(source, dest, gauss);</div>
<div class="line"></div>
<div class="line"><span class="comment">// create 3 Gauss kernels, one for each dimension, but smooth the z-axis less</span></div>
<div class="line">ArrayVector&lt;Kernel1D&lt;float&gt; &gt; kernels(3, gauss);</div>
<div class="line">kernels[2].initGaussian(sigma / 2.0);</div>
<div class="line"></div>
<div class="line"><span class="comment">// perform Gaussian smoothing on all dimensions</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(source, dest, kernels.begin());</div>
<div class="line"></div>
<div class="line"><span class="comment">// create output array for a ROI</span></div>
<div class="line">MultiArray&lt;3, float&gt; destROI(shape - Shape3(10,10,10));</div>
<div class="line"></div>
<div class="line"><span class="comment">// only smooth the given ROI (ignore 5 pixels on all sides of the array)</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(source, destROI, gauss, Shape3(5,5,5), Shape3(-5,-5,-5));</div>
</div><!-- fragment --><p><a href="#" id="separableConvolveMultiArray_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;separableConvolveMultiArray_OldUsage&apos;, &apos;separableConvolveMultiArray_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="separableConvolveMultiArray_OldUsage" style="display:none"> <div class="fragment"><div class="line">MultiArray&lt;3, unsigned char&gt;::size_type shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt; dest(shape);</div>
<div class="line">...</div>
<div class="line">Kernel1D&lt;<span class="keywordtype">float</span>&gt; gauss;</div>
<div class="line">gauss.initGaussian(sigma);</div>
<div class="line"><span class="comment">// create 3 Gauss kernels, one for each dimension</span></div>
<div class="line">ArrayVector&lt;Kernel1D&lt;float&gt; &gt; kernels(3, gauss);</div>
<div class="line"></div>
<div class="line"><span class="comment">// perform Gaussian smoothing on all dimensions</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(source, dest,</div>
<div class="line">                            kernels.begin());</div>
</div><!-- fragment --><p> <b> Required Interface:</b> </p>
<div class="fragment"><div class="line">see \ref separableConvolveImage(), in addition:</div>
<div class="line"></div>
<div class="line">NumericTraits&lt;T1&gt;::RealPromote s = src[0];</div>
<div class="line"></div>
<div class="line">s = s + s;</div>
<div class="line">s = kernel(0) * s;</div>
</div><!-- fragment --> </div><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel. ">vigra::Kernel1D</a>, <a class="el" href="group__SeparableConvolution.html#ga68b1efe52c497cfbaece1452515b6307" title="Performs a 1-dimensional convolution of the source signal using the given kernel. ...">convolveLine()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac82f89797cb83810e5a9ebddac36259b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convolveMultiArrayOneDimension </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolution along a single dimension of a multi-dimensional arrays. </p>
<p>This function computes a convolution along one dimension (specified by the parameter <code>dim</code> of the given multi-dimensional array with the given <code>kernel</code>. The destination array must already have the correct size.</p>
<p>If <code>start</code> and <code>stop</code> have non-default values, they must represent a valid subarray of the input array. The convolution is then restricted to that subarray, and it is assumed that the output array only refers to the subarray (i.e. <code>dest.shape() == stop - start</code>). Negative ROI boundaries are interpreted relative to the end of the respective dimension (i.e. <code>if(stop[k] &lt; 0) stop[k] += source.shape(k);</code>).</p>
<p>This function may work in-place, which means that <code>source.data() == dest.data()</code> is allowed.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,</div>
<div class="line">              <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                   MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim,</div>
<div class="line">                                   Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel,</div>
<div class="line">                                   <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type start = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type(),</div>
<div class="line">                                   <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type stop  = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type());</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="convolveMultiArrayOneDimension_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;convolveMultiArrayOneDimension_OldAPI&apos;, &apos;convolveMultiArrayOneDimension_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="convolveMultiArrayOneDimension_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                                   DestIterator diter, DestAccessor dest,</div>
<div class="line">                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <a class="code" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D&lt;T&gt;</a> <span class="keyword">const</span> &amp; kernel,</div>
<div class="line">                                   SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),</div>
<div class="line">                                   SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                   pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <a class="code" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D&lt;T&gt;</a> <span class="keyword">const</span> &amp; kernel,</div>
<div class="line">                                   SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),</div>
<div class="line">                                   SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">Shape3 shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt; dest(shape);</div>
<div class="line">...</div>
<div class="line">Kernel1D&lt;<span class="keywordtype">float</span>&gt; gauss;</div>
<div class="line">gauss.initGaussian(sigma);</div>
<div class="line"></div>
<div class="line"><span class="comment">// perform Gaussian smoothing along dimension 1 (height)</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a>(source, dest, 1, gauss);</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays. ">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga11d81ef630205d44b8517c464217207d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::gaussianSmoothMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Isotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing of a multi-dimensional arrays. </p>
<p>This function computes an isotropic convolution of the given N-dimensional array with a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter at the given standard deviation <code>sigma</code>. Both source and destination arrays are represented by iterators, shape objects and accessors. The destination array is required to already have the correct size. This function may work in-place, which means that <code>source.data() == dest.data()</code> is allowed. It is implemented by a call to <a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernel.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// pass filter scale explicitly</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                             MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                             <span class="keywordtype">double</span> sigma,</div>
<div class="line">                             ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass filer scale(s) in the option object</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                             MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                             ConvolutionOptions&lt;N&gt; opt);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// as above, but execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                             MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                             BlockwiseConvolutionOptions&lt;N&gt; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="gaussianSmoothMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianSmoothMultiArray_OldAPI&apos;, &apos;gaussianSmoothMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="gaussianSmoothMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                             DestIterator diter, DestAccessor dest,</div>
<div class="line">                             <span class="keywordtype">double</span> sigma,</div>
<div class="line">                             <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                             pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                             <span class="keywordtype">double</span> sigma,</div>
<div class="line">                             <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">Shape3 shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt;         dest(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// perform isotropic Gaussian smoothing at scale &#39;sigma&#39;</span></div>
<div class="line">gaussianSmoothMultiArray(source, dest, sigma);</div>
</div><!-- fragment --><p><b> Multi-threaded execution:</b></p>
<div class="fragment"><div class="line">Shape3 shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt;         dest(shape);</div>
<div class="line">...</div>
<div class="line">BlockwiseConvolutionOptions&lt;3&gt; opt;</div>
<div class="line">opt.numThreads(4);       <span class="comment">// use 4 threads (uses hardware default if not given)</span></div>
<div class="line">opt.innerScale(sigma);</div>
<div class="line"></div>
<div class="line"><span class="comment">// perform isotropic Gaussian smoothing at scale &#39;sigma&#39; in parallel</span></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(source, dest, sigma, opt);</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line">Shape3 shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt;         dest(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">TinyVector&lt;float, 3&gt; resolution_sigmas;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// perform anisotropic Gaussian smoothing at scale &#39;sigma&#39;</span></div>
<div class="line">gaussianSmoothMultiArray(source, dest, sigma,</div>
<div class="line">                         ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays. ">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d5e9021732f13248ca3a0fe1b7c0552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::gaussianGradientMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of a multi-dimensional arrays. </p>
<p>This function computes the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of the given N-dimensional array with a sequence of first-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code> (differentiation is applied to each dimension in turn, starting with the innermost dimension). The destination array is required to have a vector valued pixel type with as many elements as the number of dimensions. This function is implemented by calls to <a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernels.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// pass filter scale explicitly</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                               MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,</div>
<div class="line">                               <span class="keywordtype">double</span> sigma,</div>
<div class="line">                               ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass filter scale(s) in option object</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                               MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,</div>
<div class="line">                               ConvolutionOptions&lt;N&gt; opt);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// likewise, but execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                               MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,</div>
<div class="line">                               BlockwiseConvolutionOptions&lt;N&gt; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="gaussianGradientMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianGradientMultiArray_OldAPI&apos;, &apos;gaussianGradientMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="gaussianGradientMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                               DestIterator diter, DestAccessor dest,</div>
<div class="line">                               <span class="keywordtype">double</span> sigma,</div>
<div class="line">                               <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                               pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                               <span class="keywordtype">double</span> sigma,</div>
<div class="line">                               <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">Shape3 shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute Gaussian gradient at scale sigma</span></div>
<div class="line">gaussianGradientMultiArray(source, dest, sigma);</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line">Shape3 shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">TinyVector&lt;float, 3&gt; resolution_sigmas;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute Gaussian gradient at scale sigma</span></div>
<div class="line">gaussianGradientMultiArray(source, dest, sigma,</div>
<div class="line">                           ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays. ">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga99cfc937dc06355aaf71b551a7c31faa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::symmetricGradientMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate gradient of a multi-dimensional arrays using symmetric difference filters. </p>
<p>This function computes the gradient of the given N-dimensional array with a sequence of symmetric difference filters a (differentiation is applied to each dimension in turn, starting with the innermost dimension). The destination array is required to have a vector valued pixel type with as many elements as the number of dimensions. This function is implemented by calls to <a class="el" href="group__ConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension()</a> with the symmetric difference kernel.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// execute algorithm sequentially</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,</div>
<div class="line">                                ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,</div>
<div class="line">                                BlockwiseConvolutionOptions&lt;N&gt; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="symmetricGradientMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;symmetricGradientMultiArray_OldAPI&apos;, &apos;symmetricGradientMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="symmetricGradientMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                                DestIterator diter, DestAccessor dest,</div>
<div class="line">                                <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                                <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArray&lt;3, unsigned char&gt;::size_type shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute gradient</span></div>
<div class="line">symmetricGradientMultiArray(srcMultiArrayRange(source), destMultiArray(dest));</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line">Shape3 shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute gradient</span></div>
<div class="line">symmetricGradientMultiArray(source, dest,</div>
<div class="line">                            ConvolutionOptions&lt;3&gt;().stepSize(step_size));</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__ConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b" title="Convolution along a single dimension of a multi-dimensional arrays. ">convolveMultiArrayOneDimension()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac165234c3bca25d3162cac15ceb2b970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::laplacianOfGaussianMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate Laplacian of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters. </p>
<p>This function computes the Laplacian of the given N-dimensional array with a sequence of second-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code>. Both source and destination arrays must have scalar value_type. This function is implemented by calls to <a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernels, followed by summation.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// pass scale explicitly</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                  MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                                  <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                  ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass scale(s) in option object</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                  MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                                  ConvolutionOptions&lt;N&gt; opt );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// likewise, but execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                  MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                                  BlockwiseConvolutionOptions&lt;N&gt; opt );</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="laplacianOfGaussianMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;laplacianOfGaussianMultiArray_OldAPI&apos;, &apos;laplacianOfGaussianMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="laplacianOfGaussianMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                                  DestIterator diter, DestAccessor dest,</div>
<div class="line">                                  <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                  <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                  pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                                  <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                  <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">Shape3 shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, float&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt; laplacian(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute Laplacian at scale sigma</span></div>
<div class="line">laplacianOfGaussianMultiArray(source, laplacian, sigma);</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line">MultiArray&lt;3, float&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt; laplacian(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">TinyVector&lt;float, 3&gt; resolution_sigmas;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute Laplacian at scale sigma</span></div>
<div class="line">laplacianOfGaussianMultiArray(source, laplacian, sigma,</div>
<div class="line">                              ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays. ">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga63e603a8303c5af14dd8e709a63141fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::gaussianDivergenceMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the divergence of a vector field using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters. </p>
<p>This function computes the divergence of the given N-dimensional vector field with a sequence of first-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code>. The input vector field can either be given as a sequence of scalar array views (one for each vector field component), represented by an iterator range, or by a single vector array with the appropriate shape. This function is implemented by calls to <a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the suitable kernels, followed by summation.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// specify input vector field as a sequence of scalar arrays</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>Iterator,</div>
<div class="line">              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T, <span class="keyword">class </span>S&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a>(Iterator vectorField, Iterator vectorFieldEnd,</div>
<div class="line">                                 MultiArrayView&lt;N, T, S&gt; divergence,</div>
<div class="line">                                 ConvolutionOptions&lt;N&gt; <span class="keyword">const</span> &amp; opt);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>Iterator,</div>
<div class="line">              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T, <span class="keyword">class </span>S&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a>(Iterator vectorField, Iterator vectorFieldEnd,</div>
<div class="line">                                 MultiArrayView&lt;N, T, S&gt; divergence,</div>
<div class="line">                                 <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                 ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass input vector field as an array of vectors</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a>(MultiArrayView&lt;N, TinyVector&lt;T1, N&gt;, S1&gt; <span class="keyword">const</span> &amp; vectorField,</div>
<div class="line">                                 MultiArrayView&lt;N, T2, S2&gt; divergence,</div>
<div class="line">                                 ConvolutionOptions&lt;N&gt; <span class="keyword">const</span> &amp; opt);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a>(MultiArrayView&lt;N, TinyVector&lt;T1, N&gt;, S1&gt; <span class="keyword">const</span> &amp; vectorField,</div>
<div class="line">                                 MultiArrayView&lt;N, T2, S2&gt; divergence,</div>
<div class="line">                                 <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                 ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass input vector field as an array of vectors and</span></div>
<div class="line">    <span class="comment">// execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a>(MultiArrayView&lt;N, TinyVector&lt;T1, N&gt;, S1&gt; <span class="keyword">const</span> &amp; vectorField,</div>
<div class="line">                                 MultiArrayView&lt;N, T2, S2&gt; divergence,</div>
<div class="line">                                 BlockwiseConvolutionOptions&lt;N&gt; <span class="keyword">const</span> &amp; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">Shape3 shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt; laplacian(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute divergence at scale sigma</span></div>
<div class="line">gaussianDivergenceMultiArray(source, laplacian, sigma);</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line">MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt; laplacian(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">TinyVector&lt;float, 3&gt; resolution_sigmas;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute divergence at scale sigma</span></div>
<div class="line">gaussianDivergenceMultiArray(source, laplacian, sigma,</div>
<div class="line">                             ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gae419814e55fb3191a87e7b75f505d4da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::hessianOfGaussianMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate Hessian matrix of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters. </p>
<p>This function computes the Hessian matrix the given scalar N-dimensional array with a sequence of second-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code>. The destination array must have a vector valued element type with N*(N+1)/2 elements (it represents the upper triangular part of the symmetric Hessian matrix, flattened row-wise). This function is implemented by calls to <a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernels.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// pass scale explicitly</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,</div>
<div class="line">                                <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass scale(s) in option object</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,</div>
<div class="line">                                ConvolutionOptions&lt;N&gt; opt);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// likewise, but execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,</div>
<div class="line">                                BlockwiseConvolutionOptions&lt;N&gt; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="hessianOfGaussianMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;hessianOfGaussianMultiArray_OldAPI&apos;, &apos;hessianOfGaussianMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="hessianOfGaussianMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                                DestIterator diter, DestAccessor dest,</div>
<div class="line">                                <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                                <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">Shape3 shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, float&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 6&gt; &gt; dest(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute Hessian at scale sigma</span></div>
<div class="line">hessianOfGaussianMultiArray(source, dest, sigma);</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line">MultiArray&lt;3, float&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 6&gt; &gt; dest(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">TinyVector&lt;float, 3&gt; resolution_sigmas;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute Hessian at scale sigma</span></div>
<div class="line">hessianOfGaussianMultiArray(source, dest, sigma,</div>
<div class="line">                            ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays. ">separableConvolveMultiArray()</a>, <a class="el" href="group__MultiPointoperators.html#gad869b7b263b104e005a1ddc66b5c1f80" title="Calculate the tensor (outer) product of a N-D vector with itself. ">vectorToTensorMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6be0fb8e178b6b589e2441cc4ae0f54d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::structureTensorMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the structure tensor of a multi-dimensional arrays. </p>
<p>This function computes the gradient (outer product) tensor for each element of the given N-dimensional array with first-derivative-of-Gaussian filters at the given <code>innerScale</code>, followed by <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing at <code>outerScale</code>. The destination array must have a vector valued pixel type with N*(N+1)/2 elements (it represents the upper triangular part of the symmetric structure tensor matrix, flattened row-wise). If the source array is also vector valued, the resulting structure tensor is the sum of the individual tensors for each channel. This function is implemented by calls to <a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernels.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameters <code>innerScale</code> and <code>outerScale</code> are both omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// pass scales explicitly</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                              MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,</div>
<div class="line">                              <span class="keywordtype">double</span> innerScale, <span class="keywordtype">double</span> outerScale,</div>
<div class="line">                              ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass scales in option object</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                              MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,</div>
<div class="line">                              ConvolutionOptions&lt;N&gt; opt );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// likewise, but execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                              MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,</div>
<div class="line">                              BlockwiseConvolutionOptions&lt;N&gt; opt );</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="structureTensorMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;structureTensorMultiArray_OldAPI&apos;, &apos;structureTensorMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="structureTensorMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                              DestIterator diter, DestAccessor dest,</div>
<div class="line">                              <span class="keywordtype">double</span> innerScale, <span class="keywordtype">double</span> outerScale,</div>
<div class="line">                              ConvolutionOptions&lt;N&gt; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                              pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                              <span class="keywordtype">double</span> innerScale, <span class="keywordtype">double</span> outerScale,</div>
<div class="line">                              <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">Shape3 shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, RGBValue&lt;float&gt; &gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 6&gt; &gt; dest(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute structure tensor at scales innerScale and outerScale</span></div>
<div class="line">structureTensorMultiArray(source, dest, innerScale, outerScale);</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line">MultiArray&lt;3, RGBValue&lt;float&gt; &gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 6&gt; &gt; dest(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">TinyVector&lt;float, 3&gt; resolution_sigmas;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute structure tensor at scales innerScale and outerScale</span></div>
<div class="line">structureTensorMultiArray(source, dest, innerScale, outerScale,</div>
<div class="line">                          ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays. ">separableConvolveMultiArray()</a>, <a class="el" href="group__MultiPointoperators.html#gad869b7b263b104e005a1ddc66b5c1f80" title="Calculate the tensor (outer) product of a N-D vector with itself. ">vectorToTensorMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf819a613a16ee9807d69ecb2d91b2ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convolveFFT </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve an array with a kernel by means of the Fourier transform. </p>
<p>Thanks to the convolution theorem of Fourier theory, a convolution in the spatial domain is equivalent to a multiplication in the frequency domain. Thus, for certain kernels (especially large, non-separable ones), it is advantageous to perform the convolution by first transforming both array and kernel to the frequency domain, multiplying the frequency representations, and transforming the result back into the spatial domain. Some kernels have a much simpler definition in the frequency domain, so that they are readily computed there directly, avoiding Fourier transformation of those kernels.</p>
<p>The following functions implement various variants of FFT-based convolution:</p>
<dl>
<dt><b>convolveFFT</b></dt>
<dd>Convolve a real-valued input array with a kernel such that the result is also real-valued. That is, the kernel is either provided as a real-valued array in the spatial domain, or as a complex-valued array in the Fourier domain, using the half-space format of the R2C Fourier transform (see below). </dd>
<dt><b>convolveFFTMany</b></dt>
<dd>Like <code>convolveFFT</code>, but you may provide many kernels at once (using an iterator pair specifying the kernel sequence). This has the advantage that the forward transform of the input array needs to be executed only once. </dd>
<dt><b>convolveFFTComplex</b></dt>
<dd>Convolve a complex-valued input array with a complex-valued kernel, resulting in a complex-valued output array. An additional flag is used to specify whether the kernel is defined in the spatial or frequency domain. </dd>
<dt><b>convolveFFTComplexMany</b></dt>
<dd>Like <code>convolveFFTComplex</code>, but you may provide many kernels at once (using an iterator pair specifying the kernel sequence). This has the advantage that the forward transform of the input array needs to be executed only once. </dd>
</dl>
<p>The output arrays must have the same shape as the input arrays. In the "Many" variants of the convolution functions, the kernels must all have the same shape.</p>
<p>The origin of the kernel is always assumed to be in the center of the kernel array (precisely, at the point <code>floor(kernel.shape() / 2.0)</code>, except when the half-space format is used, see below). The function <a class="el" href="group__FourierTransform.html#gaee27c376079af99e8e2148e7d23ffbbb">moveDCToUpperLeft()</a> will be called internally to align the kernel with the transformed input as appropriate.</p>
<p>If a real input is combined with a real kernel, the kernel is automatically assumed to be defined in the spatial domain. If a real input is combined with a complex kernel, the kernel is assumed to be defined in the Fourier domain in half-space format. If the input array is complex, a flag <code>fourierDomainKernel</code> determines where the kernel is defined.</p>
<p>When the kernel is defined in the spatial domain, the convolution functions will automatically pad (enlarge) the input array by at least the kernel radius in each direction. The newly added space is filled according to reflective boundary conditions in order to minimize border artifacts during convolution. It is thus ensured that convolution in the Fourier domain yields the same results as convolution in the spatial domain (e.g. when <a class="el" href="group__ConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> is called with the same kernel). A little further padding may be added to make sure that the padded array shape uses integers which have only small prime factors, because FFTW is then able to use the fastest possible algorithms. <a class="el" href="classvigra_1_1Any.html" title="Typesafe storage of arbitrary values. ">Any</a> padding is automatically removed from the result arrays before the function returns.</p>
<p>When the kernel is defined in the frequency domain, it must be complex-valued, and its shape determines the shape of the Fourier representation (i.e. the input is padded according to the shape of the kernel). If we are going to perform a complex-valued convolution, the kernel must be defined for the entire frequency domain, and its shape directly determines the size of the FFT.</p>
<p>In contrast, a frequency domain kernel for a real-valued convolution must have symmetry properties that allow to drop half of the kernel coefficients, as in the <a href="http://www.fftw.org/doc/Multi_002dDimensional-DFTs-of-Real-Data.html">R2C transform</a>. That is, the kernel must have the <em>half-space format</em>, that is the shape returned by <code>fftwCorrespondingShapeR2C(fourier_shape)</code>, where <code>fourier_shape</code> is the desired logical shape of the frequency representation (and thus the size of the padded input). The origin of the kernel must be at the point <code>(0, floor(fourier_shape[0] / 2.0), ..., floor(fourier_shape[N-1] / 2.0))</code> (i.e. as in a regular kernel except for the first dimension).</p>
<p>The <code>Real</code> type in the declarations can be <code>double</code>, <code>float</code>, and <code>long double</code>. Your program must always link against <code>libfftw3</code>. If you use <code>float</code> or <code>long double</code> arrays, you must <em>additionally</em> link against <code>libfftw3f</code> and <code>libfftw3l</code> respectively.</p>
<p>The Fourier transform functions internally create <a href="http://www.fftw.org/doc/Using-Plans.html">FFTW plans</a> which control the algorithm details. The plans are created with the flag <code>FFTW_ESTIMATE</code>, i.e. optimal settings are guessed or read from saved "wisdom" files. If you need more control over planning, you can use the class <a class="el" href="classvigra_1_1FFTWConvolvePlan.html">FFTWConvolvePlan</a>.</p>
<p>See also <a class="el" href="group__FourierTransform.html#gad51931cfe91ece316e28ff9d7ff28377">applyFourierFilter()</a> for corresponding functionality on the basis of the old image iterator interface.</p>
<p><b> Declarations:</b></p>
<p>Real-valued convolution with kernel in the spatial domain: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT</a>(MultiArrayView&lt;N, Real, C1&gt; in,</div>
<div class="line">                MultiArrayView&lt;N, Real, C2&gt; kernel,</div>
<div class="line">                MultiArrayView&lt;N, Real, C3&gt; out);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Real-valued convolution with kernel in the Fourier domain (half-space format): </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT</a>(MultiArrayView&lt;N, Real, C1&gt; in,</div>
<div class="line">                MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,</div>
<div class="line">                MultiArrayView&lt;N, Real, C3&gt; out);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Series of real-valued convolutions with kernels in the spatial or Fourier domain (the kernel and out sequences must have the same length): </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>Real, <span class="keyword">class </span>C1,</div>
<div class="line">              <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>OutIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gae2598869b328eae9ff709387e0b758a0">convolveFFTMany</a>(MultiArrayView&lt;N, Real, C1&gt; in,</div>
<div class="line">                    KernelIterator kernels, KernelIterator kernelsEnd,</div>
<div class="line">                    OutIterator outs);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Complex-valued convolution (parameter <code>fourierDomainKernel</code> determines if the kernel is defined in the spatial or Fourier domain): </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga014b4e7d6d5154d5ad83170c6cb547f6">convolveFFTComplex</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in,</div>
<div class="line">                       MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,</div>
<div class="line">                       MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C3&gt; out,</div>
<div class="line">                       <span class="keywordtype">bool</span> fourierDomainKernel);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Series of complex-valued convolutions (parameter <code>fourierDomainKernel</code> determines if the kernels are defined in the spatial or Fourier domain, the kernel and out sequences must have the same length): </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>Real, <span class="keyword">class </span>C1,</div>
<div class="line">              <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>OutIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gaf555ec81ad059261e2bb8b5d03a0aa83">convolveFFTComplexMany</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in,</div>
<div class="line">                           KernelIterator kernels, KernelIterator kernelsEnd,</div>
<div class="line">                           OutIterator outs,</div>
<div class="line">                           <span class="keywordtype">bool</span> fourierDomainKernel);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__fft_8hxx_source.html">vigra/multi_fft.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><span class="comment">// convolve real array with a Gaussian (sigma=1) defined in the spatial domain</span></div>
<div class="line"><span class="comment">// (implicitly uses padding by at least 4 pixels)</span></div>
<div class="line">MultiArray&lt;2, double&gt; src(Shape2(w, h)), dest(Shape2(w,h));</div>
<div class="line"></div>
<div class="line">MultiArray&lt;2, double&gt; spatial_kernel(Shape2(9, 9));</div>
<div class="line">Gaussian&lt;double&gt; gauss(1.0);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;9; ++y)</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;9; ++x)</div>
<div class="line">        spatial_kernel(x, y) = gauss(x-4.0)*gauss(y-4.0);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT</a>(src, spatial_kernel, dest);</div>
<div class="line"></div>
<div class="line"><span class="comment">// convolve real array with a Gaussian (sigma=1) defined in the Fourier domain</span></div>
<div class="line"><span class="comment">// (uses no padding, because the kernel size corresponds to the input size)</span></div>
<div class="line">MultiArray&lt;2, FFTWComplex&lt;double&gt; &gt; fourier_kernel(<a class="code" href="group__FourierTransform.html#gafbea828444f49163293b1d81fcd05da8">fftwCorrespondingShapeR2C</a>(src.shape()));</div>
<div class="line"><span class="keywordtype">int</span> y0 = h / 2;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;fourier_kernel.shape(1); ++y)</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;fourier_kernel.shape(0); ++x)</div>
<div class="line">        fourier_kernel(x, y) = <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>(-0.5*<a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e">sq</a>(x / <span class="keywordtype">double</span>(w))) * <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>(-0.5*<a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e">sq</a>((y-y0)/<span class="keywordtype">double</span>(h)));</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT</a>(src, fourier_kernel, dest);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga014b4e7d6d5154d5ad83170c6cb547f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convolveFFTComplex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve a complex-valued array by means of the Fourier transform. </p>
<p>See <a class="el" href="group__ConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT()</a> for details. </p>

</div>
</div>
<a class="anchor" id="gae2598869b328eae9ff709387e0b758a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convolveFFTMany </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve a real-valued array with a sequence of kernels by means of the Fourier transform. </p>
<p>See <a class="el" href="group__ConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT()</a> for details. </p>

</div>
</div>
<a class="anchor" id="gaf555ec81ad059261e2bb8b5d03a0aa83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convolveFFTComplexMany </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve a complex-valued array with a sequence of kernels by means of the Fourier transform. </p>
<p>See <a class="el" href="group__ConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT()</a> for details. </p>

</div>
</div>
<a class="anchor" id="ga3b019af5eba5f0654edde1fe6a0e2c2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::correlateFFT </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlate an array with a kernel by means of the Fourier transform. </p>
<p>This function correlates a real-valued input array with a real-valued kernel such that the result is also real-valued. Thanks to the correlation theorem of Fourier theory, a correlation in the spatial domain is equivalent to a multiplication with the complex conjugate in the frequency domain. Thus, for certain kernels (especially large, non-separable ones), it is advantageous to perform the correlation by first transforming both array and kernel to the frequency domain, multiplying the frequency representations, and transforming the result back into the spatial domain.</p>
<p>The output arrays must have the same shape as the input arrays.</p>
<p>See also <a class="el" href="group__ConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT()</a> for corresponding functionality.</p>
<p><b> Declarations:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga3b019af5eba5f0654edde1fe6a0e2c2b">correlateFFT</a>(MultiArrayView&lt;N, Real, C1&gt; in,</div>
<div class="line">                 MultiArrayView&lt;N, Real, C2&gt; kernel,</div>
<div class="line">                 MultiArrayView&lt;N, Real, C3&gt; out);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__fft_8hxx_source.html">vigra/multi_fft.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><span class="comment">// correlate real array with a template to find best matches</span></div>
<div class="line"><span class="comment">// (implicitly uses padding by at least 4 pixels)</span></div>
<div class="line">MultiArray&lt;2, double&gt; src(Shape2(w, h)), dest(Shape2(w, h));</div>
<div class="line"></div>
<div class="line">MultiArray&lt;2, double&gt; <span class="keyword">template</span>(Shape2(9, 9));</div>
<div class="line"><span class="keyword">template</span> = ...;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga3b019af5eba5f0654edde1fe6a0e2c2b">correlateFFT</a>(src, <span class="keyword">template</span>, dest);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga69ac94967f6044203ebb85d84cc51b84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::normalizedConvolveImage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a 2-dimensional normalized convolution, i.e. convolution with a mask image. </p>
<p>This functions computes <a href="http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/PIRODDI1/NormConv/NormConv.html">normalized convolution</a> as defined in Knutsson, H. and Westin, C-F.: <em>Normalized and differential convolution: Methods for Interpolation and Filtering of incomplete and uncertain data</em>. Proc. of the IEEE Conf. on Computer Vision and Pattern Recognition, 1993, 515-523.</p>
<p>The mask image must be binary and encodes which pixels of the original image are valid. It is used as follows: Only pixel under the mask are used in the calculations. Whenever a part of the kernel lies outside the mask, it is ignored, and the kernel is renormalized to its original norm (analogous to the CLIP <a class="el" href="BorderTreatmentMode.html">BorderTreatmentMode</a>). Thus, a useful convolution result is computed whenever <em>at least one valid pixel is within the current window</em> Thus, destination pixels not under the mask still receive a value if they are <em>near</em> the mask. Therefore, this algorithm is useful as an interpolator of sparse input data. If you are only interested in the destination values under the mask, you can perform a subsequent <a class="el" href="group__CopyAlgo.html#ga6ff922dacba428e319cb0ae2ebbfedd0">copyImageIf()</a>.</p>
<p>The KernelIterator must point to the center of the kernel, and the kernel's size is given by its upper left (x and y of distance &lt;= 0) and lower right (distance &gt;= 0) corners. The image must always be larger than the kernel. At those positions where the kernel does not completely fit into the image, the specified <a class="el" href="BorderTreatmentMode.html">BorderTreatmentMode</a> is applied. Only BORDER_TREATMENT_CLIP and BORDER_TREATMENT_AVOID are currently supported.</p>
<p>The images's pixel type (SrcAccessor::value_type) must be a linear space over the kernel's value_type (KernelAccessor::value_type), i.e. addition of source values, multiplication with kernel values, and NumericTraits must be defined. The kernel's value_type must be an algebraic field, i.e. the arithmetic operations (+, -, *, /) and NumericTraits must be defined.</p>
<p><b> Declarations:</b></p>
<p>pass 2D array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,</div>
<div class="line">              <span class="keyword">class </span>TM, <span class="keyword">class </span>SM,</div>
<div class="line">              <span class="keyword">class </span>T3&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga69ac94967f6044203ebb85d84cc51b84">normalizedConvolveImage</a>(MultiArrayView&lt;2, T1, S1&gt; <span class="keyword">const</span> &amp; src,</div>
<div class="line">                            MultiArrayView&lt;2, TM, SM&gt; <span class="keyword">const</span> &amp; mask,</div>
<div class="line">                            MultiArrayView&lt;2, T2, S2&gt; dest,</div>
<div class="line">                            Kernel2D&lt;T3&gt; <span class="keyword">const</span> &amp; kernel);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="normalizedConvolveImage_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;normalizedConvolveImage_OldAPI&apos;, &apos;normalizedConvolveImage_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="normalizedConvolveImage_OldAPI" style="display:none"> pass <a class="el" href="group__ImageIterators.html">Image Iterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>MaskIterator, <span class="keyword">class </span>MaskAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,</div>
<div class="line">              <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#ga69ac94967f6044203ebb85d84cc51b84">normalizedConvolveImage</a>(SrcIterator src_ul, SrcIterator src_lr, SrcAccessor src_acc,</div>
<div class="line">                            MaskIterator <a class="code" href="group__FixedPointOperations.html#ga71573012351636ef982341cf3eb1d669">mul</a>, MaskAccessor am,</div>
<div class="line">                            DestIterator dest_ul, DestAccessor dest_acc,</div>
<div class="line">                            KernelIterator ki, KernelAccessor ak,</div>
<div class="line">                            Diff2D kul, Diff2D klr, BorderTreatmentMode border);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>MaskIterator, <span class="keyword">class </span>MaskAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,</div>
<div class="line">              <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#ga69ac94967f6044203ebb85d84cc51b84">normalizedConvolveImage</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                                 pair&lt;MaskIterator, MaskAccessor&gt; mask,</div>
<div class="line">                                 pair&lt;DestIterator, DestAccessor&gt; dest,</div>
<div class="line">                                 tuple5&lt;KernelIterator, KernelAccessor, Diff2D, Diff2D,</div>
<div class="line">                                 BorderTreatmentMode&gt; kernel);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="stdconvolution_8hxx_source.html">vigra/stdconvolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArray&lt;2, float&gt;          src(w,h), dest(w,h);</div>
<div class="line">MultiArray&lt;2, unsigned char&gt;  mask(w,h);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// define 3x3 binomial filter</span></div>
<div class="line">vigra::Kernel2D&lt;<span class="keywordtype">float</span>&gt; binom;</div>
<div class="line">binom.initExplicitly(Diff2D(-1,-1), Diff2D(1,1)) =   <span class="comment">// upper left and lower right</span></div>
<div class="line">                     0.0625, 0.125, 0.0625,</div>
<div class="line">                     0.125,  0.25,  0.125,</div>
<div class="line">                     0.0625, 0.125, 0.0625;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga69ac94967f6044203ebb85d84cc51b84">normalizedConvolveImage</a>(src, mask, dest, binom);</div>
</div><!-- fragment --><p><a href="#" id="normalizedConvolveImage_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;normalizedConvolveImage_OldUsage&apos;, &apos;normalizedConvolveImage_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="normalizedConvolveImage_OldUsage" style="display:none"> <div class="fragment"><div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h), dest(w,h);</div>
<div class="line">vigra::CImage mask(w,h);</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// define 3x3 binomial filter</span></div>
<div class="line">vigra::Kernel2D&lt;<span class="keywordtype">float</span>&gt; binom;</div>
<div class="line"></div>
<div class="line">binom.initExplicitly(Diff2D(-1,-1), Diff2D(1,1)) =   <span class="comment">// upper left and lower right</span></div>
<div class="line">                     0.0625, 0.125, 0.0625,</div>
<div class="line">                     0.125,  0.25,  0.125,</div>
<div class="line">                     0.0625, 0.125, 0.0625;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#ga69ac94967f6044203ebb85d84cc51b84">vigra::normalizedConvolveImage</a>(srcImageRange(src), maskImage(mask), destImage(dest), kernel2d(binom));</div>
</div><!-- fragment --><p> <b> Required Interface:</b> </p>
<div class="fragment"><div class="line">ImageIterator src_ul, src_lr;</div>
<div class="line">ImageIterator <a class="code" href="group__FixedPointOperations.html#ga71573012351636ef982341cf3eb1d669">mul</a>;</div>
<div class="line">ImageIterator dest_ul;</div>
<div class="line">ImageIterator ik;</div>
<div class="line"></div>
<div class="line">SrcAccessor src_accessor;</div>
<div class="line">MaskAccessor mask_accessor;</div>
<div class="line">DestAccessor dest_accessor;</div>
<div class="line">KernelAccessor kernel_accessor;</div>
<div class="line"></div>
<div class="line">NumericTraits&lt;SrcAccessor::value_type&gt;::RealPromote s = src_accessor(src_ul);</div>
<div class="line"></div>
<div class="line">s = s + s;</div>
<div class="line">s = kernel_accessor(ik) * s;</div>
<div class="line">s -= s;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span>(mask_accessor(mul)) ...;</div>
<div class="line"></div>
<div class="line">dest_accessor.set(</div>
<div class="line">NumericTraits&lt;DestAccessor::value_type&gt;::fromRealPromote(s), dest_ul);</div>
<div class="line"></div>
<div class="line">NumericTraits&lt;KernelAccessor::value_type&gt;::RealPromote k = kernel_accessor(ik);</div>
<div class="line"></div>
<div class="line">k += k;</div>
<div class="line">k -= k;</div>
<div class="line">k = k / k;</div>
</div><!-- fragment --> </div><p><b> Preconditions:</b></p>
<ul>
<li>
The image must be longer than the kernel radius: <code>w &gt; std::max(kernel.lowerRight().x, -kernel.upperLeft().x)</code> and <code>h &gt; std::max(kernel.lowerRight().y, -kernel.upperLeft().y)</code>. </li>
<li>
The sum of kernel elements must be != 0. </li>
<li>
<code>border == BORDER_TREATMENT_CLIP || border == BORDER_TREATMENT_AVOID</code> </li>
</ul>

</div>
</div>
<a class="anchor" id="gaa1698618c44d0d5d5e0559212519b562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convolveImageWithMask </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated name of 2-dimensional normalized convolution, i.e. convolution with a mask image. </p>
<p>See <a class="el" href="group__ConvolutionFilters.html#ga69ac94967f6044203ebb85d84cc51b84">normalizedConvolveImage()</a> for documentation.</p>
<p><b> Declarations:</b></p>
<p>pass 2D array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>MaskIterator, <span class="keyword">class </span>MaskAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,</div>
<div class="line">              <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gaa1698618c44d0d5d5e0559212519b562">convolveImageWithMask</a>(SrcIterator src_ul, SrcIterator src_lr, SrcAccessor src_acc,</div>
<div class="line">                          MaskIterator mul, MaskAccessor am,</div>
<div class="line">                          DestIterator dest_ul, DestAccessor dest_acc,</div>
<div class="line">                          KernelIterator ki, KernelAccessor ak,</div>
<div class="line">                          Diff2D kul, Diff2D klr, BorderTreatmentMode border);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="convolveImageWithMask_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;convolveImageWithMask_OldAPI&apos;, &apos;convolveImageWithMask_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="convolveImageWithMask_OldAPI" style="display:none"> pass <a class="el" href="group__ImageIterators.html">Image Iterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>MaskIterator, <span class="keyword">class </span>MaskAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,</div>
<div class="line">              <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__ConvolutionFilters.html#gaa1698618c44d0d5d5e0559212519b562">convolveImageWithMask</a>(SrcIterator src_ul, SrcIterator src_lr, SrcAccessor src_acc,</div>
<div class="line">                          MaskIterator mul, MaskAccessor am,</div>
<div class="line">                          DestIterator dest_ul, DestAccessor dest_acc,</div>
<div class="line">                          KernelIterator ki, KernelAccessor ak,</div>
<div class="line">                          Diff2D kul, Diff2D klr, BorderTreatmentMode border);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>MaskIterator, <span class="keyword">class </span>MaskAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,</div>
<div class="line">              <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ConvolutionFilters.html#gaa1698618c44d0d5d5e0559212519b562">convolveImageWithMask</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,</div>
<div class="line">                               pair&lt;MaskIterator, MaskAccessor&gt; mask,</div>
<div class="line">                               pair&lt;DestIterator, DestAccessor&gt; dest,</div>
<div class="line">                               tuple5&lt;KernelIterator, KernelAccessor, Diff2D, Diff2D,</div>
<div class="line">                               BorderTreatmentMode&gt; kernel);</div>
<div class="line">}</div>
</div><!-- fragment --> </div> 
</div>
</div>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.0 (Thu Mar 17 2016)
</i>
</tr>
</table>
</BODY>
</HTML>
