<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - ChunkedArray&lt; N, T &gt; Class Template Reference</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
<script>
var runOnLoad=function(c,o,d,e){function x(){for(e=1;c.length;)c.shift()()}o[d]?(document[d]('DOMContentLoaded',x,0),o[d]('load',x,0)):o.attachEvent('onload',x);return function(t){e?o.setTimeout(t,0):c.push(t)}}([],window,'addEventListener');
</script>
<script type="text/javascript" src="documents/CollapsibleLists.js"></script>
<script type="text/javascript">
    runOnLoad(function(){ CollapsibleLists.apply(); });
</script>
<style type="text/css">
.collapsibleList li.collapsibleListOpen{
  list-style-image:url('documents/pfeil.gif');
  cursor:pointer;
}
.collapsibleList li.collapsibleListClosed{
  list-style-image:url('documents/bullet.gif');
  cursor:pointer;
}
.collapsibleList li.lastItem{
  list-style-image:url('documents/diamond.gif');
}
</style>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://ukoethe.github.io/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">ChunkedArray&lt; N, T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__ChunkedArrayClasses.html">Chunked arrays</a> &#124; <a class="el" href="group__MultiIteratorGroup.html">Multi-dimensional Shapes and Array Iterators</a></div>
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>


<p>Interface and base class for chunked arrays.  
 <a href="classvigra_1_1ChunkedArray.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="multi__array__chunked_8hxx_source.html">vigra/multi_array_chunked.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ChunkedArray&lt; N, T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvigra_1_1ChunkedArray.png" usemap="#ChunkedArray&lt; N, T &gt;_map" alt=""/>
  <map id="ChunkedArray&lt; N, T &gt;_map" name="ChunkedArray&lt; N, T &gt;_map">
<area href="classvigra_1_1ChunkedArrayCompressed.html" alt="ChunkedArrayCompressed&lt; N, T, Alloc &gt;" shape="rect" coords="0,56,252,80"/>
<area href="classvigra_1_1ChunkedArrayFull.html" alt="ChunkedArrayFull&lt; N, T, Alloc &gt;" shape="rect" coords="262,56,514,80"/>
<area href="classvigra_1_1ChunkedArrayHDF5.html" alt="ChunkedArrayHDF5&lt; N, T, Alloc &gt;" shape="rect" coords="524,56,776,80"/>
<area href="classvigra_1_1ChunkedArrayLazy.html" alt="ChunkedArrayLazy&lt; N, T, Alloc &gt;" shape="rect" coords="786,56,1038,80"/>
<area href="classvigra_1_1ChunkedArrayTmpFile.html" alt="ChunkedArrayTmpFile&lt; N, T &gt;" shape="rect" coords="1048,56,1300,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a16969b82d60716e33d0ab6d9743c7cd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16969b82d60716e33d0ab6d9743c7cd3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a16969b82d60716e33d0ab6d9743c7cd3">backend</a> () const </td></tr>
<tr class="memdesc:a16969b82d60716e33d0ab6d9743c7cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the class that implements this <a class="el" href="classvigra_1_1ChunkedArray.html" title="Interface and base class for chunked arrays. ">ChunkedArray</a>. <br/></td></tr>
<tr class="separator:a16969b82d60716e33d0ab6d9743c7cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69bd11391be1a1dba5c8202259664f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad69bd11391be1a1dba5c8202259664f8"></a>
<a class="el" href="classvigra_1_1StridedScanOrderIterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#ad69bd11391be1a1dba5c8202259664f8">begin</a> ()</td></tr>
<tr class="memdesc:ad69bd11391be1a1dba5c8202259664f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scan-order iterator for the entire chunked array. <br/></td></tr>
<tr class="separator:ad69bd11391be1a1dba5c8202259664f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b02d4f1a8500fb07a551069060709f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4b02d4f1a8500fb07a551069060709f"></a>
<a class="el" href="classvigra_1_1StridedScanOrderIterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#aa4b02d4f1a8500fb07a551069060709f">begin</a> () const </td></tr>
<tr class="memdesc:aa4b02d4f1a8500fb07a551069060709f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a read-only scan-order iterator for the entire chunked array. <br/></td></tr>
<tr class="separator:aa4b02d4f1a8500fb07a551069060709f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5886ba94688ac8fbb3df80374bd1ae86"><td class="memTemplParams" colspan="2">template&lt;unsigned int M&gt; </td></tr>
<tr class="memitem:a5886ba94688ac8fbb3df80374bd1ae86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N-1, T, <br class="typebreak"/>
<a class="el" href="structvigra_1_1ChunkedArrayTag.html">ChunkedArrayTag</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a5886ba94688ac8fbb3df80374bd1ae86">bind</a> (difference_type_1 index) const </td></tr>
<tr class="memdesc:a5886ba94688ac8fbb3df80374bd1ae86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a lower dimensional view to the chunked array.  <a href="#a5886ba94688ac8fbb3df80374bd1ae86">More...</a><br/></td></tr>
<tr class="separator:a5886ba94688ac8fbb3df80374bd1ae86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7656ac1635efc43562454b77bb1686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N-1, T, <br class="typebreak"/>
<a class="el" href="structvigra_1_1ChunkedArrayTag.html">ChunkedArrayTag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#aac7656ac1635efc43562454b77bb1686">bindAt</a> (<a class="el" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> dim, <a class="el" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a> index) const </td></tr>
<tr class="memdesc:aac7656ac1635efc43562454b77bb1686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a lower dimensional view to the chunked array.  <a href="#aac7656ac1635efc43562454b77bb1686">More...</a><br/></td></tr>
<tr class="separator:aac7656ac1635efc43562454b77bb1686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294816822d9380996316168f6312f4bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N-1, T, <br class="typebreak"/>
<a class="el" href="structvigra_1_1ChunkedArrayTag.html">ChunkedArrayTag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a294816822d9380996316168f6312f4bc">bindInner</a> (difference_type_1 index) const </td></tr>
<tr class="memdesc:a294816822d9380996316168f6312f4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a lower dimensional view to the chunked array.  <a href="#a294816822d9380996316168f6312f4bc">More...</a><br/></td></tr>
<tr class="separator:a294816822d9380996316168f6312f4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ab037e305598d8ea8bbac16a71807a"><td class="memTemplParams" colspan="2">template&lt;int M, class Index &gt; </td></tr>
<tr class="memitem:a22ab037e305598d8ea8bbac16a71807a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N-M, T, <br class="typebreak"/>
<a class="el" href="structvigra_1_1ChunkedArrayTag.html">ChunkedArrayTag</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a22ab037e305598d8ea8bbac16a71807a">bindInner</a> (const <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; Index, M &gt; &amp;d) const </td></tr>
<tr class="memdesc:a22ab037e305598d8ea8bbac16a71807a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a lower dimensional view to the chunked array.  <a href="#a22ab037e305598d8ea8bbac16a71807a">More...</a><br/></td></tr>
<tr class="separator:a22ab037e305598d8ea8bbac16a71807a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add30b0027bada67ebc6999ef3850c55e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N-1, T, <br class="typebreak"/>
<a class="el" href="structvigra_1_1ChunkedArrayTag.html">ChunkedArrayTag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#add30b0027bada67ebc6999ef3850c55e">bindOuter</a> (difference_type_1 index) const </td></tr>
<tr class="memdesc:add30b0027bada67ebc6999ef3850c55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a lower dimensional view to the chunked array.  <a href="#add30b0027bada67ebc6999ef3850c55e">More...</a><br/></td></tr>
<tr class="separator:add30b0027bada67ebc6999ef3850c55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dba669bfee607fb5aed178db5309f5"><td class="memTemplParams" colspan="2">template&lt;int M, class Index &gt; </td></tr>
<tr class="memitem:ae7dba669bfee607fb5aed178db5309f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N-M, T, <br class="typebreak"/>
<a class="el" href="structvigra_1_1ChunkedArrayTag.html">ChunkedArrayTag</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#ae7dba669bfee607fb5aed178db5309f5">bindOuter</a> (const <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; Index, M &gt; &amp;d) const </td></tr>
<tr class="memdesc:ae7dba669bfee607fb5aed178db5309f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a lower dimensional view to the chunked array.  <a href="#ae7dba669bfee607fb5aed178db5309f5">More...</a><br/></td></tr>
<tr class="separator:ae7dba669bfee607fb5aed178db5309f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d67c6bf9ccf27995db928bf861afde"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#ad7d67c6bf9ccf27995db928bf861afde">cacheMaxSize</a> () const </td></tr>
<tr class="memdesc:ad7d67c6bf9ccf27995db928bf861afde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of chunks the cache will hold.  <a href="#ad7d67c6bf9ccf27995db928bf861afde">More...</a><br/></td></tr>
<tr class="separator:ad7d67c6bf9ccf27995db928bf861afde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ca39a30eda562399b5f361f882ef0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5ca39a30eda562399b5f361f882ef0f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#ae5ca39a30eda562399b5f361f882ef0f">cacheSize</a> () const </td></tr>
<tr class="memdesc:ae5ca39a30eda562399b5f361f882ef0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of chunks currently fitting into the cache. <br/></td></tr>
<tr class="separator:ae5ca39a30eda562399b5f361f882ef0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbe5a8d1c228764829c9826cfe48910"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcbe5a8d1c228764829c9826cfe48910"></a>
<a class="el" href="classvigra_1_1StridedScanOrderIterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#abcbe5a8d1c228764829c9826cfe48910">cbegin</a> () const </td></tr>
<tr class="memdesc:abcbe5a8d1c228764829c9826cfe48910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a read-only scan-order iterator for the entire chunked array. <br/></td></tr>
<tr class="separator:abcbe5a8d1c228764829c9826cfe48910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ed5283a097925e2c2f96e6daae6a80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02ed5283a097925e2c2f96e6daae6a80"></a>
<a class="el" href="classvigra_1_1StridedScanOrderIterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a02ed5283a097925e2c2f96e6daae6a80">cend</a> () const </td></tr>
<tr class="memdesc:a02ed5283a097925e2c2f96e6daae6a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the end iterator for read-only scan-order iteration over the entire chunked array. <br/></td></tr>
<tr class="separator:a02ed5283a097925e2c2f96e6daae6a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fbc0c9f44d6070bf7072884d68cb43"><td class="memTemplParams" colspan="2">template&lt;class U , class Stride &gt; </td></tr>
<tr class="memitem:af1fbc0c9f44d6070bf7072884d68cb43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#af1fbc0c9f44d6070bf7072884d68cb43">checkoutSubarray</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;start, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N, U, Stride &gt; &amp;<a class="el" href="classvigra_1_1ChunkedArray.html#ac3de45b70c5d89ed7fb65bc308523da9">subarray</a>) const </td></tr>
<tr class="memdesc:af1fbc0c9f44d6070bf7072884d68cb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an ROI of the chunked array into an ordinary <a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray. ">MultiArrayView</a>.  <a href="#af1fbc0c9f44d6070bf7072884d68cb43">More...</a><br/></td></tr>
<tr class="separator:af1fbc0c9f44d6070bf7072884d68cb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4789ad138ea261ba36487c8e8bf56cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4789ad138ea261ba36487c8e8bf56cf"></a>
chunk_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#af4789ad138ea261ba36487c8e8bf56cf">chunk_begin</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;start, <a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;stop)</td></tr>
<tr class="memdesc:af4789ad138ea261ba36487c8e8bf56cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an iterator over all chunks intersected by the given ROI. <br/></td></tr>
<tr class="separator:af4789ad138ea261ba36487c8e8bf56cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1c6b7e6401d4dc28b9951b064fc9c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc1c6b7e6401d4dc28b9951b064fc9c3"></a>
chunk_const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#abc1c6b7e6401d4dc28b9951b064fc9c3">chunk_begin</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;start, <a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;stop) const </td></tr>
<tr class="memdesc:abc1c6b7e6401d4dc28b9951b064fc9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a read-only iterator over all chunks intersected by the given ROI. <br/></td></tr>
<tr class="separator:abc1c6b7e6401d4dc28b9951b064fc9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b39b18ea139b6e54024c667b8d91f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3b39b18ea139b6e54024c667b8d91f8"></a>
chunk_const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#ac3b39b18ea139b6e54024c667b8d91f8">chunk_cbegin</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;start, <a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;stop) const </td></tr>
<tr class="memdesc:ac3b39b18ea139b6e54024c667b8d91f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a read-only iterator over all chunks intersected by the given ROI. <br/></td></tr>
<tr class="separator:ac3b39b18ea139b6e54024c667b8d91f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfd8bf26d024481ab612a64e9605af8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bfd8bf26d024481ab612a64e9605af8"></a>
chunk_const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a2bfd8bf26d024481ab612a64e9605af8">chunk_cend</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;start, <a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;stop) const </td></tr>
<tr class="memdesc:a2bfd8bf26d024481ab612a64e9605af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the end iterator for read-only iteration over all chunks intersected by the given ROI. <br/></td></tr>
<tr class="separator:a2bfd8bf26d024481ab612a64e9605af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674f8fe9466fd09c2e4bc6d34cffbc4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a674f8fe9466fd09c2e4bc6d34cffbc4b"></a>
chunk_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a674f8fe9466fd09c2e4bc6d34cffbc4b">chunk_end</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;start, <a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;stop)</td></tr>
<tr class="memdesc:a674f8fe9466fd09c2e4bc6d34cffbc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the end iterator for iteration over all chunks intersected by the given ROI. <br/></td></tr>
<tr class="separator:a674f8fe9466fd09c2e4bc6d34cffbc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d9d2951fb9335ad89aec5240b102e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1d9d2951fb9335ad89aec5240b102e5"></a>
chunk_const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#aa1d9d2951fb9335ad89aec5240b102e5">chunk_end</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;start, <a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;stop) const </td></tr>
<tr class="memdesc:aa1d9d2951fb9335ad89aec5240b102e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the end iterator for read-only iteration over all chunks intersected by the given ROI. <br/></td></tr>
<tr class="separator:aa1d9d2951fb9335ad89aec5240b102e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c5efce7b89ed0caaa26bdd96439412"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5c5efce7b89ed0caaa26bdd96439412"></a>
virtual <a class="el" href="classvigra_1_1TinyVector.html">shape_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#ab5c5efce7b89ed0caaa26bdd96439412">chunkArrayShape</a> () const </td></tr>
<tr class="memdesc:ab5c5efce7b89ed0caaa26bdd96439412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of chunks along each coordinate direction. <br/></td></tr>
<tr class="separator:ab5c5efce7b89ed0caaa26bdd96439412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b28ad3f3d701435396bc1ad42ee88a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a6b28ad3f3d701435396bc1ad42ee88a2">chunkShape</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;chunk_index) const </td></tr>
<tr class="memdesc:a6b28ad3f3d701435396bc1ad42ee88a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the shape of the chunk indexed by 'chunk_index'.  <a href="#a6b28ad3f3d701435396bc1ad42ee88a2">More...</a><br/></td></tr>
<tr class="separator:a6b28ad3f3d701435396bc1ad42ee88a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298cc634e6bcc748a7ebee5e7dff7d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a298cc634e6bcc748a7ebee5e7dff7d0c">chunkShape</a> () const </td></tr>
<tr class="memdesc:a298cc634e6bcc748a7ebee5e7dff7d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global chunk shape.  <a href="#a298cc634e6bcc748a7ebee5e7dff7d0c">More...</a><br/></td></tr>
<tr class="separator:a298cc634e6bcc748a7ebee5e7dff7d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa307f1d6625445924bbca45a6dfdfc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa307f1d6625445924bbca45a6dfdfc0"></a>
<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#aaa307f1d6625445924bbca45a6dfdfc0">chunkStart</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;global_start) const </td></tr>
<tr class="memdesc:aaa307f1d6625445924bbca45a6dfdfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the chunk that contains array element 'global_start'. <br/></td></tr>
<tr class="separator:aaa307f1d6625445924bbca45a6dfdfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617e7306ca16891bdcb59d4da741cd5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a617e7306ca16891bdcb59d4da741cd5d">chunkStop</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> global_stop) const </td></tr>
<tr class="memdesc:a617e7306ca16891bdcb59d4da741cd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the chunk that is beyond array element 'global_stop'.  <a href="#a617e7306ca16891bdcb59d4da741cd5d">More...</a><br/></td></tr>
<tr class="separator:a617e7306ca16891bdcb59d4da741cd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95c2df02bc2bf51b61e2ba58fbdd81b"><td class="memTemplParams" colspan="2">template&lt;class U , class Stride &gt; </td></tr>
<tr class="memitem:af95c2df02bc2bf51b61e2ba58fbdd81b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#af95c2df02bc2bf51b61e2ba58fbdd81b">commitSubarray</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;start, <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N, U, Stride &gt; const &amp;<a class="el" href="classvigra_1_1ChunkedArray.html#ac3de45b70c5d89ed7fb65bc308523da9">subarray</a>)</td></tr>
<tr class="memdesc:af95c2df02bc2bf51b61e2ba58fbdd81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an ordinary <a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray. ">MultiArrayView</a> into an ROI of the chunked array.  <a href="#af95c2df02bc2bf51b61e2ba58fbdd81b">More...</a><br/></td></tr>
<tr class="separator:af95c2df02bc2bf51b61e2ba58fbdd81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092202efae947078733521a73609ecfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1MultiArrayView.html">const_view_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a092202efae947078733521a73609ecfb">const_subarray</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;start, <a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;stop) const </td></tr>
<tr class="memdesc:a092202efae947078733521a73609ecfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a read-only view to the specified ROI.  <a href="#a092202efae947078733521a73609ecfb">More...</a><br/></td></tr>
<tr class="separator:a092202efae947078733521a73609ecfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7442a44033d2f1430655981cd08a429e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a7442a44033d2f1430655981cd08a429e">dataBytes</a> () const </td></tr>
<tr class="memdesc:a7442a44033d2f1430655981cd08a429e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bytes of main memory occupied by the array's data.  <a href="#a7442a44033d2f1430655981cd08a429e">More...</a><br/></td></tr>
<tr class="separator:a7442a44033d2f1430655981cd08a429e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0be6870e551fb19ccb019cfa230fd8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0be6870e551fb19ccb019cfa230fd8e"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#af0be6870e551fb19ccb019cfa230fd8e">dataBytesPerChunk</a> () const </td></tr>
<tr class="memdesc:af0be6870e551fb19ccb019cfa230fd8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of data bytes in an uncompressed chunk. <br/></td></tr>
<tr class="separator:af0be6870e551fb19ccb019cfa230fd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad38d52497a975bfb6f2f6acd76631f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acad38d52497a975bfb6f2f6acd76631f"></a>
<a class="el" href="classvigra_1_1StridedScanOrderIterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#acad38d52497a975bfb6f2f6acd76631f">end</a> ()</td></tr>
<tr class="memdesc:acad38d52497a975bfb6f2f6acd76631f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the end iterator for scan-order iteration over the entire chunked array. <br/></td></tr>
<tr class="separator:acad38d52497a975bfb6f2f6acd76631f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350132543d80a1c1e5be844e6d2878ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a350132543d80a1c1e5be844e6d2878ea"></a>
<a class="el" href="classvigra_1_1StridedScanOrderIterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a350132543d80a1c1e5be844e6d2878ea">end</a> () const </td></tr>
<tr class="memdesc:a350132543d80a1c1e5be844e6d2878ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the end iterator for read-only scan-order iteration over the entire chunked array. <br/></td></tr>
<tr class="separator:a350132543d80a1c1e5be844e6d2878ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb43aee2dd30ad3b38ef8132a8db9384"><td class="memItemLeft" align="right" valign="top">value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#adb43aee2dd30ad3b38ef8132a8db9384">getItem</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;point) const </td></tr>
<tr class="memdesc:adb43aee2dd30ad3b38ef8132a8db9384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the array element at index 'point'.  <a href="#adb43aee2dd30ad3b38ef8132a8db9384">More...</a><br/></td></tr>
<tr class="separator:adb43aee2dd30ad3b38ef8132a8db9384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d67ba1869adc5e308348d3d1d3adbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1d67ba1869adc5e308348d3d1d3adbb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#ab1d67ba1869adc5e308348d3d1d3adbb">isInside</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;p) const </td></tr>
<tr class="memdesc:ab1d67ba1869adc5e308348d3d1d3adbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given point is in the array domain. <br/></td></tr>
<tr class="separator:ab1d67ba1869adc5e308348d3d1d3adbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018c002f23f0985c9ca89cd0a244f59d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a018c002f23f0985c9ca89cd0a244f59d"></a>
template&lt;class U , class C1 &gt; </td></tr>
<tr class="memitem:a018c002f23f0985c9ca89cd0a244f59d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a018c002f23f0985c9ca89cd0a244f59d">operator!=</a> (<a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N, U, C1 &gt; const &amp;rhs) const </td></tr>
<tr class="memdesc:a018c002f23f0985c9ca89cd0a244f59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two arrays differ in at least one element. <br/></td></tr>
<tr class="separator:a018c002f23f0985c9ca89cd0a244f59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2799b196fd761fc6d5313cf374f2b5a"><td class="memTemplParams" colspan="2"><a class="anchor" id="af2799b196fd761fc6d5313cf374f2b5a"></a>
template&lt;class U , class C1 &gt; </td></tr>
<tr class="memitem:af2799b196fd761fc6d5313cf374f2b5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#af2799b196fd761fc6d5313cf374f2b5a">operator==</a> (<a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N, U, C1 &gt; const &amp;rhs) const </td></tr>
<tr class="memdesc:af2799b196fd761fc6d5313cf374f2b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two arrays are elementwise equal. <br/></td></tr>
<tr class="separator:af2799b196fd761fc6d5313cf374f2b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9122ced2cc1cf49e04645e9cda203bfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9122ced2cc1cf49e04645e9cda203bfb"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a9122ced2cc1cf49e04645e9cda203bfb">overheadBytes</a> () const </td></tr>
<tr class="memdesc:a9122ced2cc1cf49e04645e9cda203bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bytes of main memory needed to manage the chunked storage. <br/></td></tr>
<tr class="separator:a9122ced2cc1cf49e04645e9cda203bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9956e140d2de708c5d876d0e45b2aa20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9956e140d2de708c5d876d0e45b2aa20"></a>
virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a9956e140d2de708c5d876d0e45b2aa20">overheadBytesPerChunk</a> () const =0</td></tr>
<tr class="memdesc:a9956e140d2de708c5d876d0e45b2aa20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bytes of main memory needed to manage a single chunk. <br/></td></tr>
<tr class="separator:a9956e140d2de708c5d876d0e45b2aa20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09aa30c72793c85e16c4e29a2774e9fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a09aa30c72793c85e16c4e29a2774e9fc">releaseChunks</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;start, <a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;stop, bool destroy=false)</td></tr>
<tr class="separator:a09aa30c72793c85e16c4e29a2774e9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b502a2b9970e599ee8cbc82a2b4abaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a1b502a2b9970e599ee8cbc82a2b4abaf">setCacheMaxSize</a> (std::size_t c)</td></tr>
<tr class="memdesc:a1b502a2b9970e599ee8cbc82a2b4abaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of chunks the cache will hold.  <a href="#a1b502a2b9970e599ee8cbc82a2b4abaf">More...</a><br/></td></tr>
<tr class="separator:a1b502a2b9970e599ee8cbc82a2b4abaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e96d7344bc15a037644a43d837ca7ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a4e96d7344bc15a037644a43d837ca7ae">setItem</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;point, value_type const &amp;v)</td></tr>
<tr class="memdesc:a4e96d7344bc15a037644a43d837ca7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the array element at index 'point'.  <a href="#a4e96d7344bc15a037644a43d837ca7ae">More...</a><br/></td></tr>
<tr class="separator:a4e96d7344bc15a037644a43d837ca7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061df318877277056b594eb521849f03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a061df318877277056b594eb521849f03"></a>
<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a061df318877277056b594eb521849f03">shape</a> () const </td></tr>
<tr class="memdesc:a061df318877277056b594eb521849f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the shape in this array. <br/></td></tr>
<tr class="separator:a061df318877277056b594eb521849f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd2394aa66127a1f347c80abd3da783"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadd2394aa66127a1f347c80abd3da783"></a>
<a class="el" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#aadd2394aa66127a1f347c80abd3da783">size</a> () const </td></tr>
<tr class="memdesc:aadd2394aa66127a1f347c80abd3da783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in this array. <br/></td></tr>
<tr class="separator:aadd2394aa66127a1f347c80abd3da783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3de45b70c5d89ed7fb65bc308523da9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1MultiArrayView.html">view_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#ac3de45b70c5d89ed7fb65bc308523da9">subarray</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;start, <a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;stop)</td></tr>
<tr class="memdesc:ac3de45b70c5d89ed7fb65bc308523da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a view to the specified ROI.  <a href="#ac3de45b70c5d89ed7fb65bc308523da9">More...</a><br/></td></tr>
<tr class="separator:ac3de45b70c5d89ed7fb65bc308523da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090ef1ecc26fa050f5da17d163eecc34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvigra_1_1MultiArrayView.html">const_view_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ChunkedArray.html#a090ef1ecc26fa050f5da17d163eecc34">subarray</a> (<a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;start, <a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;stop) const </td></tr>
<tr class="memdesc:a090ef1ecc26fa050f5da17d163eecc34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a read-only view to the specified ROI.  <a href="#a090ef1ecc26fa050f5da17d163eecc34">More...</a><br/></td></tr>
<tr class="separator:a090ef1ecc26fa050f5da17d163eecc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<div class="textblock"><h3>template&lt;unsigned int N, class T&gt;<br/>
class vigra::ChunkedArray&lt; N, T &gt;</h3>

<p>Interface and base class for chunked arrays. </p>
<p>Very big data arrays (possibly bigger than the available RAM) can only be processed in smaller pieces. To support quick access to these pieces, it is advantegeous to store big arrays in chunks, i.e. as a collection of small rectagular subarrays. The class <a class="el" href="classvigra_1_1ChunkedArray.html" title="Interface and base class for chunked arrays. ">ChunkedArray</a> encapsulates storage and handling of these chunks and provides various APIs to easily access the data.</p>
<p><b>#include</b> &lt;<a class="el" href="multi__array__chunked_8hxx_source.html">vigra/multi_array_chunked.hxx</a>&gt; <br/>
 Namespace: vigra</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the array dimension </td></tr>
    <tr><td class="paramname">T</td><td>the type of the array elements</td></tr>
  </table>
  </dd>
</dl>
<p>(these are the same as in <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>). The actual way of chunk storage is determined by the derived class the program uses:</p>
<ul>
<li>
<p class="startli"><a class="el" href="classvigra_1_1ChunkedArrayFull.html">ChunkedArrayFull</a>: Provides the chunked array API for a standard <a class="el" href="classvigra_1_1MultiArray.html">MultiArray</a> (i.e. there is only one chunk for the entire array).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classvigra_1_1ChunkedArrayLazy.html">ChunkedArrayLazy</a>: All chunks reside in memory, but are only allocated upon first access.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classvigra_1_1ChunkedArrayCompressed.html">ChunkedArrayCompressed</a>: Like <a class="el" href="classvigra_1_1ChunkedArrayLazy.html">ChunkedArrayLazy</a>, but temporarily unused chunks are compressed in memory to save space.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classvigra_1_1ChunkedArrayTmpFile.html">ChunkedArrayTmpFile</a>: Chunks are stored in a memory-mapped file. Temporarily unused chunks are written to the hard-drive and deleted from memory.</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="classvigra_1_1ChunkedArrayHDF5.html">ChunkedArrayHDF5</a>: Chunks are stored in a HDF5 dataset by means of HDF5's native chunked storage capabilities. Temporarily unused chunks are written to the hard-drive in compressed form and deleted from memory. </li>
</ul>
<p>You must use these derived classes to construct a chunked array because <a class="el" href="classvigra_1_1ChunkedArray.html" title="Interface and base class for chunked arrays. ">ChunkedArray</a> itself is an abstract class.</p>
<p>Chunks can be in one of the following states: </p>
<ul>
<li>
<p class="startli">uninitialized: Chunks are only initialized (i.e. allocated) upon the first write access. If an uninitialized chunk is accessed in a read-only manner, the system returns a pseudo-chunk whose elements have a user-provided fill value.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">asleep: The chunk is currently unused and has been compressed and/or swapped out to the hard drive.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">inactive: The chunk is currently unused, but still resides in memory.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">active: The chunk resides in memory and is currently in use.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">locked: Chunks are briefly in this state during transitions between the other states (e.g. while loading and/or decompression is in progress).</p>
<p class="endli"></p>
</li>
<li>
failed: An unexpected error occured, e.g. the system is out of memory or a write to the hard drive failed. </li>
</ul>
<p>In-memory chunks (active and inactive) are placed in a cache. If a chunk transitions from the 'asleep' to the 'active' state, it is added to the cache, and an 'inactive' chunk is removed and sent 'asleep'. If there is no 'inactive' chunk in the cache, the cache size is temporarily increased. All state transitions are thread-safe.</p>
<p>In order to optimize performance, the user should adjust the cache size (via <a class="el" href="classvigra_1_1ChunkedArray.html#a1b502a2b9970e599ee8cbc82a2b4abaf">setCacheMaxSize()</a> or <a class="el" href="classvigra_1_1ChunkedArrayOptions.html">ChunkedArrayOptions</a>) so that it can hold all chunks that are frequently needed (e.g. all chunks forming a row of the full array).</p>
<p>Another performance critical parameter is the chunk shape. While the system uses sensible defaults (512<sup>2</sup> for 2D arrays, 64<sup>3</sup> for 3D, 64x64x16x4 for 4D, and 64x64x16x4x4 for 5D), the shape may need to be adjusted via the array's constructor to match the access patterns of the algorithms to be used. For speed reasons, chunk shapes must be powers of 2.</p>
<p>The data in the array can be accessed in several ways. The simplest is via calls to <code><a class="el" href="classvigra_1_1ChunkedArray.html#af1fbc0c9f44d6070bf7072884d68cb43" title="Copy an ROI of the chunked array into an ordinary MultiArrayView. ">checkoutSubarray()</a></code> and <code><a class="el" href="classvigra_1_1ChunkedArray.html#af95c2df02bc2bf51b61e2ba58fbdd81b" title="Copy an ordinary MultiArrayView into an ROI of the chunked array. ">commitSubarray()</a></code>: These functions copy an arbitrary subregion of a chunked array (possibly straddling many chunks) into a standard <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a> for processing, and write results back into the chunked array: </p>
<div class="fragment"><div class="line">ChunkedArray&lt;3, float&gt; &amp; chunked_array = ...;</div>
<div class="line"></div>
<div class="line">Shape3 roi_start(1000, 500, 500);</div>
<div class="line">MultiArray&lt;3, float&gt; work_array(Shape3(100, 100, 100));</div>
<div class="line"></div>
<div class="line"><span class="comment">// copy data from region (1000,500,500)...(1100,600,600)</span></div>
<div class="line">chunked_array.checkoutSubarray(roi_start, work_array);</div>
<div class="line"></div>
<div class="line">... <span class="comment">// work phase: process data in work_array as usual</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// write results back into chunked_array</span></div>
<div class="line">chunked_array.commitSubarray(roi_start, work_array);</div>
</div><!-- fragment --><p> The required chunks in <code>chunked_array</code> will only be active while the checkout and commit calls are executing. During the work phase, other threads can use the chunked array's cache to checkout or commit different subregions.</p>
<p>Alternatively, one can work directly on the chunk storage. This is most easily achieved by means of chunk iterators: </p>
<div class="fragment"><div class="line">ChunkedArray&lt;3, float&gt; &amp; chunked_array = ...;</div>
<div class="line"></div>
<div class="line"><span class="comment">// define the ROI to be processed</span></div>
<div class="line">Shape3 roi_start(100, 200, 300), roi_end(1000, 2000, 600);</div>
<div class="line"></div>
<div class="line"><span class="comment">// get a pair of chunk iterators ( = iterators over chunks)</span></div>
<div class="line"><span class="keyword">auto</span> chunk = chunked_array.chunk_begin(roi_start, roi_end),</div>
<div class="line">     end   = chunked_array.chunk_end(roi_start, roi_end);</div>
<div class="line"></div>
<div class="line"><span class="comment">// iterate over the chunks in the ROI</span></div>
<div class="line"><span class="keywordflow">for</span>(; chunk != <a class="code" href="classvigra_1_1ChunkedArray.html#acad38d52497a975bfb6f2f6acd76631f">end</a>; ++chunk)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// get a view to the current chunk&#39;s data</span></div>
<div class="line">    <span class="comment">// Note: The view actually refers to the intersection of the</span></div>
<div class="line">    <span class="comment">//       current chunk with the ROI. Thus, chunks which are</span></div>
<div class="line">    <span class="comment">//       partially outside the ROI are appropriately trimmed.</span></div>
<div class="line">    MultiArrayView&lt;3, float&gt; chunk_view = *chunk;</div>
<div class="line"></div>
<div class="line">    ... <span class="comment">// work phase: process data in chunk_view as usual</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> No memory is duplicated in this approach, and only the current chunk needs to be active, so that a small chunk cache is sufficient. The iteration over chunks can be distributed over several threads that process the array data in parallel. The programmer must make sure that write operations to individual elements are synchronized between threads. This is usually achieved by ensuring that the threads are responsible for non-overlapping regions of the output array.</p>
<p>An even simpler method is direct element access via indexing. However, the chunked array has no control over the access order in this case, so it must potentially activate the present chunk upon each access. This is rather expensive and should only be used for debugging: </p>
<div class="fragment"><div class="line">ChunkedArray&lt;3, float&gt; &amp; chunked_array = ...;</div>
<div class="line"></div>
<div class="line">Shape3 index(100, 200, 300);</div>
<div class="line"><span class="comment">// access data at coordinate &#39;index&#39;</span></div>
<div class="line">chunked_array.setItem(index, chunked_array.getItem(index) + 2.0);</div>
</div><!-- fragment --><p>Two additional APIs provide access in a way compatible with an ordinary <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>. These APIs should be used in functions that are supposed to work unchanged on both ordinary and chunked arrays. The first possibility is the chunked scan-order iterator: </p>
<div class="fragment"><div class="line">ChunkedArray&lt;3, float&gt; &amp; chunked_array = ...;</div>
<div class="line"></div>
<div class="line"><span class="comment">// get a pair of scan-order iterators ( = iterators over elements)</span></div>
<div class="line"><span class="keyword">auto</span> iter = chunked_array.begin(),</div>
<div class="line">     end  = chunked_array.end();</div>
<div class="line"></div>
<div class="line"><span class="comment">// iterate over all array elements</span></div>
<div class="line"><span class="keywordflow">for</span>(; iter != <a class="code" href="classvigra_1_1ChunkedArray.html#acad38d52497a975bfb6f2f6acd76631f">end</a>; ++iter)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// access current element</span></div>
<div class="line">     iter = *iter + 2.0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> A new chunk must potentially be activated whenever the iterator crosses a chunk boundary. Since the overhead of the activation operation can be amortized over many within-chunk steps, the iteration (excluding the workload within the loop) takes only twice as long as the iteration over an unstrided array using an ordinary <a class="el" href="classvigra_1_1StridedScanOrderIterator.html">StridedScanOrderIterator</a>.</p>
<p>The final possibility is the creation of a <a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray. ">MultiArrayView</a> that accesses an arbitrary ROI directly: </p>
<div class="fragment"><div class="line">ChunkedArray&lt;3, float&gt; &amp; chunked_array = ...;</div>
<div class="line"></div>
<div class="line"><span class="comment">// define the ROI to be processed</span></div>
<div class="line">Shape3 roi_start(100, 200, 300), roi_end(1000, 2000, 600);</div>
<div class="line"></div>
<div class="line"><span class="comment">// create view for ROI</span></div>
<div class="line">MultiArrayView&lt;3, float, ChunkedArrayTag&gt; view =</div>
<div class="line">                chunked_array.subarray(roi_start, roi_stop);</div>
<div class="line"></div>
<div class="line">... <span class="comment">// work phase: process view like any ordinary MultiArrayView</span></div>
</div><!-- fragment --><p> Similarly, a lower-dimensional view can be created with one of the <code>bind</code> functions. This approach has the advantage that 'view' can be passed to any function which is implemented in terms of MultiArrayViews. However, there are two disadvantages: First, data access in the view requires two steps (first find the chunk, then find the appropriate element in the chunk), which causes the chunked view to be slower than an ordinary <a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray. ">MultiArrayView</a>. Second, all chunks intersected by the view must remain active throughout the view's lifetime, which may require a big chunk cache and thus keeps many chunks in memory. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7442a44033d2f1430655981cd08a429e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t dataBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bytes of main memory occupied by the array's data. </p>
<p>Compressed chunks are only counted with their compressed size. Chunks swapped out to the hard drive are not counted. </p>

</div>
</div>
<a class="anchor" id="a617e7306ca16891bdcb59d4da741cd5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> chunkStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a>&#160;</td>
          <td class="paramname"><em>global_stop</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the chunk that is beyond array element 'global_stop'. </p>
<p>Specifically, this computes </p>
<div class="fragment"><div class="line"><a class="code" href="classvigra_1_1ChunkedArray.html#aaa307f1d6625445924bbca45a6dfdfc0">chunkStart</a>(global_stop - shape_type(1)) + shape_type(1)</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a6b28ad3f3d701435396bc1ad42ee88a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> chunkShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>chunk_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the shape of the chunk indexed by 'chunk_index'. </p>
<p>This may differ from the global chunk shape because chunks at the right/lower border of the array may be smaller than usual. </p>

</div>
</div>
<a class="anchor" id="a298cc634e6bcc748a7ebee5e7dff7d0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const&amp; chunkShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the global chunk shape. </p>
<p>This is the shape of all chunks that are completely contained in the array's domain. </p>

</div>
</div>
<a class="anchor" id="a09aa30c72793c85e16c4e29a2774e9fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void releaseChunks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>destroy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends all chunks asleep which are completely inside the given ROI. If destroy == true and the backend supports destruction (currently: <a class="el" href="classvigra_1_1ChunkedArrayLazy.html">ChunkedArrayLazy</a> and <a class="el" href="classvigra_1_1ChunkedArrayCompressed.html">ChunkedArrayCompressed</a>), chunks will be deleted entirely. The chunk's contents after <a class="el" href="classvigra_1_1ChunkedArray.html#a09aa30c72793c85e16c4e29a2774e9fc">releaseChunks()</a> are undefined. Currently, chunks retain their values when sent asleep, and assume the array's fill_value when deleted, but applications should not rely on this behavior. </p>

</div>
</div>
<a class="anchor" id="af1fbc0c9f44d6070bf7072884d68cb43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void checkoutSubarray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N, U, Stride &gt; &amp;&#160;</td>
          <td class="paramname"><em>subarray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy an ROI of the chunked array into an ordinary <a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray. ">MultiArrayView</a>. </p>
<p>The ROI's lower bound is given by 'start', its upper bound (in 'beyond' sense) is 'start + subarray.shape()'. Chunks in the ROI are only activated while the read is in progress. </p>

</div>
</div>
<a class="anchor" id="af95c2df02bc2bf51b61e2ba58fbdd81b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void commitSubarray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt; N, U, Stride &gt; const &amp;&#160;</td>
          <td class="paramname"><em>subarray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy an ordinary <a class="el" href="classvigra_1_1MultiArrayView.html" title="Base class for, and view to, vigra::MultiArray. ">MultiArrayView</a> into an ROI of the chunked array. </p>
<p>The ROI's lower bound is given by 'start', its upper bound (in 'beyond' sense) is 'start + subarray.shape()'. Chunks in the ROI are only activated while the write is in progress. </p>

</div>
</div>
<a class="anchor" id="ac3de45b70c5d89ed7fb65bc308523da9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1MultiArrayView.html">view_type</a> subarray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a view to the specified ROI. </p>
<p>The view can be used like an ordinary <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>, but is a but slower. All chunks intersecting the view remain active throughout the view's lifetime. </p>

</div>
</div>
<a class="anchor" id="a090ef1ecc26fa050f5da17d163eecc34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1MultiArrayView.html">const_view_type</a> subarray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a read-only view to the specified ROI. </p>
<p>The view can be used like an ordinary <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>, but is a but slower. All chunks intersecting the view remain active throughout the view's lifetime. </p>

</div>
</div>
<a class="anchor" id="a092202efae947078733521a73609ecfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1MultiArrayView.html">const_view_type</a> const_subarray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a read-only view to the specified ROI. </p>
<p>The view can be used like an ordinary <a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>, but is a but slower. All chunks intersecting the view remain active throughout the view's lifetime. </p>

</div>
</div>
<a class="anchor" id="adb43aee2dd30ad3b38ef8132a8db9384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">value_type getItem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the array element at index 'point'. </p>
<p>Since the corresponding chunk must potentially be activated first, this function may be slow and should mainly be used in debugging. </p>

</div>
</div>
<a class="anchor" id="a4e96d7344bc15a037644a43d837ca7ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setItem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1TinyVector.html">shape_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the array element at index 'point'. </p>
<p>Since the corresponding chunk must potentially be activated first, this function may be slow and should mainly be used in debugging. </p>

</div>
</div>
<a class="anchor" id="aac7656ac1635efc43562454b77bb1686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt;N-1, T, <a class="el" href="structvigra_1_1ChunkedArrayTag.html">ChunkedArrayTag</a>&gt; bindAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__MultiIteratorGroup.html#gac436173a0374e960a463a9186496ab70">MultiArrayIndex</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a lower dimensional view to the chunked array. </p>
<p>Dimension 'dim' is bound at 'index', all other dimensions remain unchanged. All chunks intersecting the view remain active throughout the view's lifetime. </p>

</div>
</div>
<a class="anchor" id="a5886ba94688ac8fbb3df80374bd1ae86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt;N-1, T, <a class="el" href="structvigra_1_1ChunkedArrayTag.html">ChunkedArrayTag</a>&gt; bind </td>
          <td>(</td>
          <td class="paramtype">difference_type_1&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a lower dimensional view to the chunked array. </p>
<p>Dimension 'M' (given as a template parameter) is bound at 'index', all other dimensions remain unchanged. All chunks intersecting the view remain active throughout the view's lifetime. </p>

</div>
</div>
<a class="anchor" id="add30b0027bada67ebc6999ef3850c55e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt;N-1, T, <a class="el" href="structvigra_1_1ChunkedArrayTag.html">ChunkedArrayTag</a>&gt; bindOuter </td>
          <td>(</td>
          <td class="paramtype">difference_type_1&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a lower dimensional view to the chunked array. </p>
<p>Dimension 'N-1' is bound at 'index', all other dimensions remain unchanged. All chunks intersecting the view remain active throughout the view's lifetime. </p>

</div>
</div>
<a class="anchor" id="ae7dba669bfee607fb5aed178db5309f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt;N-M, T, <a class="el" href="structvigra_1_1ChunkedArrayTag.html">ChunkedArrayTag</a>&gt; bindOuter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; Index, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a lower dimensional view to the chunked array. </p>
<p>The M rightmost dimensions are bound to the indices given in 'd'. All chunks intersecting the view remain active throughout the view's lifetime. </p>

</div>
</div>
<a class="anchor" id="a294816822d9380996316168f6312f4bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt;N-1, T, <a class="el" href="structvigra_1_1ChunkedArrayTag.html">ChunkedArrayTag</a>&gt; bindInner </td>
          <td>(</td>
          <td class="paramtype">difference_type_1&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a lower dimensional view to the chunked array. </p>
<p>Dimension '0' is bound at 'index', all other dimensions remain unchanged. All chunks intersecting the view remain active throughout the view's lifetime. </p>

</div>
</div>
<a class="anchor" id="a22ab037e305598d8ea8bbac16a71807a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1MultiArrayView.html">MultiArrayView</a>&lt;N-M, T, <a class="el" href="structvigra_1_1ChunkedArrayTag.html">ChunkedArrayTag</a>&gt; bindInner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvigra_1_1TinyVector.html">TinyVector</a>&lt; Index, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a lower dimensional view to the chunked array. </p>
<p>The M leftmost dimensions are bound to the indices given in 'd'. All chunks intersecting the view remain active throughout the view's lifetime. </p>

</div>
</div>
<a class="anchor" id="ad7d67c6bf9ccf27995db928bf861afde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t cacheMaxSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of chunks the cache will hold. </p>
<p>If there are any inactive chunks in the cache, these will be sent asleep until the max cahce size is reached. The max cache size may be temporarily overridden when more chunks need to be active simultaneously. </p>

</div>
</div>
<a class="anchor" id="a1b502a2b9970e599ee8cbc82a2b4abaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setCacheMaxSize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of chunks the cache will hold. </p>
<p>This should be big enough to hold all chunks that are frequently needed and must therefore be adopted to the application's access pattern. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vigra/<a class="el" href="multi__array__chunked_8hxx_source.html">multi_array_chunked.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.0 (Thu Mar 17 2016)
</i>
</tr>
</table>
</BODY>
</HTML>
