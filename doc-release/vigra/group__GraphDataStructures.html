<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Graph Data Structures and Algorithms</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
<script>
var runOnLoad=function(c,o,d,e){function x(){for(e=1;c.length;)c.shift()()}o[d]?(document[d]('DOMContentLoaded',x,0),o[d]('load',x,0)):o.attachEvent('onload',x);return function(t){e?o.setTimeout(t,0):c.push(t)}}([],window,'addEventListener');
</script>
<script type="text/javascript" src="documents/CollapsibleLists.js"></script>
<script type="text/javascript">
    runOnLoad(function(){ CollapsibleLists.apply(); });
</script>
<style type="text/css">
.collapsibleList li.collapsibleListOpen{
  list-style-image:url('documents/pfeil.gif');
  cursor:pointer;
}
.collapsibleList li.collapsibleListClosed{
  list-style-image:url('documents/bullet.gif');
  cursor:pointer;
}
.collapsibleList li.lastItem{
  list-style-image:url('documents/diamond.gif');
}
</style>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://ukoethe.github.io/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Graph Data Structures and Algorithms
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1AdjacencyListGraph.html">AdjacencyListGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">undirected adjacency list graph in the LEMON API  <a href="classvigra_1_1AdjacencyListGraph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BinaryForest.html">BinaryForest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvigra_1_1BinaryForest.html" title="BinaryForest stores a collection of rooted binary trees. ">BinaryForest</a> stores a collection of rooted binary trees.  <a href="classvigra_1_1BinaryForest.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ClusteringOptions.html">ClusteringOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options object for hierarchical clustering.  <a href="classvigra_1_1ClusteringOptions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1GridGraph.html">GridGraph&lt; N, DirectedTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a grid graph in arbitrary dimensions.  <a href="classvigra_1_1GridGraph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ShortestPathDijkstra.html">ShortestPathDijkstra&lt; GRAPH, WEIGHT_TYPE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortest path computer  <a href="classvigra_1_1ShortestPathDijkstra.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0e9d9113b29e570e2395339b51c6b037"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0e9d9113b29e570e2395339b51c6b037"></a>
Arc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga0e9d9113b29e570e2395339b51c6b037">addArc</a> (Node const &amp;u, Node const &amp;v)</td></tr>
<tr class="memdesc:ga0e9d9113b29e570e2395339b51c6b037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new arc from node <em>u</em> to node <em>v</em>. The arc ID is <code>2*id(u)</code> if <em>v</em> is the left child of <em>u</em>, <code>2*id(u)+1</code> otherwise. <br/></td></tr>
<tr class="separator:ga0e9d9113b29e570e2395339b51c6b037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9987a230a6155e90fc55f23dec0203f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9987a230a6155e90fc55f23dec0203f0"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga9987a230a6155e90fc55f23dec0203f0">addNode</a> ()</td></tr>
<tr class="memdesc:ga9987a230a6155e90fc55f23dec0203f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new node (its node ID will be selected automatically). <br/></td></tr>
<tr class="separator:ga9987a230a6155e90fc55f23dec0203f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a80eac08cb55526b1d90ac9efb7d8f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5a80eac08cb55526b1d90ac9efb7d8f2"></a>
Arc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga5a80eac08cb55526b1d90ac9efb7d8f2">arcFromId</a> (index_type const &amp;id) const </td></tr>
<tr class="memdesc:ga5a80eac08cb55526b1d90ac9efb7d8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get arc descriptor for <em>id</em>. <br/></td></tr>
<tr class="separator:ga5a80eac08cb55526b1d90ac9efb7d8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad1a97397e4aa8ca193401c6bfb1b1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0ad1a97397e4aa8ca193401c6bfb1b1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga0ad1a97397e4aa8ca193401c6bfb1b1f">BinaryForest</a> ()</td></tr>
<tr class="memdesc:ga0ad1a97397e4aa8ca193401c6bfb1b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty forest. <br/></td></tr>
<tr class="separator:ga0ad1a97397e4aa8ca193401c6bfb1b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab83f15062e3840121e29048e28a61b7e"><td class="memTemplParams" colspan="2">template&lt;class GRAPH , class EDGE_WEIGHTS , class SEEDS , class LABELS &gt; </td></tr>
<tr class="memitem:gab83f15062e3840121e29048e28a61b7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gab83f15062e3840121e29048e28a61b7e">carvingSegmentation</a> (const GRAPH &amp;g, const EDGE_WEIGHTS &amp;edgeWeights, const SEEDS &amp;seeds, const typename LABELS::Value backgroundLabel, const typename EDGE_WEIGHTS::Value backgroundBias, const typename EDGE_WEIGHTS::Value noPriorBelow, LABELS &amp;labels)</td></tr>
<tr class="memdesc:gab83f15062e3840121e29048e28a61b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge weighted watersheds Segmentataion  <a href="#gab83f15062e3840121e29048e28a61b7e">More...</a><br/></td></tr>
<tr class="separator:gab83f15062e3840121e29048e28a61b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df648e05bbd7b292bf65e54a93cacbf"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6df648e05bbd7b292bf65e54a93cacbf"></a>
template&lt;class G , class A , class B &gt; </td></tr>
<tr class="memitem:ga6df648e05bbd7b292bf65e54a93cacbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga6df648e05bbd7b292bf65e54a93cacbf">copyEdgeMap</a> (const G &amp;g, const A &amp;a, B &amp;b)</td></tr>
<tr class="memdesc:ga6df648e05bbd7b292bf65e54a93cacbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy a lemon edge map <br/></td></tr>
<tr class="separator:ga6df648e05bbd7b292bf65e54a93cacbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0461a292f8ffc7030457c25f87c0073"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac0461a292f8ffc7030457c25f87c0073"></a>
template&lt;class G , class A , class B &gt; </td></tr>
<tr class="memitem:gac0461a292f8ffc7030457c25f87c0073"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gac0461a292f8ffc7030457c25f87c0073">copyNodeMap</a> (const G &amp;g, const A &amp;a, B &amp;b)</td></tr>
<tr class="memdesc:gac0461a292f8ffc7030457c25f87c0073"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy a lemon node map <br/></td></tr>
<tr class="separator:gac0461a292f8ffc7030457c25f87c0073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf2d9ac4f45fe58fa403af7c0821b38"><td class="memTemplParams" colspan="2">template&lt;class GRAPH , class WEIGHTS , class COMPERATOR &gt; </td></tr>
<tr class="memitem:ga5cf2d9ac4f45fe58fa403af7c0821b38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga5cf2d9ac4f45fe58fa403af7c0821b38">edgeSort</a> (const GRAPH &amp;g, const WEIGHTS &amp;weights, const COMPERATOR &amp;comperator, std::vector&lt; typename GRAPH::Edge &gt; &amp;sortedEdges)</td></tr>
<tr class="memdesc:ga5cf2d9ac4f45fe58fa403af7c0821b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a vector of Edge descriptors  <a href="#ga5cf2d9ac4f45fe58fa403af7c0821b38">More...</a><br/></td></tr>
<tr class="separator:ga5cf2d9ac4f45fe58fa403af7c0821b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c146d157be5221477d8efb6943623a"><td class="memTemplParams" colspan="2">template&lt;class GRAPH , class EDGE_WEIGHTS , class SEEDS , class LABELS &gt; </td></tr>
<tr class="memitem:ga67c146d157be5221477d8efb6943623a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga67c146d157be5221477d8efb6943623a">edgeWeightedWatershedsSegmentation</a> (const GRAPH &amp;g, const EDGE_WEIGHTS &amp;edgeWeights, const SEEDS &amp;seeds, LABELS &amp;labels)</td></tr>
<tr class="memdesc:ga67c146d157be5221477d8efb6943623a"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge weighted watersheds Segmentataion  <a href="#ga67c146d157be5221477d8efb6943623a">More...</a><br/></td></tr>
<tr class="separator:ga67c146d157be5221477d8efb6943623a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab6c54335f12cd7da2798eb5a2177910"><td class="memTemplParams" colspan="2">template&lt;unsigned int N, class DirectedTag , class T , class EDGEMAP &gt; </td></tr>
<tr class="memitem:gaab6c54335f12cd7da2798eb5a2177910"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaab6c54335f12cd7da2798eb5a2177910">edgeWeightsFromInterpolatedImage</a> (const GridGraph&lt; N, DirectedTag &gt; &amp;g, const MultiArrayView&lt; N, T &gt; &amp;interpolatedImage, EDGEMAP &amp;edgeWeights, bool euclidean=false)</td></tr>
<tr class="memdesc:gaab6c54335f12cd7da2798eb5a2177910"><td class="mdescLeft">&#160;</td><td class="mdescRight">create edge weights from an interpolated image  <a href="#gaab6c54335f12cd7da2798eb5a2177910">More...</a><br/></td></tr>
<tr class="separator:gaab6c54335f12cd7da2798eb5a2177910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb6612859f47b018b2eaa6a6cd24a5ea"><td class="memTemplParams" colspan="2">template&lt;unsigned int N, class DirectedTag , class NODEMAP , class EDGEMAP , class FUNCTOR &gt; </td></tr>
<tr class="memitem:gadb6612859f47b018b2eaa6a6cd24a5ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gadb6612859f47b018b2eaa6a6cd24a5ea">edgeWeightsFromNodeWeights</a> (const GridGraph&lt; N, DirectedTag &gt; &amp;g, const NODEMAP &amp;nodeWeights, EDGEMAP &amp;edgeWeights, bool euclidean, FUNCTOR const &amp;func)</td></tr>
<tr class="memdesc:gadb6612859f47b018b2eaa6a6cd24a5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">create edge weights from node weights  <a href="#gadb6612859f47b018b2eaa6a6cd24a5ea">More...</a><br/></td></tr>
<tr class="separator:gadb6612859f47b018b2eaa6a6cd24a5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3db8b23fe023c6493405ae4f8a3cf60"><td class="memTemplParams" colspan="2">template&lt;class GRAPH , class EDGE_WEIGHTS , class NODE_SIZE , class NODE_LABEL_MAP &gt; </td></tr>
<tr class="memitem:gac3db8b23fe023c6493405ae4f8a3cf60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gac3db8b23fe023c6493405ae4f8a3cf60">felzenszwalbSegmentation</a> (const GRAPH &amp;graph, const EDGE_WEIGHTS &amp;edgeWeights, const NODE_SIZE &amp;nodeSizes, float k, NODE_LABEL_MAP &amp;nodeLabeling, const int nodeNumStopCond=-1)</td></tr>
<tr class="memdesc:gac3db8b23fe023c6493405ae4f8a3cf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge weighted watersheds Segmentataion  <a href="#gac3db8b23fe023c6493405ae4f8a3cf60">More...</a><br/></td></tr>
<tr class="separator:gac3db8b23fe023c6493405ae4f8a3cf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab987a63a328ffd395970d3080a8a501b"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab987a63a328ffd395970d3080a8a501b"></a>
template&lt;class G , class A , class T &gt; </td></tr>
<tr class="memitem:gab987a63a328ffd395970d3080a8a501b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gab987a63a328ffd395970d3080a8a501b">fillEdgeMap</a> (const G &amp;g, A &amp;a, const T &amp;value)</td></tr>
<tr class="memdesc:gab987a63a328ffd395970d3080a8a501b"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill a lemon edge map <br/></td></tr>
<tr class="separator:gab987a63a328ffd395970d3080a8a501b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219158b1d271342c96ad37d96a0f8997"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga219158b1d271342c96ad37d96a0f8997"></a>
template&lt;class G , class A , class T &gt; </td></tr>
<tr class="memitem:ga219158b1d271342c96ad37d96a0f8997"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga219158b1d271342c96ad37d96a0f8997">fillNodeMap</a> (const G &amp;g, A &amp;a, const T &amp;value)</td></tr>
<tr class="memdesc:ga219158b1d271342c96ad37d96a0f8997"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill a lemon node map <br/></td></tr>
<tr class="separator:ga219158b1d271342c96ad37d96a0f8997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe5aa97793b5ecc1c5f86254abf65113"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabe5aa97793b5ecc1c5f86254abf65113"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gabe5aa97793b5ecc1c5f86254abf65113">getChild</a> (Node const &amp;node, size_t i=0) const </td></tr>
<tr class="memdesc:gabe5aa97793b5ecc1c5f86254abf65113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get child number <em>i</em> of <em>node</em>. Returns the left child if <code>i=0</code>, the right child if <code>i=1</code>, and <code>lemon::INVALID</code> for other values of <em>i</em> or when the respective is undefined. <br/></td></tr>
<tr class="separator:gabe5aa97793b5ecc1c5f86254abf65113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bef6b1dcb8786a01e679084e5d92a12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2bef6b1dcb8786a01e679084e5d92a12"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga2bef6b1dcb8786a01e679084e5d92a12">getNode</a> (size_t i) const </td></tr>
<tr class="memdesc:ga2bef6b1dcb8786a01e679084e5d92a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create node cescriptor for ID <em>i</em>, or <code>lemon::INVALID</code> if <em>i</em> is not a valid ID. <br/></td></tr>
<tr class="separator:ga2bef6b1dcb8786a01e679084e5d92a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab535952560b92420ebc9d8ad4f0ca574"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab535952560b92420ebc9d8ad4f0ca574"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gab535952560b92420ebc9d8ad4f0ca574">getParent</a> (Node const &amp;node, size_t i=0) const </td></tr>
<tr class="memdesc:gab535952560b92420ebc9d8ad4f0ca574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent node descriptor of <em>node</em>, or <code>lemon::INVALID</code> if <em>node</em> is a root or <em>i</em> is non-zero. <br/></td></tr>
<tr class="separator:gab535952560b92420ebc9d8ad4f0ca574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa849e9cb4b40c1fdd09644aba91c724c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa849e9cb4b40c1fdd09644aba91c724c"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaa849e9cb4b40c1fdd09644aba91c724c">getRoot</a> (size_t i=0) const </td></tr>
<tr class="memdesc:gaa849e9cb4b40c1fdd09644aba91c724c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the root node descriptor of tree <em>i</em> in the forest, or <code>lemon::INVALID</code> if <em>i</em> is invalid. <br/></td></tr>
<tr class="separator:gaa849e9cb4b40c1fdd09644aba91c724c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae576b3bc3a6baeb6518cca788035d9d3"><td class="memTemplParams" colspan="2">template&lt;class GRAPH , class NODE_FEATURES_IN , class EDGE_INDICATOR , class NODE_FEATURES_OUT &gt; </td></tr>
<tr class="memitem:gae576b3bc3a6baeb6518cca788035d9d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gae576b3bc3a6baeb6518cca788035d9d3">graphSmoothing</a> (const GRAPH &amp;g, const NODE_FEATURES_IN &amp;nodeFeaturesIn, const EDGE_INDICATOR &amp;edgeIndicator, const float lambda, const float edgeThreshold, const float scale, NODE_FEATURES_OUT &amp;nodeFeaturesOut)</td></tr>
<tr class="memdesc:gae576b3bc3a6baeb6518cca788035d9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">smooth node features of a graph  <a href="#gae576b3bc3a6baeb6518cca788035d9d3">More...</a><br/></td></tr>
<tr class="separator:gae576b3bc3a6baeb6518cca788035d9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbaa28685756ee5d69b17c7a31f8b8fb"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gafbaa28685756ee5d69b17c7a31f8b8fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gafbaa28685756ee5d69b17c7a31f8b8fb">hierarchicalClustering</a> (...)</td></tr>
<tr class="memdesc:gafbaa28685756ee5d69b17c7a31f8b8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the number of nodes in a graph by iteratively contracting the cheapest edge.  <a href="#gafbaa28685756ee5d69b17c7a31f8b8fb">More...</a><br/></td></tr>
<tr class="separator:gafbaa28685756ee5d69b17c7a31f8b8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2f9e3ff165c2946c49bf4ff09e0677e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf2f9e3ff165c2946c49bf4ff09e0677e"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaf2f9e3ff165c2946c49bf4ff09e0677e">id</a> (Node const &amp;node) const </td></tr>
<tr class="memdesc:gaf2f9e3ff165c2946c49bf4ff09e0677e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ID for node descriptor <em>node</em>. <br/></td></tr>
<tr class="separator:gaf2f9e3ff165c2946c49bf4ff09e0677e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9335c48d136f6822d949b2115a3ea717"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9335c48d136f6822d949b2115a3ea717"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga9335c48d136f6822d949b2115a3ea717">id</a> (Arc const &amp;arc) const </td></tr>
<tr class="memdesc:ga9335c48d136f6822d949b2115a3ea717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ID for arc descriptor <em>arc</em>. <br/></td></tr>
<tr class="separator:ga9335c48d136f6822d949b2115a3ea717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa696f39a0aad68629f7e2e7674a60d55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa696f39a0aad68629f7e2e7674a60d55"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaa696f39a0aad68629f7e2e7674a60d55">inDegree</a> (Node const &amp;node) const </td></tr>
<tr class="memdesc:gaa696f39a0aad68629f7e2e7674a60d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of incoming edges of <em>node</em>. <code>0</code> for a root node, <code>1</code> otherwise. <br/></td></tr>
<tr class="separator:gaa696f39a0aad68629f7e2e7674a60d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e4a082419162804528250e835f0b0f"><td class="memTemplParams" colspan="2">template&lt;class GRAPH_IN , class GRAPH_IN_NODE_LABEL_MAP &gt; </td></tr>
<tr class="memitem:gac2e4a082419162804528250e835f0b0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gac2e4a082419162804528250e835f0b0f">makeRegionAdjacencyGraph</a> (GRAPH_IN graphIn, GRAPH_IN_NODE_LABEL_MAP labels, AdjacencyListGraph &amp;rag, typename AdjacencyListGraph::template EdgeMap&lt; std::vector&lt; typename GRAPH_IN::Edge &gt; &gt; &amp;affiliatedEdges, const Int64 ignoreLabel=-1)</td></tr>
<tr class="memdesc:gac2e4a082419162804528250e835f0b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a region adjacency graph from a graph and labels w.r.t. that graph  <a href="#gac2e4a082419162804528250e835f0b0f">More...</a><br/></td></tr>
<tr class="separator:gac2e4a082419162804528250e835f0b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a70f17e3297169076a96fb3482d455d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a70f17e3297169076a96fb3482d455d"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga1a70f17e3297169076a96fb3482d455d">maxArcId</a> () const </td></tr>
<tr class="memdesc:ga1a70f17e3297169076a96fb3482d455d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the highest possible arc ID (equivalent to <code>2*maxNodeId() + 1</code>). <br/></td></tr>
<tr class="separator:ga1a70f17e3297169076a96fb3482d455d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa72e95d300708e73e992c8dda8ac8e9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa72e95d300708e73e992c8dda8ac8e9b"></a>
index_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaa72e95d300708e73e992c8dda8ac8e9b">maxNodeId</a> () const </td></tr>
<tr class="memdesc:gaa72e95d300708e73e992c8dda8ac8e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the highest existing node ID. <br/></td></tr>
<tr class="separator:gaa72e95d300708e73e992c8dda8ac8e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf61a3005f991dde97d45aff37764f9ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf61a3005f991dde97d45aff37764f9ff"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaf61a3005f991dde97d45aff37764f9ff">merge</a> (BinaryForest const &amp;other)</td></tr>
<tr class="memdesc:gaf61a3005f991dde97d45aff37764f9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two forests and increase the IDs of <em>other</em> to avoid ID clashes. The function returns the offset that has been added to these IDs. <br/></td></tr>
<tr class="separator:gaf61a3005f991dde97d45aff37764f9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289fced77f5ddfe05e8f22265b36ff0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga289fced77f5ddfe05e8f22265b36ff0a"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga289fced77f5ddfe05e8f22265b36ff0a">nodeFromId</a> (index_type const &amp;id) const </td></tr>
<tr class="memdesc:ga289fced77f5ddfe05e8f22265b36ff0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get node descriptor for <em>id</em>. <br/></td></tr>
<tr class="separator:ga289fced77f5ddfe05e8f22265b36ff0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ec48c0ca1ab9969107a25b6f1aa5a75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7ec48c0ca1ab9969107a25b6f1aa5a75"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga7ec48c0ca1ab9969107a25b6f1aa5a75">numArcs</a> () const </td></tr>
<tr class="memdesc:ga7ec48c0ca1ab9969107a25b6f1aa5a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of arcs. Always less than <code><a class="el" href="group__GraphDataStructures.html#ga1a70f17e3297169076a96fb3482d455d" title="Return the highest possible arc ID (equivalent to 2*maxNodeId() + 1). ">maxArcId()</a></code> because not all arcs actually exist. <br/></td></tr>
<tr class="separator:ga7ec48c0ca1ab9969107a25b6f1aa5a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f34b5c0a2f75e2913c6cc233931ce64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f34b5c0a2f75e2913c6cc233931ce64"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga6f34b5c0a2f75e2913c6cc233931ce64">numChildren</a> (Node const &amp;node) const </td></tr>
<tr class="memdesc:ga6f34b5c0a2f75e2913c6cc233931ce64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of children of <em>node</em> (equivalent to <code><a class="el" href="group__GraphDataStructures.html#ga23e1f1d21d76c23ecdccb8d712c7a212" title="Return the number of outgoing edges of node. 0 for a leaf node, 1 or 2 otherwise. ...">outDegree()</a></code>). <br/></td></tr>
<tr class="separator:ga6f34b5c0a2f75e2913c6cc233931ce64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f6faf35474e0e5457885e2b7dc0ebc5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3f6faf35474e0e5457885e2b7dc0ebc5"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga3f6faf35474e0e5457885e2b7dc0ebc5">numNodes</a> () const </td></tr>
<tr class="memdesc:ga3f6faf35474e0e5457885e2b7dc0ebc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes (equivalent to <code><a class="el" href="group__GraphDataStructures.html#gaa72e95d300708e73e992c8dda8ac8e9b" title="Return the highest existing node ID. ">maxNodeId()</a>+1</code>). <br/></td></tr>
<tr class="separator:ga3f6faf35474e0e5457885e2b7dc0ebc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fa22a080ca182b625a3f446a681eea1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5fa22a080ca182b625a3f446a681eea1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga5fa22a080ca182b625a3f446a681eea1">numParents</a> (Node const &amp;node) const </td></tr>
<tr class="memdesc:ga5fa22a080ca182b625a3f446a681eea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of parents of <em>node</em> (equivalent to <code><a class="el" href="group__GraphDataStructures.html#gaa696f39a0aad68629f7e2e7674a60d55" title="Return the number of incoming edges of node. 0 for a root node, 1 otherwise. ">inDegree()</a></code>). <br/></td></tr>
<tr class="separator:ga5fa22a080ca182b625a3f446a681eea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga834a1f118c619060851ec8d6519c4201"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga834a1f118c619060851ec8d6519c4201"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga834a1f118c619060851ec8d6519c4201">numRoots</a> () const </td></tr>
<tr class="memdesc:ga834a1f118c619060851ec8d6519c4201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of trees in the forest. <br/></td></tr>
<tr class="separator:ga834a1f118c619060851ec8d6519c4201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23e1f1d21d76c23ecdccb8d712c7a212"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga23e1f1d21d76c23ecdccb8d712c7a212"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga23e1f1d21d76c23ecdccb8d712c7a212">outDegree</a> (Node const &amp;node) const </td></tr>
<tr class="memdesc:ga23e1f1d21d76c23ecdccb8d712c7a212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of outgoing edges of <em>node</em>. <code>0</code> for a leaf node, <code>1</code> or <code>2</code> otherwise. <br/></td></tr>
<tr class="separator:ga23e1f1d21d76c23ecdccb8d712c7a212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74f4759ba0a1c275eebe78b9eefc0e09"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga74f4759ba0a1c275eebe78b9eefc0e09"></a>
template&lt;class NODE , class PREDECESSORS &gt; </td></tr>
<tr class="memitem:ga74f4759ba0a1c275eebe78b9eefc0e09"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga74f4759ba0a1c275eebe78b9eefc0e09">pathLength</a> (const NODE source, const NODE target, const PREDECESSORS &amp;predecessors)</td></tr>
<tr class="memdesc:ga74f4759ba0a1c275eebe78b9eefc0e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the length in node units of a path <br/></td></tr>
<tr class="separator:ga74f4759ba0a1c275eebe78b9eefc0e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga788f5718a30636b2d0403d407e6886d5"><td class="memTemplParams" colspan="2">template&lt;class RAG , class BASE_GRAPH , class BASE_GRAPH_RAG_LABELS , class BASE_GRAPH_GT , class RAG_GT , class RAG_GT_QT &gt; </td></tr>
<tr class="memitem:ga788f5718a30636b2d0403d407e6886d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga788f5718a30636b2d0403d407e6886d5">projectGroundTruth</a> (const RAG &amp;rag, const BASE_GRAPH &amp;baseGraph, const BASE_GRAPH_RAG_LABELS &amp;baseGraphRagLabels, const BASE_GRAPH_GT &amp;baseGraphGt, RAG_GT &amp;ragGt, RAG_GT_QT &amp;)</td></tr>
<tr class="separator:ga788f5718a30636b2d0403d407e6886d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacec4a1f5b62eda886e2d4383c97dc808"><td class="memTemplParams" colspan="2">template&lt;class RAGGRAPH , class GRAPH , class RAGEDGES , unsigned int N, class T &gt; </td></tr>
<tr class="memitem:gacec4a1f5b62eda886e2d4383c97dc808"><td class="memTemplItemLeft" align="right" valign="top">MultiArray&lt; 2, MultiArrayIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gacec4a1f5b62eda886e2d4383c97dc808">ragFindEdges</a> (const RAGGRAPH &amp;rag, const GRAPH &amp;graph, const RAGEDGES &amp;affiliatedEdges, MultiArrayView&lt; N, T &gt; labelsArray, const typename RAGGRAPH::Node &amp;node)</td></tr>
<tr class="memdesc:gacec4a1f5b62eda886e2d4383c97dc808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find indices of points on the edges.  <a href="#gacec4a1f5b62eda886e2d4383c97dc808">More...</a><br/></td></tr>
<tr class="separator:gacec4a1f5b62eda886e2d4383c97dc808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5146deb4665a1cff08bc087ad4b091"><td class="memTemplParams" colspan="2">template&lt;class GRAPH , class NODE_FEATURES_IN , class EDGE_INDICATOR , class NODE_FEATURES_OUT &gt; </td></tr>
<tr class="memitem:gaec5146deb4665a1cff08bc087ad4b091"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaec5146deb4665a1cff08bc087ad4b091">recursiveGraphSmoothing</a> (const GRAPH &amp;g, const NODE_FEATURES_IN &amp;nodeFeaturesIn, const EDGE_INDICATOR &amp;edgeIndicator, const float lambda, const float edgeThreshold, const float scale, size_t iterations, NODE_FEATURES_OUT &amp;nodeFeaturesBuffer, NODE_FEATURES_OUT &amp;nodeFeaturesOut)</td></tr>
<tr class="memdesc:gaec5146deb4665a1cff08bc087ad4b091"><td class="mdescLeft">&#160;</td><td class="mdescRight">smooth node features of a graph  <a href="#gaec5146deb4665a1cff08bc087ad4b091">More...</a><br/></td></tr>
<tr class="separator:gaec5146deb4665a1cff08bc087ad4b091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae55d4b94f1300b962ac7e9b4dfd75575"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae55d4b94f1300b962ac7e9b4dfd75575"></a>
template&lt;class GRAPH , class WEIGHTS , class PREDECESSORS , class DISTANCE , class HEURSTIC &gt; </td></tr>
<tr class="memitem:gae55d4b94f1300b962ac7e9b4dfd75575"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gae55d4b94f1300b962ac7e9b4dfd75575">shortestPathAStar</a> (const GRAPH &amp;graph, const typename GRAPH::Node &amp;source, const typename GRAPH::Node &amp;target, const WEIGHTS &amp;weights, PREDECESSORS &amp;predecessors, DISTANCE &amp;distance, const HEURSTIC &amp;heuristic)</td></tr>
<tr class="memdesc:gae55d4b94f1300b962ac7e9b4dfd75575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Astar Shortest path search. <br/></td></tr>
<tr class="separator:gae55d4b94f1300b962ac7e9b4dfd75575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfef0e211a2b3a4ec460596bebb9a5d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabfef0e211a2b3a4ec460596bebb9a5d6"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gabfef0e211a2b3a4ec460596bebb9a5d6">source</a> (Arc const &amp;arc) const </td></tr>
<tr class="memdesc:gabfef0e211a2b3a4ec460596bebb9a5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find start node of <em>arc</em>. <br/></td></tr>
<tr class="separator:gabfef0e211a2b3a4ec460596bebb9a5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeb5c8e50e768e47740f636c76f15fc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafeb5c8e50e768e47740f636c76f15fc6"></a>
Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gafeb5c8e50e768e47740f636c76f15fc6">target</a> (Arc const &amp;arc) const </td></tr>
<tr class="memdesc:gafeb5c8e50e768e47740f636c76f15fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find end node of <em>arc</em>. <br/></td></tr>
<tr class="separator:gafeb5c8e50e768e47740f636c76f15fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3d344748456d4ecc8354cf9962408f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4c3d344748456d4ecc8354cf9962408f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#ga4c3d344748456d4ecc8354cf9962408f">valid</a> (Node const &amp;node) const </td></tr>
<tr class="memdesc:ga4c3d344748456d4ecc8354cf9962408f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <em>node</em> exists. <br/></td></tr>
<tr class="separator:ga4c3d344748456d4ecc8354cf9962408f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf424e78bba00e3cbad6fb7cfac9a4255"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf424e78bba00e3cbad6fb7cfac9a4255"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphDataStructures.html#gaf424e78bba00e3cbad6fb7cfac9a4255">valid</a> (Arc const &amp;arc) const </td></tr>
<tr class="memdesc:gaf424e78bba00e3cbad6fb7cfac9a4255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <em>arc</em> exists. <br/></td></tr>
<tr class="separator:gaf424e78bba00e3cbad6fb7cfac9a4255"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<p>Graph algorithms and the underlying graph data structures (e.g. <a class="el" href="classvigra_1_1GridGraph.html" title="Define a grid graph in arbitrary dimensions. ">GridGraph</a> and <a class="el" href="classvigra_1_1AdjacencyListGraph.html" title="undirected adjacency list graph in the LEMON API ">AdjacencyListGraph</a>) implementing the APIs of the <a href="http://www.boost.org/doc/libs/release/libs/graph/">boost::graph</a> and <a href="http://lemon.cs.elte.hu/">LEMON</a> libraries.</p>
<p>See also the <a class="el" href="group__BoostGraphExtensions.html">GridGraph additions to namespace <code>boost</code></a>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5cf2d9ac4f45fe58fa403af7c0821b38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::edgeSort </td>
          <td>(</td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WEIGHTS &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMPERATOR &amp;&#160;</td>
          <td class="paramname"><em>comperator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename GRAPH::Edge &gt; &amp;&#160;</td>
          <td class="paramname"><em>sortedEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a vector of Edge descriptors </p>
<p>Sort the Edge descriptors given weights and a comperator </p>

</div>
</div>
<a class="anchor" id="gac2e4a082419162804528250e835f0b0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::makeRegionAdjacencyGraph </td>
          <td>(</td>
          <td class="paramtype">GRAPH_IN&#160;</td>
          <td class="paramname"><em>graphIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GRAPH_IN_NODE_LABEL_MAP&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AdjacencyListGraph &amp;&#160;</td>
          <td class="paramname"><em>rag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename AdjacencyListGraph::template EdgeMap&lt; std::vector&lt; typename GRAPH_IN::Edge &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>affiliatedEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int64&#160;</td>
          <td class="paramname"><em>ignoreLabel</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make a region adjacency graph from a graph and labels w.r.t. that graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">graphIn</td><td>: input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">labels</td><td>: labels w.r.t. graphIn </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rag</td><td>: region adjacency graph </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">affiliatedEdges</td><td>: a vector of edges of graphIn for each edge in rag </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ignoreLabel</td><td>: optional label to ignore (default: -1 means no label will be ignored) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="graph_agglomerative_clustering_8cxx-example.html#a17">graph_agglomerative_clustering.cxx</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga67c146d157be5221477d8efb6943623a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::edgeWeightedWatershedsSegmentation </td>
          <td>(</td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EDGE_WEIGHTS &amp;&#160;</td>
          <td class="paramname"><em>edgeWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SEEDS &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LABELS &amp;&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge weighted watersheds Segmentataion </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g</td><td>input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeWeights</td><td>: edge weights / edge indicator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seeds</td><td>: seed must be non empty! </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">labels</td><td>: resulting nodeLabeling (not necessarily dense) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab83f15062e3840121e29048e28a61b7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::carvingSegmentation </td>
          <td>(</td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EDGE_WEIGHTS &amp;&#160;</td>
          <td class="paramname"><em>edgeWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SEEDS &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename LABELS::Value&#160;</td>
          <td class="paramname"><em>backgroundLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename EDGE_WEIGHTS::Value&#160;</td>
          <td class="paramname"><em>backgroundBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename EDGE_WEIGHTS::Value&#160;</td>
          <td class="paramname"><em>noPriorBelow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LABELS &amp;&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge weighted watersheds Segmentataion </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g</td><td>input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeWeights</td><td>: edge weights / edge indicator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">seeds</td><td>: seed must be non empty! </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">backgroundLabel</td><td>: which label is background </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">backgroundBias</td><td>: bias for background </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">noPriorBelow</td><td>: don't bias the background if edge indicator is below this value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">labels</td><td>: resulting nodeLabeling (not necessarily dense) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac3db8b23fe023c6493405ae4f8a3cf60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::felzenszwalbSegmentation </td>
          <td>(</td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EDGE_WEIGHTS &amp;&#160;</td>
          <td class="paramname"><em>edgeWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NODE_SIZE &amp;&#160;</td>
          <td class="paramname"><em>nodeSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_LABEL_MAP &amp;&#160;</td>
          <td class="paramname"><em>nodeLabeling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nodeNumStopCond</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge weighted watersheds Segmentataion </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">graph</td><td>input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeWeights</td><td>: edge weights / edge indicator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeSizes</td><td>: size of each node </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">k</td><td>: free parameter of felzenszwalb algorithm </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeLabeling</td><td>: nodeLabeling (not necessarily dense) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeNumStopCond</td><td>: optional stopping condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae576b3bc3a6baeb6518cca788035d9d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::graphSmoothing </td>
          <td>(</td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NODE_FEATURES_IN &amp;&#160;</td>
          <td class="paramname"><em>nodeFeaturesIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EDGE_INDICATOR &amp;&#160;</td>
          <td class="paramname"><em>edgeIndicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>edgeThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_FEATURES_OUT &amp;&#160;</td>
          <td class="paramname"><em>nodeFeaturesOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smooth node features of a graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g</td><td>: input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeFeaturesIn</td><td>: input node features which should be smoothed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeIndicator</td><td>: edge indicator to indicate over which edges one should smooth </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lambda</td><td>: scale edge indicator by lambda before taking negative exponent </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeThreshold</td><td>: edge threshold </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">scale</td><td>: how much smoothing should be applied </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeFeaturesOut</td><td>: smoothed node features </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec5146deb4665a1cff08bc087ad4b091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::recursiveGraphSmoothing </td>
          <td>(</td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NODE_FEATURES_IN &amp;&#160;</td>
          <td class="paramname"><em>nodeFeaturesIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EDGE_INDICATOR &amp;&#160;</td>
          <td class="paramname"><em>edgeIndicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>edgeThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_FEATURES_OUT &amp;&#160;</td>
          <td class="paramname"><em>nodeFeaturesBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_FEATURES_OUT &amp;&#160;</td>
          <td class="paramname"><em>nodeFeaturesOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smooth node features of a graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g</td><td>: input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeFeaturesIn</td><td>: input node features which should be smoothed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeIndicator</td><td>: edge indicator to indicate over which edges one should smooth </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lambda</td><td>: scale edge indicator by lambda before taking negative exponent </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edgeThreshold</td><td>: edge threshold </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">scale</td><td>: how much smoothing should be applied </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">iterations</td><td>: how often should this algorithm be called recursively </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeFeaturesBuffer</td><td>: preallocated(!) buffer to store node features temp. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeFeaturesOut</td><td>: smoothed node features </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga788f5718a30636b2d0403d407e6886d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::projectGroundTruth </td>
          <td>(</td>
          <td class="paramtype">const RAG &amp;&#160;</td>
          <td class="paramname"><em>rag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BASE_GRAPH &amp;&#160;</td>
          <td class="paramname"><em>baseGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BASE_GRAPH_RAG_LABELS &amp;&#160;</td>
          <td class="paramname"><em>baseGraphRagLabels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BASE_GRAPH_GT &amp;&#160;</td>
          <td class="paramname"><em>baseGraphGt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAG_GT &amp;&#160;</td>
          <td class="paramname"><em>ragGt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RAG_GT_QT &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>project ground truth from a base graph, to a region adjacency graph. </p>

</div>
</div>
<a class="anchor" id="gacec4a1f5b62eda886e2d4383c97dc808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MultiArray&lt;2, MultiArrayIndex&gt; vigra::ragFindEdges </td>
          <td>(</td>
          <td class="paramtype">const RAGGRAPH &amp;&#160;</td>
          <td class="paramname"><em>rag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GRAPH &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RAGEDGES &amp;&#160;</td>
          <td class="paramname"><em>affiliatedEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; N, T &gt;&#160;</td>
          <td class="paramname"><em>labelsArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename RAGGRAPH::Node &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find indices of points on the edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rag</td><td>: Region adjacency graph of the labels array </td></tr>
    <tr><td class="paramname">graph</td><td>: Graph of labels array </td></tr>
    <tr><td class="paramname">affiliatedEdges</td><td>: The affiliated edges of the region adjacency graph </td></tr>
    <tr><td class="paramname">labelsArray</td><td>: The label image </td></tr>
    <tr><td class="paramname">node</td><td>: The node (of the region adjacency graph), whose edges shall be found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadb6612859f47b018b2eaa6a6cd24a5ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::edgeWeightsFromNodeWeights </td>
          <td>(</td>
          <td class="paramtype">const GridGraph&lt; N, DirectedTag &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NODEMAP &amp;&#160;</td>
          <td class="paramname"><em>nodeWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EDGEMAP &amp;&#160;</td>
          <td class="paramname"><em>edgeWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>euclidean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FUNCTOR const &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create edge weights from node weights </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g</td><td>: input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nodeWeights</td><td>: node property map holding node weights </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edgeWeights</td><td>: resulting edge weights </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">euclidean</td><td>: if 'true', multiply the computed weights with the Euclidean distance between the edge's end nodes (default: 'false') </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">func</td><td>: binary function that computes the edge weight from the weights of the edge's end nodes (default: take the average) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab6c54335f12cd7da2798eb5a2177910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::edgeWeightsFromInterpolatedImage </td>
          <td>(</td>
          <td class="paramtype">const GridGraph&lt; N, DirectedTag &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArrayView&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolatedImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EDGEMAP &amp;&#160;</td>
          <td class="paramname"><em>edgeWeights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>euclidean</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create edge weights from an interpolated image </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g</td><td>: input graph </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">interpolatedImage</td><td>: interpolated image </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edgeWeights</td><td>: edge weights </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">euclidean</td><td>: if 'true', multiply the weights with the Euclidean distance between the edge's end nodes (default: 'false')</td></tr>
  </table>
  </dd>
</dl>
<p>For each edge, the function reads the weight from <code>interpolatedImage[u+v]</code>, where <code>u</code> and <code>v</code> are the coordinates of the edge's end points. </p>

</div>
</div>
<a class="anchor" id="gafbaa28685756ee5d69b17c7a31f8b8fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::hierarchicalClustering </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce the number of nodes in a graph by iteratively contracting the cheapest edge. </p>
<p><b> Declarations:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>GRAPH,</div>
<div class="line">              <span class="keyword">class </span>EDGE_WEIGHT_MAP,  <span class="keyword">class </span>EDGE_LENGTH_MAP,</div>
<div class="line">              <span class="keyword">class </span>NODE_FEATURE_MAP, <span class="keyword">class </span>NOSE_SIZE_MAP,</div>
<div class="line">              <span class="keyword">class </span>NODE_LABEL_MAP&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__GraphDataStructures.html#gafbaa28685756ee5d69b17c7a31f8b8fb">hierarchicalClustering</a>(GRAPH <span class="keyword">const</span> &amp; graph,</div>
<div class="line">                           EDGE_WEIGHT_MAP <span class="keyword">const</span> &amp; edgeWeights, EDGE_LENGTH_MAP <span class="keyword">const</span> &amp; edgeLengths,</div>
<div class="line">                           NODE_FEATURE_MAP <span class="keyword">const</span> &amp; nodeFeatures, NOSE_SIZE_MAP <span class="keyword">const</span> &amp; nodeSizes,</div>
<div class="line">                           NODE_LABEL_MAP &amp; labelMap,</div>
<div class="line">                           ClusteringOptions options = ClusteringOptions());</div>
<div class="line">}</div>
</div><!-- fragment --><p>Hierarchical clustering is a simple and versatile image segmentation algorithm that typically operates either directly on the pixels (e.g. on a <a class="el" href="classvigra_1_1GridGraph.html">vigra::GridGraph</a>) or on a region adjacency graph over suitable superpixels (e.g. on an <a class="el" href="classvigra_1_1AdjacencyListGraph.html">vigra::AdjacencyListGraph</a>). The graph is passed to the function in its first argument. After clustering is completed, the parameter <em>labelMap</em> contains a mapping from original node IDs to the ID of the cluster each node belongs to. Cluster IDs correspond to the ID of an arbitrarily chosen representative node within each cluster, i.e. they form a sparse subset of the original IDs.</p>
<p>Properties of the graph's edges and nodes are provided in the property maps <em>edgeWeights</em>, <em>edgeLengths</em>, <em>nodeFeatures</em>, and <em>nodeSizes</em>. These maps are indexed by edge or node ID and return the corresponding feature. Features must by arithmetic scalars or, in case of node features, scalars or vectors of scalars (precisely: objects that provide <code>begin()</code> and <code>end()</code> to create an STL range). Edge weights are typically derived from an edge indicator such as the gradient magnitude, and node features are either the responses of a filter family (when clustering on the pixel grid), or region statistics as computed by <a class="el" href="group__FeatureAccumulators.html">Feature Accumulators</a> (when clustering on superpixels).</p>
<p>In each step, the algorithm merges the two nodes <img class="formulaInl" alt="$u$" src="form_147.png"/> and <img class="formulaInl" alt="$v$" src="form_148.png"/> whose cluster distance is smallest, where the cluster distance is defined as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{uv} = \left( (1-\beta) w_{uv} + \beta || f_u - f_v ||_M \right) \cdot \frac{2}{s_u^{-\omega} + s_v^{-\omega}} \]" src="form_149.png"/>
</p>
<p>with <img class="formulaInl" alt="$ w_{uv} $" src="form_150.png"/> denoting the weight of edge <img class="formulaInl" alt="$uv$" src="form_151.png"/>, <img class="formulaInl" alt="$f_u$" src="form_152.png"/> and <img class="formulaInl" alt="$f_v$" src="form_153.png"/> being the node features (possibly vectors to be compared with metric <img class="formulaInl" alt="$M$" src="form_154.png"/>), and <img class="formulaInl" alt="$s_u$" src="form_155.png"/> and <img class="formulaInl" alt="$s_v$" src="form_156.png"/> the corresponding node sizes. The metric is defined in the option object by calling <a class="el" href="classvigra_1_1ClusteringOptions.html#a187d0df3070c97f5d5209f55e8829c2a">vigra::ClusteringOptions::nodeFeatureMetric()</a> and must be selected from the tags defined in <a class="el" href="namespacevigra_1_1metrics.html#a5a73aada416b5b8e3f549fb0caf28219">vigra::metrics::MetricType</a>.</p>
<p>The parameters <img class="formulaInl" alt="$0 \le \beta \le 1$" src="form_157.png"/> and <img class="formulaInl" alt="$0 \le \omega \le 1$" src="form_158.png"/> control the relative influence of the inputs: With <img class="formulaInl" alt="$\beta = 0$" src="form_159.png"/>, the node features are ignored, whereas with <img class="formulaInl" alt="$\beta = 1$" src="form_160.png"/> the edge weights are ignored. Similarly, with <img class="formulaInl" alt="$\omega = 0$" src="form_161.png"/>, the node size is ignored, whereas with <img class="formulaInl" alt="$\omega = 1$" src="form_162.png"/>, cluster distances are scaled by the harmonic mean of the cluster sizes, making the merging of small clusters more favorable. The parameters are defined in the option object by calling <a class="el" href="classvigra_1_1ClusteringOptions.html#abb103f1c2f82aff0cc36a48d07611225">vigra::ClusteringOptions::nodeFeatureImportance()</a> and <a class="el" href="classvigra_1_1ClusteringOptions.html#ac2d78cae72298b42bd03a370bf9a205d">vigra::ClusteringOptions::sizeImportance()</a> respectively.</p>
<p>After each merging step, the features of the resulting cluster <img class="formulaInl" alt="$z$" src="form_163.png"/> and the weights of its outgoing edges are updated by mean of the corresponding properties of the original clusters <img class="formulaInl" alt="$u$" src="form_147.png"/> and <img class="formulaInl" alt="$v$" src="form_148.png"/>, weighted by the respective node sizes <img class="formulaInl" alt="$s_z$" src="form_164.png"/> and edge lengths <img class="formulaInl" alt="$l_{zy}$" src="form_165.png"/>:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} s_z &amp; = &amp; s_u + s_v \\ f_z &amp; = &amp; \frac{s_u f_u + s_v f_v}{s_z} \\ l_{zy} &amp; = &amp; l_{uy} + l_{vy} \textrm{ for all nodes }y\textrm{ connected to }u\textrm{ or }v \\ w_{zy} &amp; = &amp; \frac{l_{uy} w_{uy} + l_{vy} w_{vy}}{l_{zy}} \end{eqnarray*}" src="form_166.png"/>
</p>
<p>Clustering normally stops when only one cluster remains. This default can be overridden by the option object parameters <a class="el" href="classvigra_1_1ClusteringOptions.html#a4b703bc8c4065b83152ffa193d5e3cff">vigra::ClusteringOptions::minRegionCount()</a> and <a class="el" href="classvigra_1_1ClusteringOptions.html#a8c0329571b8c51b46192f16580b29e27">vigra::ClusteringOptions::maxMergeDistance()</a> to stop at a particular number of clusters or a particular cluster distance respectively.</p>
<p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="hierarchical__clustering_8hxx_source.html">vigra/hierarchical_clustering.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<p>A fully worked example can be found in <a href="graph_agglomerative_clustering_8cxx-example.html">graph_agglomerative_clustering.cxx</a> </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="graph_agglomerative_clustering_8cxx-example.html#a21">graph_agglomerative_clustering.cxx</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.1 (Fri May 19 2017)
</i>
</tr>
</table>
</BODY>
</HTML>
