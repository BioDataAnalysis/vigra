<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Convolution filters for multi-dimensional arrays.</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{ 
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://hci.iwr.uni-heidelberg.de/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Convolution filters for multi-dimensional arrays.
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf819a613a16ee9807d69ecb2d91b2ae"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gaaf819a613a16ee9807d69ecb2d91b2ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT</a> (...)</td></tr>
<tr class="memdesc:gaaf819a613a16ee9807d69ecb2d91b2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve an array with a kernel by means of the Fourier transform.  <a href="#gaaf819a613a16ee9807d69ecb2d91b2ae">More...</a><br/></td></tr>
<tr class="separator:gaaf819a613a16ee9807d69ecb2d91b2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014b4e7d6d5154d5ad83170c6cb547f6"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga014b4e7d6d5154d5ad83170c6cb547f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga014b4e7d6d5154d5ad83170c6cb547f6">convolveFFTComplex</a> (...)</td></tr>
<tr class="memdesc:ga014b4e7d6d5154d5ad83170c6cb547f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a complex-valued array by means of the Fourier transform.  <a href="#ga014b4e7d6d5154d5ad83170c6cb547f6">More...</a><br/></td></tr>
<tr class="separator:ga014b4e7d6d5154d5ad83170c6cb547f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf555ec81ad059261e2bb8b5d03a0aa83"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gaf555ec81ad059261e2bb8b5d03a0aa83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gaf555ec81ad059261e2bb8b5d03a0aa83">convolveFFTComplexMany</a> (...)</td></tr>
<tr class="memdesc:gaf555ec81ad059261e2bb8b5d03a0aa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a complex-valued array with a sequence of kernels by means of the Fourier transform.  <a href="#gaf555ec81ad059261e2bb8b5d03a0aa83">More...</a><br/></td></tr>
<tr class="separator:gaf555ec81ad059261e2bb8b5d03a0aa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2598869b328eae9ff709387e0b758a0"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gae2598869b328eae9ff709387e0b758a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gae2598869b328eae9ff709387e0b758a0">convolveFFTMany</a> (...)</td></tr>
<tr class="memdesc:gae2598869b328eae9ff709387e0b758a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve a real-valued array with a sequence of kernels by means of the Fourier transform.  <a href="#gae2598869b328eae9ff709387e0b758a0">More...</a><br/></td></tr>
<tr class="separator:gae2598869b328eae9ff709387e0b758a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac82f89797cb83810e5a9ebddac36259b"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gac82f89797cb83810e5a9ebddac36259b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a> (...)</td></tr>
<tr class="memdesc:gac82f89797cb83810e5a9ebddac36259b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution along a single dimension of a multi-dimensional arrays.  <a href="#gac82f89797cb83810e5a9ebddac36259b">More...</a><br/></td></tr>
<tr class="separator:gac82f89797cb83810e5a9ebddac36259b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b019af5eba5f0654edde1fe6a0e2c2b"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga3b019af5eba5f0654edde1fe6a0e2c2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga3b019af5eba5f0654edde1fe6a0e2c2b">correlateFFT</a> (...)</td></tr>
<tr class="memdesc:ga3b019af5eba5f0654edde1fe6a0e2c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlate an array with a kernel by means of the Fourier transform.  <a href="#ga3b019af5eba5f0654edde1fe6a0e2c2b">More...</a><br/></td></tr>
<tr class="separator:ga3b019af5eba5f0654edde1fe6a0e2c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e603a8303c5af14dd8e709a63141fe"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga63e603a8303c5af14dd8e709a63141fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a> (...)</td></tr>
<tr class="memdesc:ga63e603a8303c5af14dd8e709a63141fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the divergence of a vector field using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters.  <a href="#ga63e603a8303c5af14dd8e709a63141fe">More...</a><br/></td></tr>
<tr class="separator:ga63e603a8303c5af14dd8e709a63141fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d5e9021732f13248ca3a0fe1b7c0552"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga4d5e9021732f13248ca3a0fe1b7c0552"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a> (...)</td></tr>
<tr class="memdesc:ga4d5e9021732f13248ca3a0fe1b7c0552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of a multi-dimensional arrays.  <a href="#ga4d5e9021732f13248ca3a0fe1b7c0552">More...</a><br/></td></tr>
<tr class="separator:ga4d5e9021732f13248ca3a0fe1b7c0552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d81ef630205d44b8517c464217207d"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga11d81ef630205d44b8517c464217207d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a> (...)</td></tr>
<tr class="memdesc:ga11d81ef630205d44b8517c464217207d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Isotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing of a multi-dimensional arrays.  <a href="#ga11d81ef630205d44b8517c464217207d">More...</a><br/></td></tr>
<tr class="separator:ga11d81ef630205d44b8517c464217207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae419814e55fb3191a87e7b75f505d4da"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gae419814e55fb3191a87e7b75f505d4da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a> (...)</td></tr>
<tr class="memdesc:gae419814e55fb3191a87e7b75f505d4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Hessian matrix of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters.  <a href="#gae419814e55fb3191a87e7b75f505d4da">More...</a><br/></td></tr>
<tr class="separator:gae419814e55fb3191a87e7b75f505d4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac165234c3bca25d3162cac15ceb2b970"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:gac165234c3bca25d3162cac15ceb2b970"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a> (...)</td></tr>
<tr class="memdesc:gac165234c3bca25d3162cac15ceb2b970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Laplacian of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters.  <a href="#gac165234c3bca25d3162cac15ceb2b970">More...</a><br/></td></tr>
<tr class="separator:gac165234c3bca25d3162cac15ceb2b970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c43f1c6fd2f6391c7a26de88545b8db"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga1c43f1c6fd2f6391c7a26de88545b8db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a> (...)</td></tr>
<tr class="memdesc:ga1c43f1c6fd2f6391c7a26de88545b8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separated convolution on multi-dimensional arrays.  <a href="#ga1c43f1c6fd2f6391c7a26de88545b8db">More...</a><br/></td></tr>
<tr class="separator:ga1c43f1c6fd2f6391c7a26de88545b8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6be0fb8e178b6b589e2441cc4ae0f54d"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga6be0fb8e178b6b589e2441cc4ae0f54d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a> (...)</td></tr>
<tr class="memdesc:ga6be0fb8e178b6b589e2441cc4ae0f54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate th structure tensor of a multi-dimensional arrays.  <a href="#ga6be0fb8e178b6b589e2441cc4ae0f54d">More...</a><br/></td></tr>
<tr class="separator:ga6be0fb8e178b6b589e2441cc4ae0f54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99cfc937dc06355aaf71b551a7c31faa"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga99cfc937dc06355aaf71b551a7c31faa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a> (...)</td></tr>
<tr class="memdesc:ga99cfc937dc06355aaf71b551a7c31faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate gradient of a multi-dimensional arrays using symmetric difference filters.  <a href="#ga99cfc937dc06355aaf71b551a7c31faa">More...</a><br/></td></tr>
<tr class="separator:ga99cfc937dc06355aaf71b551a7c31faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<p>These functions realize a separable convolution on an arbitrary dimensional array that is specified by iterators (compatible to <a class="el" href="MultiIteratorPage.html">Multi-dimensional Array Iterators</a>) and shape objects. It can therefore be applied to a wide range of data structures (<a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a>, <a class="el" href="classvigra_1_1MultiArray.html">vigra::MultiArray</a> etc.). </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1c43f1c6fd2f6391c7a26de88545b8db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::separableConvolveMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separated convolution on multi-dimensional arrays. </p>
<p>This function computes a separated convolution on all dimensions of the given multi-dimensional array. Both source and destination arrays are represented by iterators, shape objects and accessors. The destination array is required to already have the correct size.</p>
<p>There are two variants of this functions: one takes a single kernel of type <a class="el" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D</a> which is then applied to all dimensions, whereas the other requires an iterator referencing a sequence of <a class="el" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D</a> objects, one for every dimension of the data. Then the first kernel in this sequence is applied to the innermost dimension (e.g. the x-axis of an image), while the last is applied to the outermost dimension (e.g. the z-axis in a 3D image).</p>
<p>This function may work in-place, which means that <code>source.data() == dest.data()</code> is allowed. A full-sized internal array is only allocated if working on the destination array directly would cause round-off errors (i.e. if <code>typeid(typename NumericTraits&lt;T2&gt;::RealPromote) != typeid(T2)</code>).</p>
<p>If <code>start</code> and <code>stop</code> have non-default values, they must represent a valid subarray of the input array. The convolution is then restricted to that subarray, and it is assumed that the output array only refers to the subarray (i.e. <code>dest.shape() == stop - start</code>). Negative ROI boundaries are interpreted relative to the end of the respective dimension (i.e. <code>if(stop[k] &lt; 0) stop[k] += source.shape(k);</code>).</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// apply each kernel from the sequence &#39;kernels&#39; in turn</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,</div>
<div class="line">              <span class="keyword">class </span>KernelIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>,</div>
<div class="line">                                MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                                KernelIterator kernels,</div>
<div class="line">                                <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type start = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type(),</div>
<div class="line">                                <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type stop  = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// apply the same kernel to all dimensions</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,</div>
<div class="line">              <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                                Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel,</div>
<div class="line">                                <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type <span class="keyword">const</span> &amp; start = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type(),</div>
<div class="line">                                <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type <span class="keyword">const</span> &amp; stop = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type());</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="separableConvolveMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;separableConvolveMultiArray_OldAPI&apos;, &apos;separableConvolveMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="separableConvolveMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// apply the same kernel to all dimensions</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                                DestIterator diter, DestAccessor dest,</div>
<div class="line">                                Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel,</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// apply each kernel from the sequence &#39;kernels&#39; in turn</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>KernelIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                                DestIterator diter, DestAccessor dest,</div>
<div class="line">                                KernelIterator kernels,</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// apply the same kernel to all dimensions</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                                Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel,</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// apply each kernel from the sequence &#39;kernels&#39; in turn</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>KernelIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                                KernelIterator kernels,</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),</div>
<div class="line">                                SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt;         dest(shape);</div>
<div class="line">...</div>
<div class="line">Kernel1D&lt;<span class="keywordtype">float</span>&gt; gauss;</div>
<div class="line">gauss.initGaussian(sigma);</div>
<div class="line"></div>
<div class="line"><span class="comment">// smooth all dimensions with the same kernel</span></div>
<div class="line"><a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(source, dest, gauss);</div>
<div class="line"></div>
<div class="line"><span class="comment">// create 3 Gauss kernels, one for each dimension, but smooth the z-axis less</span></div>
<div class="line">ArrayVector&lt;Kernel1D&lt;float&gt; &gt; kernels(3, gauss);</div>
<div class="line">kernels[2].initGaussian(sigma / 2.0);</div>
<div class="line"></div>
<div class="line"><span class="comment">// perform Gaussian smoothing on all dimensions</span></div>
<div class="line"><a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(source, dest, kernels.begin());</div>
<div class="line"></div>
<div class="line"><span class="comment">// create output array for a ROI</span></div>
<div class="line">MultiArray&lt;3, float&gt; destROI(shape - <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a>(10,10,10));</div>
<div class="line"></div>
<div class="line"><span class="comment">// only smooth the given ROI (ignore 5 pixels on all sides of the array)</span></div>
<div class="line"><a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(source, destROI, gauss, <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a>(5,5,5), <a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a>(-5,-5,-5));</div>
</div><!-- fragment --><p><a href="#" id="separableConvolveMultiArray_OldUsageToggle" onclick="return toggleHiddenDocumentation(&apos;separableConvolveMultiArray_OldUsage&apos;, &apos;separableConvolveMultiArray_OldUsageToggle&apos;, &apos;deprecated examples&apos;);">show deprecated examples</a></p>
<div id="separableConvolveMultiArray_OldUsage" style="display:none"> <div class="fragment"><div class="line">MultiArray&lt;3, unsigned char&gt;::size_type shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt; dest(shape);</div>
<div class="line">...</div>
<div class="line">Kernel1D&lt;<span class="keywordtype">float</span>&gt; gauss;</div>
<div class="line">gauss.initGaussian(sigma);</div>
<div class="line"><span class="comment">// create 3 Gauss kernels, one for each dimension</span></div>
<div class="line">ArrayVector&lt;Kernel1D&lt;float&gt; &gt; kernels(3, gauss);</div>
<div class="line"></div>
<div class="line"><span class="comment">// perform Gaussian smoothing on all dimensions</span></div>
<div class="line"><a class="code" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray</a>(source, dest,</div>
<div class="line">                            kernels.begin());</div>
</div><!-- fragment --><p> <b> Required Interface:</b> </p>
<div class="fragment"><div class="line">see \ref separableConvolveImage(), in addition:</div>
<div class="line"></div>
<div class="line">NumericTraits&lt;T1&gt;::RealPromote s = src[0];</div>
<div class="line"></div>
<div class="line">s = s + s;</div>
<div class="line">s = kernel(0) * s;</div>
</div><!-- fragment --> </div><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel. ">vigra::Kernel1D</a>, <a class="el" href="group__SeparableConvolution.html#ga68b1efe52c497cfbaece1452515b6307" title="Performs a 1-dimensional convolution of the source signal using the given kernel. ...">convolveLine()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac82f89797cb83810e5a9ebddac36259b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convolveMultiArrayOneDimension </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolution along a single dimension of a multi-dimensional arrays. </p>
<p>This function computes a convolution along one dimension (specified by the parameter <code>dim</code> of the given multi-dimensional array with the given <code>kernel</code>. The destination array must already have the correct size.</p>
<p>If <code>start</code> and <code>stop</code> have non-default values, they must represent a valid subarray of the input array. The convolution is then restricted to that subarray, and it is assumed that the output array only refers to the subarray (i.e. <code>dest.shape() == stop - start</code>). Negative ROI boundaries are interpreted relative to the end of the respective dimension (i.e. <code>if(stop[k] &lt; 0) stop[k] += source.shape(k);</code>).</p>
<p>This function may work in-place, which means that <code>source.data() == dest.data()</code> is allowed.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2,</div>
<div class="line">              <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                   MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim,</div>
<div class="line">                                   Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel,</div>
<div class="line">                                   <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type start = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type(),</div>
<div class="line">                                   <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type stop  = <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type());</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="convolveMultiArrayOneDimension_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;convolveMultiArrayOneDimension_OldAPI&apos;, &apos;convolveMultiArrayOneDimension_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="convolveMultiArrayOneDimension_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                                   DestIterator diter, DestAccessor dest,</div>
<div class="line">                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <a class="code" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D&lt;T&gt;</a> <span class="keyword">const</span> &amp; kernel,</div>
<div class="line">                                   SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),</div>
<div class="line">                                   SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                   pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                                   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <a class="code" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D&lt;T&gt;</a> <span class="keyword">const</span> &amp; kernel,</div>
<div class="line">                                   SrcShape <span class="keyword">const</span> &amp; start = SrcShape(),</div>
<div class="line">                                   SrcShape <span class="keyword">const</span> &amp; stop = SrcShape());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt; dest(shape);</div>
<div class="line">...</div>
<div class="line">Kernel1D&lt;<span class="keywordtype">float</span>&gt; gauss;</div>
<div class="line">gauss.initGaussian(sigma);</div>
<div class="line"></div>
<div class="line"><span class="comment">// perform Gaussian smoothing along dimension 1 (height)</span></div>
<div class="line"><a class="code" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension</a>(source, dest, 1, gauss);</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays. ">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga11d81ef630205d44b8517c464217207d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::gaussianSmoothMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Isotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing of a multi-dimensional arrays. </p>
<p>This function computes an isotropic convolution of the given N-dimensional array with a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter at the given standard deviation <code>sigma</code>. Both source and destination arrays are represented by iterators, shape objects and accessors. The destination array is required to already have the correct size. This function may work in-place, which means that <code>source.data() == dest.data()</code> is allowed. It is implemented by a call to <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernel.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// pass filter scale explicitly</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                             MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                             <span class="keywordtype">double</span> sigma,</div>
<div class="line">                             ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass filer scale(s) in the option object</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                             MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                             ConvolutionOptions&lt;N&gt; opt);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// as above, but execute algorirhm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                             MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                             BlockwiseConvolutionOptions&lt;N&gt; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="gaussianSmoothMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianSmoothMultiArray_OldAPI&apos;, &apos;gaussianSmoothMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="gaussianSmoothMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                             DestIterator diter, DestAccessor dest,</div>
<div class="line">                             <span class="keywordtype">double</span> sigma,</div>
<div class="line">                             <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                             pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                             <span class="keywordtype">double</span> sigma,</div>
<div class="line">                             <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt;         dest(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// perform isotropic Gaussian smoothing at scale &#39;sigma&#39;</span></div>
<div class="line">gaussianSmoothMultiArray(source, dest, sigma);</div>
</div><!-- fragment --><p><b> Multi-threaded execution:</b></p>
<div class="fragment"><div class="line"><a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt;         dest(shape);</div>
<div class="line">...</div>
<div class="line">BlockwiseConvolutionOptions&lt;3&gt; opt;</div>
<div class="line">opt.numThreads(4);       <span class="comment">// use 4 threads (uses hardware default if not given)</span></div>
<div class="line">opt.innerScale(sigma);</div>
<div class="line"></div>
<div class="line"><span class="comment">// perform isotropic Gaussian smoothing at scale &#39;sigma&#39; in parallel</span></div>
<div class="line"><a class="code" href="group__MultiArrayConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d">gaussianSmoothMultiArray</a>(source, dest, sigma, opt);</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line"><a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt;         dest(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">TinyVector&lt;float, 3&gt; resolution_sigmas;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// perform anisotropic Gaussian smoothing at scale &#39;sigma&#39;</span></div>
<div class="line">gaussianSmoothMultiArray(source, dest, sigma,</div>
<div class="line">                         ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays. ">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d5e9021732f13248ca3a0fe1b7c0552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::gaussianGradientMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of a multi-dimensional arrays. </p>
<p>This function computes the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of the given N-dimensional array with a sequence of first-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code> (differentiation is applied to each dimension in turn, starting with the innermost dimension). The destination array is required to have a vector valued pixel type with as many elements as the number of dimensions. This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernels.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// pass filter scale explicitly</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                               MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,</div>
<div class="line">                               <span class="keywordtype">double</span> sigma,</div>
<div class="line">                               ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass filter scale(s) in option object</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                               MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,</div>
<div class="line">                               ConvolutionOptions&lt;N&gt; opt);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// likewise, but execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                               MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,</div>
<div class="line">                               BlockwiseConvolutionOptions&lt;N&gt; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="gaussianGradientMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;gaussianGradientMultiArray_OldAPI&apos;, &apos;gaussianGradientMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="gaussianGradientMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                               DestIterator diter, DestAccessor dest,</div>
<div class="line">                               <span class="keywordtype">double</span> sigma,</div>
<div class="line">                               <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552">gaussianGradientMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                               pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                               <span class="keywordtype">double</span> sigma,</div>
<div class="line">                               <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute Gaussian gradient at scale sigma</span></div>
<div class="line">gaussianGradientMultiArray(source, dest, sigma);</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line"><a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">TinyVector&lt;float, 3&gt; resolution_sigmas;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute Gaussian gradient at scale sigma</span></div>
<div class="line">gaussianGradientMultiArray(source, dest, sigma,</div>
<div class="line">                           ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays. ">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga99cfc937dc06355aaf71b551a7c31faa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::symmetricGradientMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate gradient of a multi-dimensional arrays using symmetric difference filters. </p>
<p>This function computes the gradient of the given N-dimensional array with a sequence of symmetric difference filters a (differentiation is applied to each dimension in turn, starting with the innermost dimension). The destination array is required to have a vector valued pixel type with as many elements as the number of dimensions. This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b">convolveMultiArrayOneDimension()</a> with the symmetric difference kernel.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// execute algorithm sequentially</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,</div>
<div class="line">                                ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                MultiArrayView&lt;N, TinyVector&lt;T2, N&gt;, S2&gt; dest,</div>
<div class="line">                                BlockwiseConvolutionOptions&lt;N&gt; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="symmetricGradientMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;symmetricGradientMultiArray_OldAPI&apos;, &apos;symmetricGradientMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="symmetricGradientMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                                DestIterator diter, DestAccessor dest,</div>
<div class="line">                                <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa">symmetricGradientMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                                <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line">MultiArray&lt;3, unsigned char&gt;::size_type shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute gradient</span></div>
<div class="line">symmetricGradientMultiArray(srcMultiArrayRange(source), destMultiArray(dest));</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line"><a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, unsigned char&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute gradient</span></div>
<div class="line">symmetricGradientMultiArray(source, dest,</div>
<div class="line">                            ConvolutionOptions&lt;3&gt;().stepSize(step_size));</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#gac82f89797cb83810e5a9ebddac36259b" title="Convolution along a single dimension of a multi-dimensional arrays. ">convolveMultiArrayOneDimension()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac165234c3bca25d3162cac15ceb2b970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::laplacianOfGaussianMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate Laplacian of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters. </p>
<p>This function computes the Laplacian of the given N-dimensional array with a sequence of second-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code>. Both source and destination arrays must have scalar value_type. This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernels, followed by summation.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// pass scale explicitly</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                  MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                                  <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                  ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass scale(s) in option object</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                  MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                                  ConvolutionOptions&lt;N&gt; opt );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// likewise, but execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                  MultiArrayView&lt;N, T2, S2&gt; dest,</div>
<div class="line">                                  BlockwiseConvolutionOptions&lt;N&gt; opt );</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="laplacianOfGaussianMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;laplacianOfGaussianMultiArray_OldAPI&apos;, &apos;laplacianOfGaussianMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="laplacianOfGaussianMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                                  DestIterator diter, DestAccessor dest,</div>
<div class="line">                                  <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                  <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970">laplacianOfGaussianMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                  pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                                  <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                  <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, float&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt; laplacian(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute Laplacian at scale sigma</span></div>
<div class="line">laplacianOfGaussianMultiArray(source, laplacian, sigma);</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line">MultiArray&lt;3, float&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt; laplacian(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">TinyVector&lt;float, 3&gt; resolution_sigmas;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute Laplacian at scale sigma</span></div>
<div class="line">laplacianOfGaussianMultiArray(source, laplacian, sigma,</div>
<div class="line">                              ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays. ">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga63e603a8303c5af14dd8e709a63141fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::gaussianDivergenceMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the divergence of a vector field using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters. </p>
<p>This function computes the divergence of the given N-dimensional vector field with a sequence of first-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code>. The input vector field can either be given as a sequence of scalar array views (one for each vector field component), represented by an iterator range, or by a single vector array with the appropriate shape. This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the suitable kernels, followed by summation.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// specify input vector field as a sequence of scalar arrays</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>Iterator,</div>
<div class="line">              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T, <span class="keyword">class </span>S&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a>(Iterator vectorField, Iterator vectorFieldEnd,</div>
<div class="line">                                 MultiArrayView&lt;N, T, S&gt; divergence,</div>
<div class="line">                                 ConvolutionOptions&lt;N&gt; <span class="keyword">const</span> &amp; opt);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>Iterator,</div>
<div class="line">              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T, <span class="keyword">class </span>S&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a>(Iterator vectorField, Iterator vectorFieldEnd,</div>
<div class="line">                                 MultiArrayView&lt;N, T, S&gt; divergence,</div>
<div class="line">                                 <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                 ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass input vector field as an array of vectors</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a>(MultiArrayView&lt;N, TinyVector&lt;T1, N&gt;, S1&gt; <span class="keyword">const</span> &amp; vectorField,</div>
<div class="line">                                 MultiArrayView&lt;N, T2, S2&gt; divergence,</div>
<div class="line">                                 ConvolutionOptions&lt;N&gt; <span class="keyword">const</span> &amp; opt);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a>(MultiArrayView&lt;N, TinyVector&lt;T1, N&gt;, S1&gt; <span class="keyword">const</span> &amp; vectorField,</div>
<div class="line">                                 MultiArrayView&lt;N, T2, S2&gt; divergence,</div>
<div class="line">                                 <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                 ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass input vector field as an array of vectors and</span></div>
<div class="line">    <span class="comment">// execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe">gaussianDivergenceMultiArray</a>(MultiArrayView&lt;N, TinyVector&lt;T1, N&gt;, S1&gt; <span class="keyword">const</span> &amp; vectorField,</div>
<div class="line">                                 MultiArrayView&lt;N, T2, S2&gt; divergence,</div>
<div class="line">                                 BlockwiseConvolutionOptions&lt;N&gt; <span class="keyword">const</span> &amp; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt; laplacian(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute divergence at scale sigma</span></div>
<div class="line">gaussianDivergenceMultiArray(source, laplacian, sigma);</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line">MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, float&gt; laplacian(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">TinyVector&lt;float, 3&gt; resolution_sigmas;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute divergence at scale sigma</span></div>
<div class="line">gaussianDivergenceMultiArray(source, laplacian, sigma,</div>
<div class="line">                             ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gae419814e55fb3191a87e7b75f505d4da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::hessianOfGaussianMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate Hessian matrix of a N-dimensional arrays using <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative filters. </p>
<p>This function computes the Hessian matrix the given scalar N-dimensional array with a sequence of second-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code>. The destination array must have a vector valued element type with N*(N+1)/2 elements (it represents the upper triangular part of the symmetric Hessian matrix, flattened row-wise). This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernels.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameter <code>sigma</code> is omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// pass scale explicitly</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,</div>
<div class="line">                                <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass scale(s) in option object</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,</div>
<div class="line">                                ConvolutionOptions&lt;N&gt; opt);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// likewise, but execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,</div>
<div class="line">                                BlockwiseConvolutionOptions&lt;N&gt; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="hessianOfGaussianMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;hessianOfGaussianMultiArray_OldAPI&apos;, &apos;hessianOfGaussianMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="hessianOfGaussianMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                                DestIterator diter, DestAccessor dest,</div>
<div class="line">                                <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da">hessianOfGaussianMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                                pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                                <span class="keywordtype">double</span> sigma,</div>
<div class="line">                                <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, float&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 6&gt; &gt; dest(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute Hessian at scale sigma</span></div>
<div class="line">hessianOfGaussianMultiArray(source, dest, sigma);</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line">MultiArray&lt;3, float&gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 6&gt; &gt; dest(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">TinyVector&lt;float, 3&gt; resolution_sigmas;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute Hessian at scale sigma</span></div>
<div class="line">hessianOfGaussianMultiArray(source, dest, sigma,</div>
<div class="line">                            ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays. ">separableConvolveMultiArray()</a>, <a class="el" href="group__MultiPointoperators.html#gad869b7b263b104e005a1ddc66b5c1f80" title="Calculate the tensor (outer) product of a N-D vector with itself. ">vectorToTensorMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6be0fb8e178b6b589e2441cc4ae0f54d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::structureTensorMultiArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate th structure tensor of a multi-dimensional arrays. </p>
<p>This function computes the gradient (outer product) tensor for each element of the given N-dimensional array with first-derivative-of-Gaussian filters at the given <code>innerScale</code>, followed by <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing at <code>outerScale</code>. The destination array must have a vector valued pixel type with N*(N+1)/2 elements (it represents the upper triangular part of the symmetric structure tensor matrix, flattened row-wise). If the source array is also vector valued, the resulting structure tensor is the sum of the individual tensors for each channel. This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> with the appropriate kernels.</p>
<p>Anisotropic data should be provided with appropriate <a class="el" href="classvigra_1_1ConvolutionOptions.html">vigra::ConvolutionOptions</a> to adjust the filter sizes for the resolution of each axis. Otherwise, the parameter <code>opt</code> is optional unless the parameters <code>innerScale</code> and <code>outerScale</code> are both omitted.</p>
<p>If you pass <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">vigra::BlockwiseConvolutionOptions</a> instead, the algorithm will be executed in parallel on data blocks of a certain size. The block size can be customized via <code><a class="el" href="classvigra_1_1BlockwiseOptions.html#a4d7f3d92e9680d53189f3c34c95b9f96">BlockwiseConvolutionOptions::blockShape()</a></code>, but the defaults usually work reasonably. By default, the number of threads equals the capabilities of your hardware, but you can change this via <code>BlockwiseConvolutionOptions::numThreads()</code>.</p>
<p><b> Declarations:</b></p>
<p>pass arbitrary-dimensional array views: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// pass scales explicitly</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                              MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,</div>
<div class="line">                              <span class="keywordtype">double</span> innerScale, <span class="keywordtype">double</span> outerScale,</div>
<div class="line">                              ConvolutionOptions&lt;N&gt; opt = ConvolutionOptions&lt;N&gt;());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass scales in option object</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                              MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,</div>
<div class="line">                              ConvolutionOptions&lt;N&gt; opt );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// likewise, but execute algorithm in parallel</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>T1, <span class="keyword">class </span>S1,</div>
<div class="line">                              <span class="keyword">class </span>T2, <span class="keyword">class </span>S2&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a>(MultiArrayView&lt;N, T1, S1&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                              MultiArrayView&lt;N, TinyVector&lt;T2, <span class="keywordtype">int</span>(N*(N+1)/2)&gt;, S2&gt; dest,</div>
<div class="line">                              BlockwiseConvolutionOptions&lt;N&gt; opt );</div>
<div class="line">}</div>
</div><!-- fragment --><p><a href="#" id="structureTensorMultiArray_OldAPIToggle" onclick="return toggleHiddenDocumentation(&apos;structureTensorMultiArray_OldAPI&apos;, &apos;structureTensorMultiArray_OldAPIToggle&apos;, &apos;deprecated declarations&apos;);">show deprecated declarations</a></p>
<div id="structureTensorMultiArray_OldAPI" style="display:none"> pass <a class="el" href="MultiIteratorPage.html">MultiIterators</a> and <a class="el" href="group__DataAccessors.html">Data Accessors</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,</div>
<div class="line">                              DestIterator diter, DestAccessor dest,</div>
<div class="line">                              <span class="keywordtype">double</span> innerScale, <span class="keywordtype">double</span> outerScale,</div>
<div class="line">                              ConvolutionOptions&lt;N&gt; opt);</div>
<div class="line">}</div>
</div><!-- fragment --><p> use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,</div>
<div class="line">              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d">structureTensorMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,</div>
<div class="line">                              pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,</div>
<div class="line">                              <span class="keywordtype">double</span> innerScale, <span class="keywordtype">double</span> outerScale,</div>
<div class="line">                              <span class="keyword">const</span> ConvolutionOptions&lt;N&gt; &amp; opt);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__convolution_8hxx_source.html">vigra/multi_convolution.hxx</a>&gt; (sequential version)<br/>
 <b>#include</b> &lt;<a class="el" href="multi__blockwise_8hxx_source.html">vigra/multi_blockwise.hxx</a>&gt; (parallel version)<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><a class="code" href="group__MultiIteratorGroup.html#gac70cfe6730d928789a2b3ce1f37ae379">Shape3</a> shape(width, height, depth);</div>
<div class="line">MultiArray&lt;3, RGBValue&lt;float&gt; &gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 6&gt; &gt; dest(shape);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute structure tensor at scales innerScale and outerScale</span></div>
<div class="line">structureTensorMultiArray(source, dest, innerScale, outerScale);</div>
</div><!-- fragment --><p><b> Usage with anisotropic data:</b></p>
<div class="fragment"><div class="line">MultiArray&lt;3, RGBValue&lt;float&gt; &gt; <a class="code" href="group__BoostGraphExtensions.html#ga0878243765124ed4e6589b09904a1568">source</a>(shape);</div>
<div class="line">MultiArray&lt;3, TinyVector&lt;float, 6&gt; &gt; dest(shape);</div>
<div class="line">TinyVector&lt;float, 3&gt; step_size;</div>
<div class="line">TinyVector&lt;float, 3&gt; resolution_sigmas;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// compute structure tensor at scales innerScale and outerScale</span></div>
<div class="line">structureTensorMultiArray(source, dest, innerScale, outerScale,</div>
<div class="line">                          ConvolutionOptions&lt;3&gt;().stepSize(step_size).resolutionStdDev(resolution_sigmas));</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db" title="Separated convolution on multi-dimensional arrays. ">separableConvolveMultiArray()</a>, <a class="el" href="group__MultiPointoperators.html#gad869b7b263b104e005a1ddc66b5c1f80" title="Calculate the tensor (outer) product of a N-D vector with itself. ">vectorToTensorMultiArray()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf819a613a16ee9807d69ecb2d91b2ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convolveFFT </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve an array with a kernel by means of the Fourier transform. </p>
<p>Thanks to the convolution theorem of Fourier theory, a convolution in the spatial domain is equivalent to a multiplication in the frequency domain. Thus, for certain kernels (especially large, non-separable ones), it is advantageous to perform the convolution by first transforming both array and kernel to the frequency domain, multiplying the frequency representations, and transforming the result back into the spatial domain. Some kernels have a much simpler definition in the frequency domain, so that they are readily computed there directly, avoiding Fourier transformation of those kernels.</p>
<p>The following functions implement various variants of FFT-based convolution:</p>
<dl>
<dt><b>convolveFFT</b></dt>
<dd>Convolve a real-valued input array with a kernel such that the result is also real-valued. That is, the kernel is either provided as a real-valued array in the spatial domain, or as a complex-valued array in the Fourier domain, using the half-space format of the R2C Fourier transform (see below). </dd>
<dt><b>convolveFFTMany</b></dt>
<dd>Like <code>convolveFFT</code>, but you may provide many kernels at once (using an iterator pair specifying the kernel sequence). This has the advantage that the forward transform of the input array needs to be executed only once. </dd>
<dt><b>convolveFFTComplex</b></dt>
<dd>Convolve a complex-valued input array with a complex-valued kernel, resulting in a complex-valued output array. An additional flag is used to specify whether the kernel is defined in the spatial or frequency domain. </dd>
<dt><b>convolveFFTComplexMany</b></dt>
<dd>Like <code>convolveFFTComplex</code>, but you may provide many kernels at once (using an iterator pair specifying the kernel sequence). This has the advantage that the forward transform of the input array needs to be executed only once. </dd>
</dl>
<p>The output arrays must have the same shape as the input arrays. In the "Many" variants of the convolution functions, the kernels must all have the same shape.</p>
<p>The origin of the kernel is always assumed to be in the center of the kernel array (precisely, at the point <code>floor(kernel.shape() / 2.0)</code>, except when the half-space format is used, see below). The function <a class="el" href="group__FourierTransform.html#gaee27c376079af99e8e2148e7d23ffbbb">moveDCToUpperLeft()</a> will be called internally to align the kernel with the transformed input as appropriate.</p>
<p>If a real input is combined with a real kernel, the kernel is automatically assumed to be defined in the spatial domain. If a real input is combined with a complex kernel, the kernel is assumed to be defined in the Fourier domain in half-space format. If the input array is complex, a flag <code>fourierDomainKernel</code> determines where the kernel is defined.</p>
<p>When the kernel is defined in the spatial domain, the convolution functions will automatically pad (enlarge) the input array by at least the kernel radius in each direction. The newly added space is filled according to reflective boundary conditions in order to minimize border artifacts during convolution. It is thus ensured that convolution in the Fourier domain yields the same results as convolution in the spatial domain (e.g. when <a class="el" href="group__MultiArrayConvolutionFilters.html#ga1c43f1c6fd2f6391c7a26de88545b8db">separableConvolveMultiArray()</a> is called with the same kernel). A little further padding may be added to make sure that the padded array shape uses integers which have only small prime factors, because FFTW is then able to use the fastest possible algorithms. <a class="el" href="classvigra_1_1Any.html" title="Typesafe storage of arbitrary values. ">Any</a> padding is automatically removed from the result arrays before the function returns.</p>
<p>When the kernel is defined in the frequency domain, it must be complex-valued, and its shape determines the shape of the Fourier representation (i.e. the input is padded according to the shape of the kernel). If we are going to perform a complex-valued convolution, the kernel must be defined for the entire frequency domain, and its shape directly determines the size of the FFT.</p>
<p>In contrast, a frequency domain kernel for a real-valued convolution must have symmetry properties that allow to drop half of the kernel coefficients, as in the <a href="http://www.fftw.org/doc/Multi_002dDimensional-DFTs-of-Real-Data.html">R2C transform</a>. That is, the kernel must have the <em>half-space format</em>, that is the shape returned by <code>fftwCorrespondingShapeR2C(fourier_shape)</code>, where <code>fourier_shape</code> is the desired logical shape of the frequency representation (and thus the size of the padded input). The origin of the kernel must be at the point <code>(0, floor(fourier_shape[0] / 2.0), ..., floor(fourier_shape[N-1] / 2.0))</code> (i.e. as in a regular kernel except for the first dimension).</p>
<p>The <code>Real</code> type in the declarations can be <code>double</code>, <code>float</code>, and <code>long double</code>. Your program must always link against <code>libfftw3</code>. If you use <code>float</code> or <code>long double</code> arrays, you must <em>additionally</em> link against <code>libfftw3f</code> and <code>libfftw3l</code> respectively.</p>
<p>The Fourier transform functions internally create <a href="http://www.fftw.org/doc/Using-Plans.html">FFTW plans</a> which control the algorithm details. The plans are created with the flag <code>FFTW_ESTIMATE</code>, i.e. optimal settings are guessed or read from saved "wisdom" files. If you need more control over planning, you can use the class <a class="el" href="classvigra_1_1FFTWConvolvePlan.html">FFTWConvolvePlan</a>.</p>
<p>See also <a class="el" href="group__FourierTransform.html#gad51931cfe91ece316e28ff9d7ff28377">applyFourierFilter()</a> for corresponding functionality on the basis of the old image iterator interface.</p>
<p><b> Declarations:</b></p>
<p>Real-valued convolution with kernel in the spatial domain: </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;</div>
<div class="line">    <span class="keywordtype">void</span> </div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT</a>(MultiArrayView&lt;N, Real, C1&gt; in, </div>
<div class="line">                MultiArrayView&lt;N, Real, C2&gt; kernel,</div>
<div class="line">                MultiArrayView&lt;N, Real, C3&gt; out);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Real-valued convolution with kernel in the Fourier domain (half-space format): </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;</div>
<div class="line">    <span class="keywordtype">void</span> </div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT</a>(MultiArrayView&lt;N, Real, C1&gt; in, </div>
<div class="line">                MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,</div>
<div class="line">                MultiArrayView&lt;N, Real, C3&gt; out);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Series of real-valued convolutions with kernels in the spatial or Fourier domain (the kernel and out sequences must have the same length): </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>Real, <span class="keyword">class </span>C1, </div>
<div class="line">              <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>OutIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span> </div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gae2598869b328eae9ff709387e0b758a0">convolveFFTMany</a>(MultiArrayView&lt;N, Real, C1&gt; in, </div>
<div class="line">                    KernelIterator kernels, KernelIterator kernelsEnd,</div>
<div class="line">                    OutIterator outs);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Complex-valued convolution (parameter <code>fourierDomainKernel</code> determines if the kernel is defined in the spatial or Fourier domain): </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga014b4e7d6d5154d5ad83170c6cb547f6">convolveFFTComplex</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in,</div>
<div class="line">                       MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C2&gt; kernel,</div>
<div class="line">                       MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C3&gt; out,</div>
<div class="line">                       <span class="keywordtype">bool</span> fourierDomainKernel);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Series of complex-valued convolutions (parameter <code>fourierDomainKernel</code> determines if the kernels are defined in the spatial or Fourier domain, the kernel and out sequences must have the same length): </p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class </span>Real, <span class="keyword">class </span>C1, </div>
<div class="line">              <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>OutIterator&gt;</div>
<div class="line">    <span class="keywordtype">void</span> </div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#gaf555ec81ad059261e2bb8b5d03a0aa83">convolveFFTComplexMany</a>(MultiArrayView&lt;N, FFTWComplex&lt;Real&gt;, C1&gt; in, </div>
<div class="line">                           KernelIterator kernels, KernelIterator kernelsEnd,</div>
<div class="line">                           OutIterator outs,</div>
<div class="line">                           <span class="keywordtype">bool</span> fourierDomainKernel);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__fft_8hxx_source.html">vigra/multi_fft.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><span class="comment">// convolve real array with a Gaussian (sigma=1) defined in the spatial domain</span></div>
<div class="line"><span class="comment">// (implicitly uses padding by at least 4 pixels)</span></div>
<div class="line">MultiArray&lt;2, double&gt; src(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b">Shape2</a>(w, h)), dest(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b">Shape2</a>(w,h));</div>
<div class="line"></div>
<div class="line">MultiArray&lt;2, double&gt; spatial_kernel(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b">Shape2</a>(9, 9));</div>
<div class="line">Gaussian&lt;double&gt; gauss(1.0);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;9; ++y)</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;9; ++x)</div>
<div class="line">        spatial_kernel(x, y) = gauss(x-4.0)*gauss(y-4.0);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT</a>(src, spatial_kernel, dest);</div>
<div class="line"></div>
<div class="line"><span class="comment">// convolve real array with a Gaussian (sigma=1) defined in the Fourier domain</span></div>
<div class="line"><span class="comment">// (uses no padding, because the kernel size corresponds to the input size)</span></div>
<div class="line">MultiArray&lt;2, FFTWComplex&lt;double&gt; &gt; fourier_kernel(<a class="code" href="group__FourierTransform.html#gafbea828444f49163293b1d81fcd05da8">fftwCorrespondingShapeR2C</a>(src.shape()));</div>
<div class="line"><span class="keywordtype">int</span> y0 = h / 2;</div>
<div class="line">    </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;fourier_kernel.shape(1); ++y)</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;fourier_kernel.shape(0); ++x)</div>
<div class="line">        fourier_kernel(x, y) = <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>(-0.5*<a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e">sq</a>(x / <span class="keywordtype">double</span>(w))) * <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>(-0.5*<a class="code" href="group__MathFunctions.html#ga5fe62e7b0dc6f379dd436c9c8338c93e">sq</a>((y-y0)/<span class="keywordtype">double</span>(h)));</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT</a>(src, fourier_kernel, dest);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga014b4e7d6d5154d5ad83170c6cb547f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convolveFFTComplex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve a complex-valued array by means of the Fourier transform. </p>
<p>See <a class="el" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT()</a> for details. </p>

</div>
</div>
<a class="anchor" id="gae2598869b328eae9ff709387e0b758a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convolveFFTMany </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve a real-valued array with a sequence of kernels by means of the Fourier transform. </p>
<p>See <a class="el" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT()</a> for details. </p>

</div>
</div>
<a class="anchor" id="gaf555ec81ad059261e2bb8b5d03a0aa83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::convolveFFTComplexMany </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolve a complex-valued array with a sequence of kernels by means of the Fourier transform. </p>
<p>See <a class="el" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT()</a> for details. </p>

</div>
</div>
<a class="anchor" id="ga3b019af5eba5f0654edde1fe6a0e2c2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::correlateFFT </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlate an array with a kernel by means of the Fourier transform. </p>
<p>This function correlates a real-valued input array with a real-valued kernel such that the result is also real-valued. Thanks to the correlation theorem of Fourier theory, a correlation in the spatial domain is equivalent to a multiplication with the complex conjugate in the frequency domain. Thus, for certain kernels (especially large, non-separable ones), it is advantageous to perform the correlation by first transforming both array and kernel to the frequency domain, multiplying the frequency representations, and transforming the result back into the spatial domain.</p>
<p>The output arrays must have the same shape as the input arrays.</p>
<p>See also <a class="el" href="group__MultiArrayConvolutionFilters.html#gaaf819a613a16ee9807d69ecb2d91b2ae">convolveFFT()</a> for corresponding functionality.</p>
<p><b> Declarations:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> Real, <span class="keyword">class</span> C1, <span class="keyword">class</span> C2, <span class="keyword">class</span> C3&gt;</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">    <a class="code" href="group__MultiArrayConvolutionFilters.html#ga3b019af5eba5f0654edde1fe6a0e2c2b">correlateFFT</a>(MultiArrayView&lt;N, Real, C1&gt; in,</div>
<div class="line">                 MultiArrayView&lt;N, Real, C2&gt; kernel,</div>
<div class="line">                 MultiArrayView&lt;N, Real, C3&gt; out);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b> Usage:</b></p>
<p><b>#include</b> &lt;<a class="el" href="multi__fft_8hxx_source.html">vigra/multi_fft.hxx</a>&gt;<br/>
 Namespace: vigra</p>
<div class="fragment"><div class="line"><span class="comment">// correlate real array with a template to find best matches</span></div>
<div class="line"><span class="comment">// (implicitly uses padding by at least 4 pixels)</span></div>
<div class="line">MultiArray&lt;2, double&gt; src(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b">Shape2</a>(w, h)), dest(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b">Shape2</a>(w, h));</div>
<div class="line"></div>
<div class="line">MultiArray&lt;2, double&gt; <span class="keyword">template</span>(<a class="code" href="group__MultiIteratorGroup.html#ga2e2ffc107bb0e38f9b1288b647c8ec5b">Shape2</a>(9, 9));</div>
<div class="line"><span class="keyword">template</span> = ...; </div>
<div class="line"></div>
<div class="line"><a class="code" href="group__MultiArrayConvolutionFilters.html#ga3b019af5eba5f0654edde1fe6a0e2c2b">correlateFFT</a>(src, <span class="keyword">template</span>, dest);</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.0 (Thu Feb 4 2016)
</i>
</tr>
</table>
</BODY>
</HTML>
