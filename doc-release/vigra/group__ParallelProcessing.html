<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Parallel Processing</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
<script>
var runOnLoad=function(c,o,d,e){function x(){for(e=1;c.length;)c.shift()()}o[d]?(document[d]('DOMContentLoaded',x,0),o[d]('load',x,0)):o.attachEvent('onload',x);return function(t){e?o.setTimeout(t,0):c.push(t)}}([],window,'addEventListener');
</script>
<script type="text/javascript" src="documents/CollapsibleLists.js"></script>
<script type="text/javascript">
    runOnLoad(function(){ CollapsibleLists.apply(); });
</script>
<style type="text/css">
.collapsibleList li.collapsibleListOpen{
  list-style-image:url('documents/pfeil.gif');
  cursor:pointer;
}
.collapsibleList li.collapsibleListClosed{
  list-style-image:url('documents/bullet.gif');
  cursor:pointer;
}
.collapsibleList li.lastItem{
  list-style-image:url('documents/diamond.gif');
}
</style>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://ukoethe.github.io/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" title="Detailed Description" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Parallel Processing<div class="ingroups"><a class="el" href="group__Labeling.html">Connected Components Labeling</a> &#124; <a class="el" href="group__Superpixels.html">Superpixel Creation</a> &#124; <a class="el" href="group__ConvolutionFilters.html">Convolution Filters</a> &#124; <a class="el" href="group__ChunkedArrayClasses.html">Chunked arrays</a></div>
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ParallelOptions.html">ParallelOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option base class for parallel algorithms.  <a href="classvigra_1_1ParallelOptions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1ThreadPool.html">ThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread pool class to manage a set of parallel workers.  <a href="classvigra_1_1ThreadPool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6321ed04dae9c5a2ab8bccf07dd52cb6"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ga6321ed04dae9c5a2ab8bccf07dd52cb6"><td class="memTemplItemLeft" align="right" valign="top">threading::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelProcessing.html#ga6321ed04dae9c5a2ab8bccf07dd52cb6">enqueue</a> (F &amp;&amp;f)</td></tr>
<tr class="separator:ga6321ed04dae9c5a2ab8bccf07dd52cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga022c9a3cb8bdfb82fe60bdc78516871e"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ga022c9a3cb8bdfb82fe60bdc78516871e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelProcessing.html#ga022c9a3cb8bdfb82fe60bdc78516871e">enqueueReturning</a> (F &amp;&amp;f) -&gt; threading::future&lt; decltype(f(0))&gt;</td></tr>
<tr class="separator:ga022c9a3cb8bdfb82fe60bdc78516871e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6139933445e70682b4fa9017cd660d22"><td class="memTemplParams" colspan="2">template&lt;... &gt; </td></tr>
<tr class="memitem:ga6139933445e70682b4fa9017cd660d22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelProcessing.html#ga6139933445e70682b4fa9017cd660d22">parallel_foreach</a> (...)</td></tr>
<tr class="memdesc:ga6139933445e70682b4fa9017cd660d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to all items in a range in parallel.  <a href="#ga6139933445e70682b4fa9017cd660d22">More...</a><br/></td></tr>
<tr class="separator:ga6139933445e70682b4fa9017cd660d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad41a30b11a0c9d8566ca1a53b4cf43f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelProcessing.html#gad41a30b11a0c9d8566ca1a53b4cf43f6">~ThreadPool</a> ()</td></tr>
<tr class="separator:gad41a30b11a0c9d8566ca1a53b4cf43f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="_details" id="details"></a><h2 class="details_section">Detailed Description</h2>
<dl class="section see"><dt>See Also</dt><dd>These algorithms and data structures also support parallel processing:</dd>
<dd>
<a class="el" href="group__Labeling.html#gaa9620d88f3ff8e9b676088c5416d5ee4" title="Connected components labeling for MultiArrays and ChunkedArrays. ">labelMultiArrayBlockwise</a> <b>(...)</b></dd>
<dd>
<a class="el" href="group__Superpixels.html#ga76433bac4c15c965da8fdd108c86bd2e" title="Blockwise union-find watersheds transform for MultiArrays and ChunkedArrays. ">unionFindWatershedsBlockwise</a> <b>(...)</b></dd>
<dd>
<a class="el" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855" title="Calculate the gradient magnitude by means of a 1st derivatives of Gaussian filter. ">gaussianGradientMagnitude</a> <b>(...,</b> <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">BlockwiseConvolutionOptions</a><b>)</b></dd>
<dd>
<a class="el" href="classvigra_1_1ChunkedArray.html" title="Interface and base class for chunked arrays. ">ChunkedArray</a></dd>
<dd>
<a class="el" href="classvigra_1_1ChunkedArrayFull.html">ChunkedArrayFull</a></dd>
<dd>
<a class="el" href="classvigra_1_1ChunkedArrayLazy.html">ChunkedArrayLazy</a></dd>
<dd>
<a class="el" href="classvigra_1_1ChunkedArrayCompressed.html">ChunkedArrayCompressed</a></dd>
<dd>
<a class="el" href="classvigra_1_1ChunkedArrayTmpFile.html">ChunkedArrayTmpFile</a></dd>
<dd>
<a class="el" href="classvigra_1_1ChunkedArrayHDF5.html">ChunkedArrayHDF5</a></dd>
<dd>
<a class="el" href="group__ConvolutionFilters.html#ga11d81ef630205d44b8517c464217207d" title="Isotropic Gaussian smoothing of a multi-dimensional arrays. ">gaussianSmoothMultiArray</a> <b>(...,</b> <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">BlockwiseConvolutionOptions</a><b>)</b></dd>
<dd>
<a class="el" href="group__ConvolutionFilters.html#ga4d5e9021732f13248ca3a0fe1b7c0552" title="Calculate Gaussian gradient of a multi-dimensional arrays. ">gaussianGradientMultiArray</a> <b>(...,</b> <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">BlockwiseConvolutionOptions</a><b>)</b></dd>
<dd>
<a class="el" href="group__ConvolutionFilters.html#ga99cfc937dc06355aaf71b551a7c31faa" title="Calculate gradient of a multi-dimensional arrays using symmetric difference filters. ">symmetricGradientMultiArray</a> <b>(...,</b> <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">BlockwiseConvolutionOptions</a><b>)</b></dd>
<dd>
<a class="el" href="group__ConvolutionFilters.html#gac165234c3bca25d3162cac15ceb2b970" title="Calculate Laplacian of a N-dimensional arrays using Gaussian derivative filters. ">laplacianOfGaussianMultiArray</a> <b>(...,</b> <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">BlockwiseConvolutionOptions</a><b>)</b></dd>
<dd>
<a class="el" href="group__ConvolutionFilters.html#ga63e603a8303c5af14dd8e709a63141fe" title="Calculate the divergence of a vector field using Gaussian derivative filters. ">gaussianDivergenceMultiArray</a> <b>(...,</b> <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">BlockwiseConvolutionOptions</a><b>)</b></dd>
<dd>
<a class="el" href="group__ConvolutionFilters.html#gae419814e55fb3191a87e7b75f505d4da" title="Calculate Hessian matrix of a N-dimensional arrays using Gaussian derivative filters. ">hessianOfGaussianMultiArray</a> <b>(...,</b> <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">BlockwiseConvolutionOptions</a><b>)</b></dd>
<dd>
<a class="el" href="group__ConvolutionFilters.html#ga6be0fb8e178b6b589e2441cc4ae0f54d" title="Calculate the structure tensor of a multi-dimensional arrays. ">structureTensorMultiArray</a> <b>(...,</b> <a class="el" href="classvigra_1_1BlockwiseConvolutionOptions.html">BlockwiseConvolutionOptions</a><b>)</b> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6139933445e70682b4fa9017cd660d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::parallel_foreach </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a functor to all items in a range in parallel. </p>
<p><b> Declarations:</b></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>vigra {</div>
<div class="line">    <span class="comment">// pass the desired number of threads or ParallelOptions::Auto</span></div>
<div class="line">    <span class="comment">// (creates an internal thread pool accordingly)</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> ITER, <span class="keyword">class</span> F&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ParallelProcessing.html#ga6139933445e70682b4fa9017cd660d22">parallel_foreach</a>(int64_t nThreads,</div>
<div class="line">                          ITER begin, ITER end,</div>
<div class="line">                          F &amp;&amp; f,</div>
<div class="line">                          <span class="keyword">const</span> uint64_t nItems = 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// use an existing thread pool</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> ITER, <span class="keyword">class</span> F&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ParallelProcessing.html#ga6139933445e70682b4fa9017cd660d22">parallel_foreach</a>(ThreadPool &amp; pool,</div>
<div class="line">                          ITER begin, ITER end,</div>
<div class="line">                          F &amp;&amp; f,</div>
<div class="line">                          <span class="keyword">const</span> uint64_t nItems = 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass the integers from 0 ... (nItems-1) to the functor f,</span></div>
<div class="line">    <span class="comment">// using the given number of threads or ParallelOptions::Auto</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ParallelProcessing.html#ga6139933445e70682b4fa9017cd660d22">parallel_foreach</a>(int64_t nThreads,</div>
<div class="line">                          uint64_t nItems,</div>
<div class="line">                          F &amp;&amp; f);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// likewise with an existing thread pool</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="group__ParallelProcessing.html#ga6139933445e70682b4fa9017cd660d22">parallel_foreach</a>(ThreadPool &amp; threadpool,</div>
<div class="line">                          uint64_t nItems,</div>
<div class="line">                          F &amp;&amp; f);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Create a thread pool (or use an existing one) to apply the functor </p>
<ul>
<li>f to all items in the range <code>[begin, end)</code> in parallel. </li>
<li>f must be callable with two arguments of type <code>size_t</code> and <code>T</code>, where the first argument is the thread index (starting at 0) and T is convertible from the iterator's <code>reference_type</code> (i.e. the result of <code>*begin</code>).</li>
</ul>
<p>If the iterators are forward iterators (<code>std::forward_iterator_tag</code>), you can provide the optional argument <code>nItems</code> to avoid the a <code>std::distance(begin, end)</code> call to compute the range's length.</p>
<p>Parameter <code>nThreads</code> controls the number of threads. <code>parallel_foreach</code> will split the work into about three times as many parallel tasks. If <code>nThreads = <a class="el" href="classvigra_1_1ParallelOptions.html#a1fb9092bcdeada2d206bdc74afbbe122ab81b7469043e9c54603ca3aebbe38e90" title="Determine number of threads automatically (from threading::thread::hardware_concurrency()) ...">ParallelOptions::Auto</a></code>, the number of threads is set to the machine default (<code>std::thread::hardware_concurrency()</code>).</p>
<p>If <code>nThreads = 0</code>, the function will not use threads, but will call the functor sequentially. This can also be enforced by setting the preprocessor flag <code>VIGRA_SINGLE_THREADED</code>, ignoring the value of <code>nThreads</code> (useful for debugging).</p>
<p><b>Usage:</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vigra/threadpool.hxx&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"><span class="keyword">using namespace </span>vigra;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span> <span class="keyword">const</span> n_threads = 4;</div>
<div class="line">    <span class="keywordtype">size_t</span> <span class="keyword">const</span> n = 2000;</div>
<div class="line">    vector&lt;int&gt; input(n);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> iter = input.begin(),</div>
<div class="line">         end  = input.end();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// fill input with 0, 1, 2, ...</span></div>
<div class="line">    iota(iter, end, 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute the sum of the elements in the input vector.</span></div>
<div class="line">    <span class="comment">// (each thread computes the partial sum of the items it sees</span></div>
<div class="line">    <span class="comment">//  and stores the sum at the appropriate index of &#39;results&#39;)</span></div>
<div class="line">    vector&lt;int&gt; results(n_threads, 0);</div>
<div class="line">    <a class="code" href="group__ParallelProcessing.html#ga6139933445e70682b4fa9017cd660d22">parallel_foreach</a>(n_threads, iter, end,</div>
<div class="line">        <span class="comment">// the functor to be executed, defined as a lambda function</span></div>
<div class="line">        <span class="comment">// (first argument: thread ID, second argument: result of *iter)</span></div>
<div class="line">        [&amp;results](<span class="keywordtype">size_t</span> thread_id, <span class="keywordtype">int</span> items)</div>
<div class="line">        {</div>
<div class="line">            results[thread_id] += items;</div>
<div class="line">        }</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// collect the partial sums of all threads</span></div>
<div class="line">    <span class="keywordtype">int</span> <a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086">sum</a> = accumulate(results.begin(), results.end(), 0);</div>
<div class="line"></div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;The sum &quot;</span> &lt;&lt; sum &lt;&lt; <span class="stringliteral">&quot; should be equal to &quot;</span> &lt;&lt; (n*(n-1))/2 &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad41a30b11a0c9d8566ca1a53b4cf43f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~ThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The destructor joins all threads. </p>

</div>
</div>
<a class="anchor" id="ga022c9a3cb8bdfb82fe60bdc78516871e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto enqueueReturning </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; threading::future&lt;decltype(f(0))&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueue a task that will be executed by the thread pool. The task result can be obtained using the <a class="el" href="group__MultiIteratorGroup.html#ga05428577aeff6d4b0746decbefbfa297">get()</a> function of the returned future. If the task throws an exception, it will be raised on the call to <a class="el" href="group__MultiIteratorGroup.html#ga05428577aeff6d4b0746decbefbfa297">get()</a>. </p>

</div>
</div>
<a class="anchor" id="ga6321ed04dae9c5a2ab8bccf07dd52cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">threading::future&lt; void &gt; enqueue </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enqueue function for tasks without return value. This is a special case of the enqueueReturning template function, but some compilers fail on <code>std::result_of&lt;F(int)&gt;::type</code> for void(int) functions. </p>

</div>
</div>
</div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.1 (Fri May 19 2017)
</i>
</tr>
</table>
</BODY>
</HTML>
