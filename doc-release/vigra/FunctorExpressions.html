<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Functor Expressions</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
<script>
var runOnLoad=function(c,o,d,e){function x(){for(e=1;c.length;)c.shift()()}o[d]?(document[d]('DOMContentLoaded',x,0),o[d]('load',x,0)):o.attachEvent('onload',x);return function(t){e?o.setTimeout(t,0):c.push(t)}}([],window,'addEventListener');
</script>
<script type="text/javascript" src="documents/CollapsibleLists.js"></script>
<script type="text/javascript">
    runOnLoad(function(){ CollapsibleLists.apply(); });
</script>
<style type="text/css">
.collapsibleList li.collapsibleListOpen{
  list-style-image:url('documents/pfeil.gif');
  cursor:pointer;
}
.collapsibleList li.collapsibleListClosed{
  list-style-image:url('documents/bullet.gif');
  cursor:pointer;
}
.collapsibleList li.lastItem{
  list-style-image:url('documents/diamond.gif');
}
</style>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://ukoethe.github.io/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">Functor Expressions 
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="textblock"><p>Simple automatic functor creation by means of expression templates (also known as a "lambda library"). Note, however, that the <a class="el" href="group__MultiMathModule.html">vigra::multi_math</a> module offers similar functionality with an easier syntax.</p>
<p><b>#include</b> &lt;<a class="el" href="functorexpression_8hxx_source.html">vigra/functorexpression.hxx</a>&gt;<br/>
 Namespace: vigra::functor</p>
<p><b> Motivation</b></p>
<p>Many generic algorithms are made more flexible by means of functors which define part of the algorithms' behavior according to the needs of a specific situation. For example, we can apply an exponential to each pixel by passing a pointer to the <code>exp</code> function to <code><a class="el" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314" title="Apply unary point transformation to each pixel. ">transformImage()</a></code>:</p>
<div class="fragment"><div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h), dest(w,h);</div>
<div class="line">... <span class="comment">// fill src</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314">vigra::transformImage</a>(srcImageRange(src), destImage(dest), &amp;<a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>);    </div>
</div><!-- fragment --><p>However, this only works for simple operations. If we wanted to apply the exponential to a scaled pixel value (i.e. we want to execute <code>exp(-beta*v)</code>), we first need to implement a new functor:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Exponential</div>
<div class="line">{</div>
<div class="line">    Exponential(<span class="keywordtype">double</span> b)</div>
<div class="line">    : beta(b)</div>
<div class="line">    {}</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PixelType&gt;</div>
<div class="line">    PixelType operator()(PixelType <span class="keyword">const</span>&amp; v)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>(-beta*v);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">double</span> beta;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This functor would be used like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> beta =  ...;</div>
<div class="line"><a class="code" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314">vigra::transformImage</a>(srcImageRange(src), destImage(dest), </div>
<div class="line">               Exponential(beta));    </div>
</div><!-- fragment --><p>However, this approach has some disadvantages:</p>
<ul>
<li>
Writing a functor is more work then simply program the loop directly, i.e. non-generically. Programmers will tend to avoid generic constructs, if they require so much writing. </li>
<li>
Often, functors are only needed for a single expression. It is not desirable to get into the trouble of introducing and documenting a new class if that class is used only once. </li>
<li>
<p class="startli">Functors cannot be implemented directly at the point of use. Thus, to find out exactly what a functor is doing, one needs to look somewhere else. This complicates use and maintenance ot generic code.</p>
<p class="endli"></p>
</li>
</ul>
<p>Therefore, it is necessary to provide a means to generate functors on the fly where they are needed. The C++ standard library contains so called "functor combinators" that allow to construct complicated functors from simpler ones. The above problem "apply exp(-beta*v) to every pixel" would be solved like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> beta = ...;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314">vigra::transformImage</a>(srcImageRange(src), destImage(dest), </div>
<div class="line">               std::compose1(std::ptr_fun(<a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>),</div>
<div class="line">                             std::bind1st(std::multiplies&lt;float&gt;(), -beta)));</div>
</div><!-- fragment --><p>I won't go into details on how this works. Suffice it to say that this technique requires a functional programming style that is unfamiliar to many programmers, and thus leads to code that is difficult to understand. Moreover, this technique has some limitations that prevent certain expressions from being implementable this way. Therefore, VIGRA provides a better and simpler means to create functors on the fly.</p>
<p><b> Automatic Functor Creation</b></p>
<p>Automatic functor creation in VIGRA is based on a technique called <a href="http://extreme.indiana.edu/~tveldhui/papers/Expression-Templates/exprtmpl.html">Expression Templates</a>. This means that C++ operators are overloaded so that they don't execute the specified operation directly, but instead produce a functor which will later calculate the result. This technique has the big advantage that the familiar operator notation can be used, while all the flexibility of generic programming is preserved.</p>
<p>The above problem "apply &lt;TT&gt;exp(-beta*v)&lt;/TT&gt; to every pixel" will be solved like this:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::functor;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">float</span> beta = ...;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314">transformImage</a>(srcImageRange(src), destImage(dest), </div>
<div class="line">               <a class="code" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp</a>(Param(-beta)*Arg1()));</div>
</div><!-- fragment --><p>Here, four expression templates have been used to create the desired functor:</p>
<dl>
<dt><b><code>Param(-beta):</code></b></dt>
<dd><p class="startdd">creates a functor that represents a constant (<code>-beta</code> in this case)</p>
<p class="enddd"></p>
</dd>
<dt><b><code>Arg1():</code></b></dt>
<dd><p class="startdd">represents the first argument of the expression (i.e. the pixels of image <code>src</code> in the example). Likewise, <code>Arg2()</code> and <code>Arg3()</code> are defined to represent more arguments. These are needed for algorithms that have multiple input images, such as <a class="el" href="group__CombineAlgo.html#gaccf94cfa4b47ceb10e08dabe668fce23">combineTwoImages()</a> and <a class="el" href="group__CombineAlgo.html#ga9bbc3b2f05707a6d4734f5f63c3884e2">combineThreeImages()</a>.</p>
<p class="enddd"></p>
</dd>
<dt><b>* (multiplication):</b></dt>
<dd><p class="startdd">creates a functor that returns the product of its arguments. Likewise, the other C++ operators (i.e. <code>+, -, *, /, %, ==, !=, &lt;, &lt;=, &gt;, &gt;=, &amp;&amp;, ||, &amp;, |, ^, !, ~</code>) are overloaded.</p>
<p class="enddd"></p>
</dd>
<dt><b><code><a class="el" href="group__LinearAlgebraFunctions.html#ga2a9e01ae7ae7b39a618e9f4a6afaee5b">exp()</a>:</code></b></dt>
<dd><p class="startdd">creates a functor that takes the exponential of its argument. Likewise, the other algebraic functions (i.e. <code>sq, sqrt, exp, log, log10, sin, asin, cos, acos, tan, atan, abs, floor, ceil, pow, atan2, fmod, min, max</code>) are overloaded.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>We will explain additional capabilities of the functor creation mechanism by means of examples.</p>
<p>The same argument can be used several times in the expression. For example, to calculate the gradient magnitude from the components of the gradient vector, you may write:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::functor;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> gradient_x(w,h), gradient_y(w,h), magnitude(w,h);</div>
<div class="line">... <span class="comment">// calculate gradient_x and gradient_y</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="group__CombineAlgo.html#gaccf94cfa4b47ceb10e08dabe668fce23">combineTwoImages</a>(srcImageRange(gradient_x), srcImage(gradient_y),</div>
<div class="line">                 destImage(magnitude),</div>
<div class="line">                 <a class="code" href="group__FixedPointOperations.html#ga22d75753836176f3d172f58be11ecc4c">sqrt</a>(Arg1()*Arg1() + Arg2()*Arg2()));</div>
</div><!-- fragment --><p>It is also possible to build other functions into functor expressions. Suppose you want to apply <code>my_complicated_function()</code> to the sum of two images:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::functor;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src1(w,h), src2(w,h), dest(w,h);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> my_complicated_function(<span class="keywordtype">double</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__CombineAlgo.html#gaccf94cfa4b47ceb10e08dabe668fce23">combineTwoImages</a>(srcImageRange(src1), srcImage(src2), destImage(dest),</div>
<div class="line">                 applyFct(&amp;my_complicated_function, Arg1()+Arg2()));    </div>
</div><!-- fragment --><p>[Note that the arguments of the wrapped function are passed as additional arguments to <code>applyFct()</code>]</p>
<p>You can implement conditional expression by means of the <code>ifThenElse()</code> functor. It corresponds to the "? :" operator that cannot be overloaded. <code>ifThenElse()</code> can be used, for example, to threshold an image:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::functor;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h), thresholded(w,h);</div>
<div class="line">...<span class="comment">// fill src</span></div>
<div class="line"></div>
<div class="line">float threshold = ...;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314">transformImage</a>(srcImageRange(src), destImage(thresholded),</div>
<div class="line">               ifThenElse(Arg1() &lt; Param(threshold),</div>
<div class="line">                          Param(0.0),    <span class="comment">// yes branch</span></div>
<div class="line">                          Param(1.0))    <span class="comment">// no  branch</span></div>
<div class="line">              );</div>
</div><!-- fragment --><p>You can use the <code>Var()</code> functor to assign values to a variable (<code>=, +=, -=, *=, /=</code>&#160; are supported). For example, the average gray value of the image is calculated like this:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::functor;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h);</div>
<div class="line">...<span class="comment">// fill src</span></div>
<div class="line"></div>
<div class="line">double <a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086">sum</a> = 0.0;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__InspectAlgo.html#gaa055bcaf71c209fdeb006fe3e44b0452">inspectImage</a>(srcImageRange(src), Var(<a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086">sum</a>) += Arg1());</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Average: &quot;</span> &lt;&lt; (<a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086">sum</a> / (w*h)) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>For use in <a class="el" href="group__InspectAlgo.html#gaa055bcaf71c209fdeb006fe3e44b0452">inspectImage()</a> and its relatives, there is a second conditional functor <code>ifThen()</code> that emulates the <code>if()</code> statement and does not return a value. Using <code>ifThen()</code>, we can calculate the size of an image region:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::functor;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::IImage</a> label_image(w,h);</div>
<div class="line">...<span class="comment">// mark regions by labels in label_image</span></div>
<div class="line"></div>
<div class="line">int region_label = ...; <span class="comment">// the region we want to inspect</span></div>
<div class="line"><span class="keywordtype">int</span> size = 0;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__InspectAlgo.html#gaa055bcaf71c209fdeb006fe3e44b0452">inspectImage</a>(srcImageRange(label_image),</div>
<div class="line">             ifThen(Arg1() == Param(region_label),</div>
<div class="line">                    Var(size) += Param(1)));</div>
<div class="line">                    </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Size of region &quot;</span> &lt;&lt; region_label &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; size &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Often, we want to execute several commands in one functor. This can be done by means of the overloaded <code>operator,()</code> ("operator comma"). Expressions separated by a comma will be executed in succession. We can thus simultaneously find the size and the average gray value of a region:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::functor;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::FImage</a> src(w,h);</div>
<div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::IImage</a> label_image(w,h);</div>
<div class="line">...<span class="comment">// segment src and mark regions in label_image</span></div>
<div class="line"></div>
<div class="line">int region_label = ...; <span class="comment">// the region we want to inspect</span></div>
<div class="line"><span class="keywordtype">int</span> size = 0;</div>
<div class="line"><span class="keywordtype">double</span> <a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086">sum</a> = 0.0;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__InspectAlgo.html#gad70a53a9ab68eab8c6d3371b1269b6ac">inspectTwoImages</a>(srcImageRange(src), srcImage(label_image),</div>
<div class="line">                 ifThen(Arg2() == Param(region_label),</div>
<div class="line">                 (</div>
<div class="line">                    Var(size) += Param(1), <span class="comment">// the comma operator is invoked</span></div>
<div class="line">                    Var(<a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086">sum</a>) += Arg1()</div>
<div class="line">                 )));</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Region &quot;</span> &lt;&lt; region_label &lt;&lt; <span class="stringliteral">&quot;: size = &quot;</span> &lt;&lt; size &lt;&lt; </div>
<div class="line">                                          <span class="stringliteral">&quot;, average = &quot;</span> &lt;&lt; <a class="code" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086">sum</a> / size &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>[Note that the list of comma-separated expressions must be enclosed in parentheses.]</p>
<p>A comma separated list of expressions can also be applied in the context of <a class="el" href="group__TransformAlgo.html#gababa545b60bb7db13076648f83c6b314">transformImage()</a> and its cousins. Here, a general rule of C++ applies: The return value of a comma expression is the value of its last subexpression. For example, we can initialize an image so that each pixel contains its address in scan order:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>vigra::functor;</div>
<div class="line"></div>
<div class="line"><a class="code" href="classvigra_1_1BasicImage.html">vigra::IImage</a> img(w,h);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> count = -1;</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__InitAlgo.html#gabae1fd1bcc1be861f086b347fefbf355">initImageWithFunctor</a>(destImageRange(img),</div>
<div class="line">                     (</div>
<div class="line">                          Var(count) += Param(1),  </div>
<div class="line">                          Var(count)     <span class="comment">// this is the result of the comma expression</span></div>
<div class="line">                     ));</div>
</div><!-- fragment --><p>Further information about how this mechanism works can be found in <a href="http://hci.iwr.uni-heidelberg.de/vigra/documents/FunctorFactory.ps">this paper</a> (sorry, slightly out of date). </p>
</div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.1 (Fri May 19 2017)
</i>
</tr>
</table>
</BODY>
</HTML>
