<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Writing your own Functions</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
<script>
var runOnLoad=function(c,o,d,e){function x(){for(e=1;c.length;)c.shift()()}o[d]?(document[d]('DOMContentLoaded',x,0),o[d]('load',x,0)):o.attachEvent('onload',x);return function(t){e?o.setTimeout(t,0):c.push(t)}}([],window,'addEventListener');
</script>
<script type="text/javascript" src="documents/CollapsibleLists.js"></script>
<script type="text/javascript">
    runOnLoad(function(){ CollapsibleLists.apply(); });
</script>
<style type="text/css">
.collapsibleList li.collapsibleListOpen{
  list-style-image:url('documents/pfeil.gif');
  cursor:pointer;
}
.collapsibleList li.collapsibleListClosed{
  list-style-image:url('documents/bullet.gif');
  cursor:pointer;
}
.collapsibleList li.lastItem{
  list-style-image:url('documents/diamond.gif');
}
</style>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://ukoethe.github.io/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">Writing your own Functions 
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="textblock"><p>Sooner or later, you will want to implement your own functions on the basis of VIGRA's functionality. Some people believe that this is very difficult because one needs to provide a lot of template magic and full genericity. However, this is <em>not</em> true: Your VIGRA functions need not be templated at all &ndash; function arguments can simply be hard-wired. In other cases, it makes sense to template on the pixel type, but leave averything else fixed. Full genericity should only be implemented step-by-step as needed.</p>
<p>As an example, consider again the image smoothing example program <a href="smooth_explicitly_8cxx-example.html">smooth_explicitly.cxx</a>. It makes sense to encapsulate the smoothing algorithm into a function of its own. When we only need to support <code>float</code> images, the function is simply a verbatim copy of the algorithm. In contrast to the original version, we now allow an arbitrary window radius to be passed to the algorithm, so that the amount of smoothing can be controlled (this also nicely illustrates the use of <code>vigra_precondition()</code> for <a class="el" href="ErrorReporting.html">Error Reporting</a>):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> smooth(MultiArrayView&lt;2, float&gt; input, MultiArrayView&lt;2, float&gt; result, <span class="keywordtype">int</span> radius)</div>
<div class="line">{</div>
<div class="line">    vigra_precondition(radius &gt;= 0, <span class="stringliteral">&quot;smooth(): window radius must not be negative.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    Shape2 current;</div>
<div class="line">    <span class="keywordflow">for</span>(current[1] = 0; current[1] &lt; input.shape(1); ++current[1])</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (current[0] = 0; current[0] &lt; input.shape(0); ++current[0])</div>
<div class="line">        {</div>
<div class="line">            Shape2 windowStart = max(Shape2(0),     current - Shape2(radius));</div>
<div class="line">            Shape2 windowStop  = min(input.shape(), current + Shape2(radius+1));</div>
<div class="line">            MultiArrayView&lt;2, float&gt; window = input.subarray(windowStart, windowStop);</div>
<div class="line">            result[current] = window.sum&lt;<span class="keywordtype">float</span>&gt;() / window.size();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>If we don't need to support any higher dimension or other pixel type, we can just leave it at this &ndash; no templates are required then.</p>
<p>But suppose now that we want to generalize this code for arbitrary dimensional arrays. To do so, we specify the dimension <code>N</code> as a template parameter. Then we can no longer use <code>Shape2</code> because this class only works for 2-dimensional arrays. Instead, we use the <code>MultiArrayShape</code> traits class to ask for the appropriate shape object. Moreover, we cannot iterate over the array with two explicitly nested loops because the number of loops must correspond to the (unknown) number of dimensions. We can solve this problems by means of a <a class="el" href="classvigra_1_1MultiCoordinateIterator.html">vigra::MultiCoordinateIterator</a> from <code><a class="el" href="multi__iterator__coupled_8hxx_source.html">multi_iterator_coupled.hxx</a></code> that iterates over all coordinates of an array, regardless of dimension. The current coordinate is returned by dereferencing the iterator:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;vigra/multi_iterator_coupled.hxx&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N&gt;</div>
<div class="line"><span class="keywordtype">void</span> smooth(MultiArrayView&lt;N, float&gt; input, MultiArrayView&lt;N, float&gt; result, <span class="keywordtype">int</span> radius)</div>
<div class="line">{</div>
<div class="line">    vigra_precondition(radius &gt;= 0, <span class="stringliteral">&quot;smooth(): window radius must not be negative.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type  Shape;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typename</span> MultiCoordinateIterator&lt;N&gt; current(input.shape()),</div>
<div class="line">                                        end = current.getEndIterator();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(; current != end; ++current)</div>
<div class="line">    {</div>
<div class="line">        Shape windowStart = max(Shape(0),      *current - Shape(radius));</div>
<div class="line">        Shape windowStop  = min(input.shape(), *current + Shape(radius+1));</div>
<div class="line">        MultiArrayView&lt;N, float&gt; window = input.subarray(windowStart, windowStop);</div>
<div class="line">        result[*current] = window.sum&lt;<span class="keywordtype">float</span>&gt;() / window.size();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Another useful generalization is in terms of the array's value_type. For one, we want to be able to smooth color images as well. Furthermore, most images are stored with pixel type <code>unsigned char</code>, and we don't want to force the user to convert them into <code>float</code> images before smoothing. We therefore specify the value_types as template parameters as well (notice that we allow input and result to have different types). In addition, we have to make the type of the sum in <code><a class="el" href="group__TinyVectorOperators.html#ga202143b556e7388b4895f457317eb086" title="sum of the vector&#39;s elements ">window.sum&lt;...&gt;()</a></code> generic. However, there is a caveat: We cannot simply use the input value_type here, because this might lead to overflow. This is easily seen when the value_type is <code>unsigned char</code>: This type already overflows when the sum exceeds the value 255, which is very likely to happen even if the windows is only 3x3. In situations like this, a suitable temporary type for the sum can be obtained from the <code>RealPromote</code> type in VIGRA's <a class="el" href="NumericTraits.html">NumericTraits</a> class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N, <span class="keyword">class</span> InputValue, <span class="keyword">class</span> ResultValue&gt;</div>
<div class="line"><span class="keywordtype">void</span> smooth(MultiArrayView&lt;N, InputValue&gt;  input,</div>
<div class="line">            MultiArrayView&lt;N, ResultValue&gt; result,</div>
<div class="line">            <span class="keywordtype">int</span> radius)</div>
<div class="line">{</div>
<div class="line">    vigra_precondition(radius &gt;= 0, <span class="stringliteral">&quot;smooth(): window radius must not be negative.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> MultiArrayShape&lt;N&gt;::type                Shape;</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> NumericTraits&lt;InputValue&gt;::RealPromote  SumType;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typename</span> MultiCoordinateIterator&lt;N&gt; current(input.shape()),</div>
<div class="line">                                        end = current.getEndIterator();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span>(; current != end; ++current)</div>
<div class="line">    {</div>
<div class="line">        Shape windowStart = max(Shape(0),      *current - Shape(radius));</div>
<div class="line">        Shape windowStop  = min(input.shape(), *current + Shape(radius+1));</div>
<div class="line">        MultiArrayView&lt;N, InputValue&gt; window = input.subarray(windowStart, windowStop);</div>
<div class="line">        result[*current] = window.template sum&lt;SumType&gt;() / window.size();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>These simple tricks already get you a long way in the advanced use of VIGRA. You will notice, that many existing VIGRA functions are not implemented in temrs of <a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a>, but in terms of <a class="el" href="group__ImageIterators.html">image iterators</a> and <a class="el" href="group__MultiIteratorGroup.html">hierarchical iterators</a>. However, these iterators are more difficult to use, so the MultiArrayView approach is recommended for new code. </p>
</div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.0 (Thu Mar 17 2016)
</i>
</tr>
</table>
</BODY>
</HTML>
