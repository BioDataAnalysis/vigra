<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>vigra - Image Segmentation</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
<link rel=stylesheet type="text/css" href="vigra_1_8_2.css">
<link rel="shortcut icon" href="vigra-icon.ico" />
<script type="text/javascript">
function toggleHiddenDocumentation( textID, toggleID, toggleMessage )
{
	if( document.getElementById(textID).style.display == 'none' )
    {
		document.getElementById(textID).style.display = 'block';
        document.getElementById(toggleID).innerHTML = "hide " + toggleMessage;
    }
    else
    {
		document.getElementById(textID).style.display = 'none';
        document.getElementById(toggleID).innerHTML = "show " + toggleMessage;
	}
    return false;
}
</script>
<script>
var runOnLoad=function(c,o,d,e){function x(){for(e=1;c.length;)c.shift()()}o[d]?(document[d]('DOMContentLoaded',x,0),o[d]('load',x,0)):o.attachEvent('onload',x);return function(t){e?o.setTimeout(t,0):c.push(t)}}([],window,'addEventListener');
</script>
<script type="text/javascript" src="documents/CollapsibleLists.js"></script>
<script type="text/javascript">
    runOnLoad(function(){ CollapsibleLists.apply(); });
</script>
<style type="text/css">
.collapsibleList li.collapsibleListOpen{
  list-style-image:url('documents/pfeil.gif');
  cursor:pointer;
}
.collapsibleList li.collapsibleListClosed{
  list-style-image:url('documents/bullet.gif');
  cursor:pointer;
}
.collapsibleList li.lastItem{
  list-style-image:url('documents/diamond.gif');
}
</style>
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://ukoethe.github.io/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">Image Segmentation 
</td>
<td align=right><a href="http://hci.iwr.uni-heidelberg.de/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif" title="VIGRA Homepage"></a></td></tr>
</table><p>

<div class="textblock"><h2>Section Contents</h2>
<ul style="list-style-image:url(documents/diamond.gif)">
<li>
<a class="el" href="ImageSegmentationTutorial.html#SuperpixelsTutorial">Computing Superpixels</a> </li>
<li>
<a class="el" href="ImageSegmentationTutorial.html#RAGTutorial">Constructing the Region Adjacency Graph and its Feature Maps</a> </li>
<li>
<a class="el" href="ImageSegmentationTutorial.html#ClusteringTutorial">Perform Hierarchical Clustering</a> </li>
</ul>
<p>The complete code of the example described here can be found in <a href="graph_agglomerative_clustering_8cxx-example.html">graph_agglomerative_clustering.cxx</a>.</p>
<h1><a class="anchor" id="SuperpixelsTutorial"></a>
Computing Superpixels</h1>
<p>Hierarchical or agglomerative clustering can be applied either to the pixels directly by using a <a class="el" href="classvigra_1_1GridGraph.html">vigra::GridGraph</a>, or on an initial oversegmentation into superpixels whose region adjacency graph is represented in a <a class="el" href="classvigra_1_1AdjacencyListGraph.html">vigra::AdjacencyListGraph</a>. We describe the second variant here, as it offers more possibilities, but the first works essentially in the same way.</p>
<p>Before computing superpixels, it is useful to transform the data from the RGB colorspace into the Lab colorspace, because distances in the Lab space are perceptually more meaningful:</p>
<div class="fragment"><div class="line"><span class="comment">// read the input image</span></div>
<div class="line">ImageImportInfo info(filename);</div>
<div class="line">MultiArray&lt;2, TinyVector&lt;float, 3&gt; &gt; imageArrayRGB(info.shape());</div>
<div class="line">importImage(info, imageArrayRGB);</div>
<div class="line"></div>
<div class="line"><span class="comment">// convert into Lab color space</span></div>
<div class="line">MultiArray&lt;2, TinyVector&lt;float, 3&gt; &gt; imageArrayLab(imageArrayRGB.shape());</div>
<div class="line"><a class="code" href="group__MultiPointoperators.html#ga4e3f906de480f4a867340968da8a98dd">transformMultiArray</a>(imageArrayRGB, imageArrayLab, RGB2LabFunctor&lt;float&gt;());</div>
</div><!-- fragment --><p>VIGRA offers two superpixel algorithms: watersheds and SLIC superpixels. We use the watershed algorithm here, see <a class="el" href="group__Superpixels.html#ga5561f1ce9b3f7a95b7de67738a0d2447">slicSuperpixels()</a> for more information on the alternative. To run the watershed algorithm, we first need an edge indicator (i.e. an image with big values along edges and small values elsewhere) like the gradient magnitude:</p>
<div class="fragment"><div class="line"><span class="comment">// detect edges by the Gaussian gradient magnitude</span></div>
<div class="line">MultiArray&lt;2, float&gt;  gradMag(imageArrayLab.shape());</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">float</span> sigmaGradMag = 3.0f;</div>
<div class="line"><a class="code" href="group__ConvolutionFilters.html#gab80e356fa487f97d718ed815a3cf4855">gaussianGradientMagnitude</a>(imageArrayLab, gradMag, sigmaGradMag);</div>
</div><!-- fragment --><table  cellspacing="10">
<tr valign="bottom">
<td><div class="image">
<img src="bears.jpg" alt="bears.jpg"/>
<div class="caption">
input image</div></div>
  </td><td><div class="image">
<img src="bears_gradient.png" alt="bears_gradient.png"/>
<div class="caption">
gradient magnitude</div></div>
   </td></tr>
</table>
<p>The watershed algorithm initiates a superpixel at every local minimum of the gradient image and then grows these seeds along increasing gradients until they meet at the gradient ridges (called "watersheds" because we can interpret the gradient as the altitude of a landscape) which partly correspond to true image edges, but are also located elsewhere. The goal of the subsequent hierarchical clustering is to identify the true edges and delete the spurious ones. The superpixels are represented in a label image that assigns the superpixel ID to every pixel. To visualize the superpixels, it is useful to display the watershed lines as an overlay on an enlarged version of the input image (Enlarging the image is necessary because the watersheds are actually between pixels, i.e. at half-integer coordinates. Doubling maps these to odd-valued coordinates in the enlarged image, so that rounding is avoided.). In this example, we use the fast union-find watershed algorithm, which is also available in a parallel version in function <a class="el" href="group__Superpixels.html#ga76433bac4c15c965da8fdd108c86bd2e">unionFindWatershedsBlockwise()</a>:</p>
<div class="fragment"><div class="line"><span class="comment">// create watershed superpixels with the fast union-find algorithm</span></div>
<div class="line">MultiArray&lt;2, unsigned int&gt; labelArray(gradMag.shape());</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_label = <a class="code" href="group__Superpixels.html#ga67dae5f2292e59d2de0936e7aa4f3e67">watershedsMultiArray</a>(gradMag, labelArray, <a class="code" href="group__MultiIteratorGroup.html#gga9d75de3edc093f215c3f4d42a966167aaf5b533c53c0491107c6c9b890b635372">DirectNeighborhood</a>,</div>
<div class="line">                                              WatershedOptions().unionFind());</div>
<div class="line"></div>
<div class="line"><span class="comment">// double the image resolution and create watershed overlay</span></div>
<div class="line">MultiArray&lt;2, TinyVector&lt;float, 3&gt; &gt; imageArrayBig(imageArrayRGB.shape()*2-Shape2(1));</div>
<div class="line"><a class="code" href="group__GeometricTransformations.html#ga2cd9b31e7f0c8648bc0d9e1a8f1a3305">resizeMultiArraySplineInterpolation</a>(imageArrayRGB, imageArrayBig);</div>
<div class="line"><a class="code" href="group__Labeling.html#ga0d13d25c5b735aaca90c5a506bb274ac">regionImageToCrackEdgeImage</a>(labelArray, imageArrayBig,</div>
<div class="line">                            RGBValue&lt;float&gt;(255, 0, 0), EdgeOverlayOnly);</div>
</div><!-- fragment --><div class="image">
<img src="bears_superpixels.png" alt="bears_superpixels.png"/>
</div>
<h1><a class="anchor" id="RAGTutorial"></a>
Constructing the Region Adjacency Graph and its Feature Maps</h1>
<p>Next, we invoke <a class="el" href="group__GraphDataStructures.html#gac2e4a082419162804528250e835f0b0f">makeRegionAdjacencyGraph()</a> to construct the region adjacency graph (RAG) of the superpixels. This function takes any graph along with a connected components labeling and creates a new graph that has exactly one node per connected component, and nodes are connected by an edge whenever the corresponding components are neighbors in the original graph, i.e. the original graph contains at least one edge with one end point in the first and the other in the second component. In general, each pair of components has several edges with this property, and all of them are mapped onto a single edge in the RAG. To keep track of this mapping, <a class="el" href="group__GraphDataStructures.html#gac2e4a082419162804528250e835f0b0f" title="make a region adjacency graph from a graph and labels w.r.t. that graph ">makeRegionAdjacencyGraph()</a> accepts an additional parameter <em>affiliatedEdges</em>, which is a map from edge IDs in the RAG to vectors of edge IDs in the original graph. In our case, the input graph is a <a class="el" href="classvigra_1_1GridGraph.html">vigra::GridGraph</a> whose labeling is stored in the <em>labelArray</em>, and the output graph is a <a class="el" href="classvigra_1_1AdjacencyListGraph.html">vigra::AdjacencyListGraph</a>. The mapping <em>affiliatedEdges</em> is best constructed by using embedded types of these graph classes:</p>
<div class="fragment"><div class="line"><span class="comment">// create grid-graph of appropriate size</span></div>
<div class="line"><span class="keyword">typedef</span> GridGraph&lt;2, undirected_tag&gt; ImageGraph;</div>
<div class="line">ImageGraph imageGraph(labelArray.shape());</div>
<div class="line"></div>
<div class="line"><span class="comment">// construct an empty graph to hold the region adjacency graph for the superpixels</span></div>
<div class="line"><span class="keyword">typedef</span> AdjacencyListGraph RAG;</div>
<div class="line">RAG rag;</div>
<div class="line"></div>
<div class="line"><span class="comment">// create the mapping &#39;affiliatedEdges&#39; from RAG edges to</span></div>
<div class="line"><span class="comment">// corresponding imageGraph edges and build the RAG</span></div>
<div class="line">RAG::EdgeMap&lt;std::vector&lt;ImageGraph::Edge&gt;&gt; affiliatedEdges(rag);</div>
<div class="line"><a class="code" href="group__GraphDataStructures.html#gac2e4a082419162804528250e835f0b0f">makeRegionAdjacencyGraph</a>(imageGraph, labelArray, rag, affiliatedEdges);</div>
</div><!-- fragment --><p>Note that VIGRA's graph classes conform to the elegant API defined in the <a href="https://lemon.cs.elte.hu/">LEMON Graph Library</a>. Although VIGRA doesn't use LEMON's implementation of this API, it is worth reading their <a href="http://lemon.cs.elte.hu/pub/tutorial/index.html">tutorial</a> because VIGRA's graph classes behave in exactly the same way.</p>
<p>To control agglomerative clustering, i.e. to define the order in which edges are contracted and nodes merged, we need some features that describe the dissimilarity of superpixels. The more dissimilar two superpixels are, the more likely they will remain separated, i.e. belong to different regions of the final segmentation. We distinguish two kinds of features: edge weights and node features.</p>
<p>Edge weights should be high when two superpixels are separated by an object edge, i.e. when the gradient magnitude along the common superpixel boundary is high. We define the edge weight as the average gradient magnitude along the boundary, i.e. as the average over the grid edges that correspond to the present RAG edge. However, as pointed out earlier, watershed boundaries are located between pixels, i.e. on half-integer coordinates, whereas the gradient has been computed on pixels, i.e. at integer coordinates. We solve this problem by linear interpolation: the gradient of a grid edge is the average gradient of its two end points.</p>
<div class="fragment"><div class="line"><span class="comment">// create edge maps for weights and lengths of the RAG edges (zero initialized)</span></div>
<div class="line">RAG::EdgeMap&lt;float&gt; edgeWeights(rag),</div>
<div class="line">                    edgeLengths(rag);</div>
<div class="line"></div>
<div class="line"><span class="comment">// iterate over all RAG edges (this loop follows a standard LEMON idiom)</span></div>
<div class="line"><span class="keywordflow">for</span>(RAG::EdgeIt rag_edge(rag); rag_edge != lemon::INVALID; ++rag_edge)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// iterate over all grid edges that constitute the present RAG edge</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; affiliatedEdges[*rag_edge].size(); ++k)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// look up the current grid edge and its end points</span></div>
<div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> &amp; grid_edge = affiliatedEdges[*rag_edge][k];</div>
<div class="line">        <span class="keyword">auto</span> start = imageGraph.u(grid_edge),</div>
<div class="line">             end   = imageGraph.v(grid_edge);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// compute gradient by linear interpolation between end points</span></div>
<div class="line">        <span class="keywordtype">double</span> grid_edge_gradient = 0.5 * (gradMag[start] + gradMag[end]);</div>
<div class="line">        <span class="comment">// aggregate the total</span></div>
<div class="line">        edgeWeights[*rag_edge] += grid_edge_gradient;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the length of the RAG edge equals the number of constituent grid edges</span></div>
<div class="line">    edgeLengths[*rag_edge] = affiliatedEdges[*rag_edge].size();</div>
<div class="line">    <span class="comment">// define edge weights by the average gradient</span></div>
<div class="line">    edgeWeights[*rag_edge] /= edgeLengths[*rag_edge];</div>
<div class="line">}</div>
</div><!-- fragment --><p>Node features are defined by the average Lab color of each superpixel. Hierarchical clustering will later turn this into a node dissimilarity by computing the Euclidean distance between the average colors of neighboring superpixels, possibly weighted by the superpixels' sizes. To compute these features, we invoke VIGRA's <a class="el" href="group__FeatureAccumulators.html">Feature Accumulators</a> framework:</p>
<div class="fragment"><div class="line"><span class="comment">// determine size and average Lab color of each superpixel</span></div>
<div class="line"><span class="keyword">using namespace </span>acc;</div>
<div class="line">AccumulatorChainArray&lt;CoupledArrays&lt;2, TinyVector&lt;float, 3&gt;, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;,</div>
<div class="line">                      Select&lt;DataArg&lt;1&gt;, LabelArg&lt;2&gt;, <span class="comment">// where to look for data and region labels</span></div>
<div class="line">                             <a class="code" href="namespacevigra_1_1acc.html#a8b80913ec664dd2e7949b1fef390b144">Count</a>, <a class="code" href="namespacevigra_1_1acc.html#ac0f533874b6415005dcf8974478c4b8e">Mean</a>&gt; &gt;           <span class="comment">// what statistics to compute</span></div>
<div class="line">    features;</div>
<div class="line"><a class="code" href="namespacevigra_1_1acc.html#a5640bdd147f40fbd9424594ea7a2515c">extractFeatures</a>(imageArrayLab, labelArray, features);</div>
</div><!-- fragment --><p>To be understood by <a class="el" href="group__GraphDataStructures.html#gafbaa28685756ee5d69b17c7a31f8b8fb" title="Reduce the number of nodes in a graph by iteratively contracting the cheapest edge. ">hierarchicalClustering()</a>, we must copy the features into node property maps which are compatible with the RAG data structure:</p>
<div class="fragment"><div class="line"><span class="comment">// copy superpixel features into NodeMaps to be passed to hierarchicalClustering()</span></div>
<div class="line">RAG::NodeMap&lt;TinyVector&lt;float, 3&gt;&gt; meanColor(rag);</div>
<div class="line">RAG::NodeMap&lt;unsigned int&gt;         regionSize(rag);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;=max_label; ++k) <span class="comment">// max_label was returned from watershedsMultiArray()</span></div>
<div class="line">{</div>
<div class="line">    meanColor[k] = get&lt;Mean&gt;(features, k);</div>
<div class="line">    regionSize[k] = get&lt;Count&gt;(features, k);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="ClusteringTutorial"></a>
Perform Hierarchical Clustering</h1>
<p>Now we have collected all information needed to perform agglomerative clustering. We pass the superpixel adjacency graph and its feature maps to the clustering function, and it returns the cluster assignment in a new property map <em>nodeLabels</em> that assigns to every RAG node the ID of the cluster the node belongs to. Thus, <em>nodeLabels</em> plays exactly the same role for the RAG as <em>labelArray</em> did for the grid graph. Cluster IDs are identical to the node IDs of arbitrarly chosen cluster representatives, i.e. they form a sparse subset of the original IDs.</p>
<div class="fragment"><div class="line"><span class="comment">// customize parameters of the clustering algorithm</span></div>
<div class="line"><span class="keywordtype">float</span> beta = 0.5f;         <span class="comment">// importance of node features relative to edge weights</span></div>
<div class="line"><span class="keywordtype">float</span> wardness = 0.8f;     <span class="comment">// importance of cluster size</span></div>
<div class="line"><span class="keywordtype">int</span> numClusters = 30;      <span class="comment">// desired number of resulting regions (clusters)</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// create a node map for the new (clustered) region labels and perform</span></div>
<div class="line"><span class="comment">// clustering to remove unimportant watershed edges</span></div>
<div class="line">RAG::NodeMap&lt;unsigned int&gt;  nodeLabels(rag);</div>
<div class="line"><a class="code" href="group__GraphDataStructures.html#gafbaa28685756ee5d69b17c7a31f8b8fb">hierarchicalClustering</a>(rag,          <span class="comment">// input: the superpixel adjacency graph</span></div>
<div class="line">                       edgeWeights, edgeLengths, meanColor, regionSize, <span class="comment">// features</span></div>
<div class="line">                       nodeLabels,   <span class="comment">// output: a cluster labeling of the RAG</span></div>
<div class="line">                       ClusteringOptions().minRegionCount(numClusters)</div>
<div class="line">                                          .nodeFeatureImportance(beta)</div>
<div class="line">                                          .sizeImportance(wardness)</div>
<div class="line">                                          .nodeFeatureMetric(metrics::L2Norm)</div>
<div class="line">                       );</div>
</div><!-- fragment --><p>The details of the clustering algorithm can be customized by the option object <a class="el" href="classvigra_1_1ClusteringOptions.html">vigra::ClusteringOptions</a>. Here, we set the termination criterion <em>numClusters</em>, the relative importance of node features and sizes (<em>beta</em> and <em>wardness</em>) and the norm to be used to compute node feature dissimiliarity. Option objects like this are a common idiom in the VIGRA library, because code readability matters.</p>
<p>Finally, we replace the original superpixel labels in <em>labelArray</em> with the new cluster labels from <em>nodeLabels</em> and visualize the resulting region boundaries, this time with a green overlay on the enlarged input image:</p>
<div class="fragment"><div class="line"><span class="comment">// update label image with the new labels</span></div>
<div class="line"><a class="code" href="group__MultiPointoperators.html#ga4e3f906de480f4a867340968da8a98dd">transformMultiArray</a>(labelArray, labelArray,</div>
<div class="line">    [&amp;nodeLabels](<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldlabel)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> nodeLabels[oldlabel];</div>
<div class="line">    });</div>
<div class="line"></div>
<div class="line"><span class="comment">// visualize the salient edges as a green overlay</span></div>
<div class="line"><a class="code" href="group__Labeling.html#ga0d13d25c5b735aaca90c5a506bb274ac">regionImageToCrackEdgeImage</a>(labelArray, imageArrayBig,</div>
<div class="line">                            RGBValue&lt;float&gt;( 0, 255, 0), EdgeOverlayOnly);</div>
</div><!-- fragment --><div class="image">
<img src="bears_segmentation.png" alt="bears_segmentation.png"/>
</div>
 </div></div><!-- contents -->
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
vigra 1.11.1 (Fri May 19 2017)
</i>
</tr>
</table>
</BODY>
</HTML>
